<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custard Forecast — Today's Flavor of the Day</title>
  <meta name="description" content="Today's Flavor of the Day forecast for frozen custard shops. See confirmed flavors and predictions for the week ahead.">
  <meta property="og:title" content="Custard Forecast — Today's Flavor of the Day">
  <meta property="og:description" content="Today's Flavor of the Day forecast for frozen custard shops near you.">
  <meta property="og:url" content="https://custard.chriskaschner.com/">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://custard.chriskaschner.com/og-calendar.png">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%8D%A6%3C/text%3E%3C/svg%3E">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#003366">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header class="forecast-header">
    <h1 style="color:#003366;font-size:1.5rem;">Custard Forecast</h1>
    <p style="color:#666;margin-top:0.25rem;font-size:0.875rem;">Today's flavor and the week ahead</p>

    <div class="location-bar">
      <div class="location-bar-inner">
        <div class="location-input-wrap">
          <input type="text" id="store-search" placeholder="Find your store..." autocomplete="off">
          <button id="geo-btn" class="location-geo-btn" title="Use my location">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"/>
              <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
            </svg>
          </button>
        </div>
        <div id="store-dropdown" class="store-dropdown" hidden></div>
        <div id="current-store" class="current-store-badge" hidden>
          <span id="current-store-name"></span>
          <button id="change-store-btn" class="change-store-btn">change</button>
        </div>
      </div>
    </div>

    <nav class="nav-links" style="margin-top:0.75rem;">
      <a href="index.html" class="nav-active">Forecast</a>
      <a href="calendar.html">Calendar</a>
      <a href="map.html">Map</a>
      <a href="radar.html">Radar</a>
      <a href="alerts.html">Alerts</a>
      <a href="siri.html">Siri</a>
    </nav>
  </header>

  <main>
    <!-- Empty state: no store selected -->
    <section id="empty-state">
      <div class="hero-empty">
        <h2>What's scooping today?</h2>
        <p>Pick your store to see today's flavor and the week ahead.</p>
        <button class="btn-primary" id="find-store-btn">Find your store</button>
      </div>
    </section>

    <!-- Loading skeleton -->
    <section id="today-loading" hidden>
      <div class="today-card-skeleton">
        <div class="skeleton-line skeleton-short"></div>
        <div class="skeleton-line skeleton-long"></div>
        <div class="skeleton-line skeleton-medium"></div>
        <div class="skeleton-line skeleton-short"></div>
      </div>
    </section>

    <!-- Error state -->
    <section id="error-state" hidden>
      <div class="error-card">
        <p id="error-message">Something went wrong loading the forecast.</p>
        <button class="btn-retry" id="retry-btn">Try again</button>
      </div>
    </section>

    <!-- Today's flavor hero card -->
    <section id="today-section" hidden>
      <div class="today-card">
        <div class="today-card-accent" id="today-accent"></div>
        <div class="today-card-body">
          <div class="today-card-header">
            <span class="today-card-label">Today's Flavor</span>
            <span id="today-badge" class="day-card-badge"></span>
          </div>
          <div class="today-flavor-body">
            <div class="today-flavor-cone" id="today-cone"></div>
            <div class="today-flavor-content">
              <div class="today-flavor-name" id="today-flavor"></div>
              <div class="today-flavor-desc" id="today-desc"></div>
            </div>
          </div>
          <div class="today-predictions" id="today-predictions"></div>
          <div class="today-meta">
            <span class="today-store" id="today-store"></span>
            <span class="freshness-ts" id="today-freshness"></span>
          </div>
        </div>
      </div>
    </section>

    <!-- Week strip -->
    <section id="week-section" hidden>
      <div class="week-header">
        <h2>Week Ahead</h2>
        <span class="freshness-ts" id="week-freshness"></span>
      </div>
      <div class="week-strip" id="week-strip"></div>
    </section>

    <!-- Quick actions -->
    <section id="actions-section">
      <div class="quick-actions">
        <a href="calendar.html" class="action-card">
          <span class="action-icon">&#x1F4C5;</span>
          <span class="action-label">Calendar</span>
          <span class="action-hint">Subscribe to daily flavors</span>
        </a>
        <a href="map.html" class="action-card">
          <span class="action-icon">&#x1F5FA;</span>
          <span class="action-label">Map</span>
          <span class="action-hint">Find shops nearby</span>
        </a>
        <a href="alerts.html" class="action-card">
          <span class="action-icon">&#x1F514;</span>
          <span class="action-label">Alerts</span>
          <span class="action-hint">Email when favorites hit</span>
        </a>
        <a href="siri.html" class="action-card">
          <span class="action-icon">&#x1F3A4;</span>
          <span class="action-label">Siri</span>
          <span class="action-hint">Ask Siri for today's flavor</span>
        </a>
        <a href="radar.html" class="action-card">
          <span class="action-icon">&#x1F4CA;</span>
          <span class="action-label">Radar</span>
          <span class="action-hint">7-day deep forecast</span>
        </a>
      </div>
    </section>
  </main>

  <footer>
    <div class="footer-brands">Culver's / Kopp's / Gille's / Hefner's / Kraverz / Oscar's</div>
    <div class="footer-links">
      <a href="https://github.com/chriskaschner/custard-calendar">GitHub</a>
    </div>
    <p style="margin-top:0.5rem;">Not affiliated with any restaurant. Flavor data sourced from restaurant websites.</p>
  </footer>

  <script>
    const WORKER_BASE = 'https://custard-calendar.chris-kaschner.workers.dev';

    let flavorColorData = null;

    async function loadFlavorColors() {
      try {
        var resp = await fetch(WORKER_BASE + '/api/v1/flavor-colors');
        if (resp.ok) flavorColorData = await resp.json();
      } catch (e) {}
    }

    function getFlavorProfileLocal(flavorName) {
      if (!flavorColorData || !flavorName) return null;
      var key = flavorName.toLowerCase();
      var profiles = flavorColorData.profiles || {};
      if (profiles[key]) return profiles[key];
      var norm = key.replace(/\u2019/g, "'").replace(/\u2018/g, "'");
      if (profiles[norm]) return profiles[norm];
      return null;
    }

    function getFlavorBaseColor(flavorName) {
      if (!flavorColorData || !flavorName) return null;
      var key = flavorName.toLowerCase();
      var profiles = flavorColorData.profiles || {};
      var bc = flavorColorData.base_colors || {};
      if (profiles[key]) return bc[profiles[key].base] || null;
      var norm = key.replace(/\u2019/g, "'").replace(/\u2018/g, "'");
      if (profiles[norm]) return bc[profiles[norm].base] || null;
      if (key.includes('mint')) return bc.mint;
      if (key.includes('dark choc')) return bc.dark_chocolate;
      if (key.includes('chocolate') || key.includes('cocoa')) return bc.chocolate;
      if (key.includes('strawberry')) return bc.strawberry;
      if (key.includes('cheesecake')) return bc.cheesecake;
      if (key.includes('caramel')) return bc.caramel;
      if (key.includes('peach')) return bc.peach;
      if (key.includes('butter pecan')) return bc.butter_pecan;
      return bc.vanilla || null;
    }

    function resolveToppingSlots(profile) {
      var tops = (profile && profile.toppings) || [];
      var density = (profile && profile.density) || 'standard';
      if (density === 'pure') return [];
      if (density === 'double') {
        var sl = tops.length > 0 ? [tops[0], tops[0]] : [];
        if (tops.length > 1) sl.push(tops[1]);
        return sl;
      }
      if (density === 'explosion') return tops.slice(0, 4);
      if (density === 'overload') return tops.length > 0 ? [tops[0], tops[0]] : [];
      return tops.slice(0, 4);
    }

    function renderMiniConeSVG(flavorName, scale) {
      if (!flavorColorData || !flavorName) return '';
      var bc = flavorColorData.base_colors || {};
      var rc = flavorColorData.ribbon_colors || {};
      var tc = flavorColorData.topping_colors || {};
      var cc = flavorColorData.cone_colors || { waffle: '#D2691E', waffle_dark: '#B8860B' };
      var profile = getFlavorProfileLocal(flavorName);
      var baseColor = (profile ? bc[profile.base] : null) || getFlavorBaseColor(flavorName) || '#F5DEB3';
      var ribbonKey = profile ? profile.ribbon : null;
      var hasRibbon = ribbonKey && (!profile || profile.density !== 'pure');
      var ribbonColor = hasRibbon ? (rc[ribbonKey] || null) : null;
      var tSlotKeys = resolveToppingSlots(profile);
      var s = scale || 5;
      var rects = [];
      // Scoop base fill (rounded top + bottom)
      var scoopRows = [[2,6],[1,7],[1,7],[1,7],[1,7],[2,6]];
      for (var row = 0; row < scoopRows.length; row++) {
        var sc = scoopRows[row][0], ec = scoopRows[row][1];
        for (var col = sc; col <= ec; col++) {
          rects.push('<rect x="' + (col*s) + '" y="' + (row*s) + '" width="' + s + '" height="' + s + '" fill="' + baseColor + '"/>');
        }
      }
      // Fixed topping slots: T1(2,1) T2(6,1) T3(3,3) T4(5,2)
      var tSlots = [[2,1],[6,1],[3,3],[5,2]];
      for (var ti = 0; ti < tSlotKeys.length && ti < tSlots.length; ti++) {
        if (ti === 3 && hasRibbon) continue;
        var tColor = tc[tSlotKeys[ti]];
        if (!tColor) continue;
        rects.push('<rect x="' + (tSlots[ti][0]*s) + '" y="' + (tSlots[ti][1]*s) + '" width="' + s + '" height="' + s + '" fill="' + tColor + '"/>');
      }
      // Fixed ribbon slots: R1(3,0) R2(4,1) R3(5,2)
      if (ribbonColor) {
        var rSlots = [[3,0],[4,1],[5,2]];
        for (var ri = 0; ri < rSlots.length; ri++) {
          rects.push('<rect x="' + (rSlots[ri][0]*s) + '" y="' + (rSlots[ri][1]*s) + '" width="' + s + '" height="' + s + '" fill="' + ribbonColor + '"/>');
        }
      }
      // Cone checkerboard (rows 6-9) + tip (row 10)
      var coneRows = [[2,6],[2,6],[3,5],[3,5]];
      for (var cr = 0; cr < coneRows.length; cr++) {
        var csc = coneRows[cr][0], cec = coneRows[cr][1];
        for (var col2 = csc; col2 <= cec; col2++) {
          var wc = ((cr + col2) % 2 === 0) ? cc.waffle : cc.waffle_dark;
          rects.push('<rect x="' + (col2*s) + '" y="' + ((cr+6)*s) + '" width="' + s + '" height="' + s + '" fill="' + wc + '"/>');
        }
      }
      rects.push('<rect x="' + (4*s) + '" y="' + (10*s) + '" width="' + s + '" height="' + s + '" fill="' + cc.waffle_dark + '"/>');
      return '<svg class="mini-cone" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ' + (9*s) + ' ' + (11*s) + '" width="' + (9*s) + '" height="' + (11*s) + '" shape-rendering="crispEdges">' + rects.join('') + '</svg>';
    }

    function lightenHex(hex, amount) {
      var r = parseInt(hex.slice(1, 3), 16);
      var g = parseInt(hex.slice(3, 5), 16);
      var b = parseInt(hex.slice(5, 7), 16);
      var lr = Math.round(r + (255 - r) * amount);
      var lg = Math.round(g + (255 - g) * amount);
      var lb = Math.round(b + (255 - b) * amount);
      return '#' + [lr, lg, lb].map(function(c) { return c.toString(16).padStart(2, '0'); }).join('').toUpperCase();
    }

    function resolveHDToppingSlots(profile) {
      var tops = (profile && profile.toppings) || [];
      var density = (profile && profile.density) || 'standard';
      if (density === 'pure') return [];
      if (density === 'double') {
        var sl = tops.length > 0 ? [tops[0], tops[0], tops[0]] : [];
        if (tops.length > 1) { sl.push(tops[1]); sl.push(tops[1]); }
        return sl;
      }
      if (density === 'explosion') {
        var slots = [];
        for (var i = 0; i < 8; i++) slots.push(tops[i % tops.length]);
        return slots;
      }
      if (density === 'overload') return tops.length > 0 ? [tops[0], tops[0], tops[0], tops[0]] : [];
      return tops.slice(0, 4);
    }

    function renderMiniConeHDSVG(flavorName, scale) {
      if (!flavorColorData || !flavorName) return '';
      var bc = flavorColorData.base_colors || {};
      var rc = flavorColorData.ribbon_colors || {};
      var tc = flavorColorData.topping_colors || {};
      var cc = flavorColorData.cone_colors || { waffle: '#D2691E', waffle_dark: '#B8860B' };
      var CONE_TIP = '#8B5A2B';

      var profile = getFlavorProfileLocal(flavorName);
      var baseColor = (profile ? bc[profile.base] : null) || getFlavorBaseColor(flavorName) || '#F5DEB3';
      var ribbonKey = profile ? profile.ribbon : null;
      var hasRibbon = ribbonKey && (!profile || profile.density !== 'pure');
      var ribbonColor = hasRibbon ? (rc[ribbonKey] || null) : null;
      var tSlotKeys = resolveHDToppingSlots(profile);
      var highlightColor = lightenHex(baseColor, 0.3);

      var s = scale || 5;
      var rects = [];

      var scoopRows = [[4,13],[2,15],[2,15],[2,15],[2,15],[2,15],[2,15],[2,15],[2,15],[2,15],[2,15],[4,13]];
      for (var row = 0; row < scoopRows.length; row++) {
        var sc = scoopRows[row][0], ec = scoopRows[row][1];
        for (var col = sc; col <= ec; col++) {
          rects.push('<rect x="' + (col*s) + '" y="' + (row*s) + '" width="' + s + '" height="' + s + '" fill="' + baseColor + '"/>');
        }
      }

      var hlSlots = [[4,0],[3,1]];
      for (var hi = 0; hi < hlSlots.length; hi++) {
        rects.push('<rect x="' + (hlSlots[hi][0]*s) + '" y="' + (hlSlots[hi][1]*s) + '" width="' + s + '" height="' + s + '" fill="' + highlightColor + '"/>');
      }

      var tSlots = [[4,2],[13,2],[3,4],[14,4],[5,6],[12,6],[4,8],[13,8]];
      for (var ti = 0; ti < tSlotKeys.length && ti < tSlots.length; ti++) {
        var tColor = tc[tSlotKeys[ti]];
        if (!tColor) continue;
        rects.push('<rect x="' + (tSlots[ti][0]*s) + '" y="' + (tSlots[ti][1]*s) + '" width="' + s + '" height="' + s + '" fill="' + tColor + '"/>');
      }

      if (ribbonColor) {
        var rSlots = [[7,1],[8,3],[9,4],[10,5],[9,7],[8,9]];
        for (var ri = 0; ri < rSlots.length; ri++) {
          rects.push('<rect x="' + (rSlots[ri][0]*s) + '" y="' + (rSlots[ri][1]*s) + '" width="' + s + '" height="' + s + '" fill="' + ribbonColor + '"/>');
        }
      }

      var coneRows = [[4,13],[4,13],[5,12],[5,12],[6,11],[6,11],[7,10],[7,10],[8,9]];
      for (var cr = 0; cr < coneRows.length; cr++) {
        var csc = coneRows[cr][0], cec = coneRows[cr][1];
        for (var col2 = csc; col2 <= cec; col2++) {
          var wc = ((cr + col2) % 2 === 0) ? cc.waffle : cc.waffle_dark;
          rects.push('<rect x="' + (col2*s) + '" y="' + ((cr+12)*s) + '" width="' + s + '" height="' + s + '" fill="' + wc + '"/>');
        }
      }
      rects.push('<rect x="' + (8*s) + '" y="' + (21*s) + '" width="' + s + '" height="' + s + '" fill="' + CONE_TIP + '"/>');
      rects.push('<rect x="' + (9*s) + '" y="' + (21*s) + '" width="' + s + '" height="' + s + '" fill="' + CONE_TIP + '"/>');

      return '<svg class="mini-cone" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ' + (18*s) + ' ' + (22*s) + '" width="' + (18*s) + '" height="' + (22*s) + '" shape-rendering="crispEdges">' + rects.join('') + '</svg>';
    }

    const BRAND_COLORS = {
      culvers: '#005696',
      kopps: '#000000',
      gilles: '#EBCC35',
      hefners: '#93BE46',
      kraverz: '#CE742D',
      oscars: '#BC272C',
    };

    const BRAND_DISPLAY = {
      kopps: "Kopp's",
      gilles: "Gille's",
      hefners: "Hefner's",
      kraverz: "Kraverz",
      oscars: "Oscar's",
    };

    // Brand detection from slug (mirrors Worker's BRAND_REGISTRY)
    function brandFromSlug(slug) {
      if (!slug) return 'culvers';
      if (slug.startsWith('kopps-')) return 'kopps';
      if (slug === 'gilles') return 'gilles';
      if (slug === 'hefners') return 'hefners';
      if (slug === 'kraverz') return 'kraverz';
      if (slug.startsWith('oscars')) return 'oscars';
      return 'culvers';
    }

    let allStores = [];
    let currentSlug = null;
    let userLat = null;
    let userLng = null;

    // DOM refs
    const storeSearch = document.getElementById('store-search');
    const storeDropdown = document.getElementById('store-dropdown');
    const currentStoreEl = document.getElementById('current-store');
    const currentStoreName = document.getElementById('current-store-name');
    const changeStoreBtn = document.getElementById('change-store-btn');
    const geoBtn = document.getElementById('geo-btn');
    const findStoreBtn = document.getElementById('find-store-btn');
    const emptyState = document.getElementById('empty-state');
    const todayLoading = document.getElementById('today-loading');
    const errorState = document.getElementById('error-state');
    const errorMessage = document.getElementById('error-message');
    const retryBtn = document.getElementById('retry-btn');
    const todaySection = document.getElementById('today-section');
    const todayAccent = document.getElementById('today-accent');
    const todayBadge = document.getElementById('today-badge');
    const todayFlavor = document.getElementById('today-flavor');
    const todayCone = document.getElementById('today-cone');
    const todayDesc = document.getElementById('today-desc');
    const todayPredictions = document.getElementById('today-predictions');
    const todayStore = document.getElementById('today-store');
    const todayFreshness = document.getElementById('today-freshness');
    const weekSection = document.getElementById('week-section');
    const weekStrip = document.getElementById('week-strip');
    const weekFreshness = document.getElementById('week-freshness');

    // --- Utility ---
    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function toISODate(d) {
      return d.toISOString().slice(0, 10);
    }

    function addDays(d, n) {
      const r = new Date(d);
      r.setDate(r.getDate() + n);
      return r;
    }

    function timeSince(isoStr) {
      if (!isoStr) return '';
      const diff = Date.now() - new Date(isoStr).getTime();
      const mins = Math.floor(diff / 60000);
      if (mins < 1) return 'just now';
      if (mins < 60) return mins + ' min ago';
      const hrs = Math.floor(mins / 60);
      if (hrs < 24) return hrs + ' hr ago';
      const days = Math.floor(hrs / 24);
      return days + 'd ago';
    }

    function haversine(lat1, lng1, lat2, lng2) {
      const R = 3958.8;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLng / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    // --- Store loading ---
    async function loadStores() {
      try {
        const resp = await fetch('stores.json?v=' + new Date().toISOString().slice(0, 10));
        const data = await resp.json();
        allStores = data.stores || [];
      } catch (err) {
        console.error('Failed to load stores:', err);
      }
    }

    // --- Store picker ---
    function filterStores(query) {
      const q = query.toLowerCase().trim();
      if (!q) return [];
      let filtered = allStores.filter(s => {
        const searchable = (s.name + ' ' + s.city + ' ' + (s.address || '') + ' ' + s.slug + ' ' + (s.brand || '') + ' ' + (BRAND_DISPLAY[s.brand] || '')).toLowerCase();
        return searchable.includes(q);
      });

      // Sort by distance if available
      if (userLat !== null && userLng !== null) {
        filtered = filtered.map(s => {
          s._dist = (s.lat != null && s.lng != null)
            ? haversine(userLat, userLng, s.lat, s.lng) : Infinity;
          return s;
        }).sort((a, b) => a._dist - b._dist);
      }

      return filtered.slice(0, 8);
    }

    function renderDropdown(stores) {
      if (stores.length === 0) {
        storeDropdown.hidden = true;
        return;
      }
      storeDropdown.innerHTML = '';
      for (const store of stores) {
        const item = document.createElement('div');
        item.className = 'store-dropdown-item';
        const brand = store.brand ? (BRAND_DISPLAY[store.brand] || store.brand) : '';
        const prefix = brand ? brand + ' \u2014 ' : '';
        const dist = (store._dist != null && store._dist !== Infinity) ? ' (' + store._dist.toFixed(1) + ' mi)' : '';
        item.innerHTML = '<div class="store-dropdown-name">' + escapeHtml(prefix + store.name) + '</div>'
          + '<div class="store-dropdown-detail">' + escapeHtml(store.city + ', ' + store.state + ' \u2014 ' + (store.address || '')) + escapeHtml(dist) + '</div>';
        item.addEventListener('click', () => selectStore(store.slug));
        storeDropdown.appendChild(item);
      }
      storeDropdown.hidden = false;
    }

    function selectStore(slug) {
      currentSlug = slug;
      const store = allStores.find(s => s.slug === slug);
      if (!store) return;

      // Save to localStorage (shared with calendar page)
      try { localStorage.setItem('custard-primary', slug); } catch (e) {}

      // Update UI
      const brand = store.brand ? (BRAND_DISPLAY[store.brand] || store.brand) + ' \u2014 ' : '';
      currentStoreName.textContent = brand + store.city + ', ' + store.state + ' \u2014 ' + (store.address || '');
      currentStoreEl.hidden = false;
      storeSearch.value = '';
      storeDropdown.hidden = true;
      emptyState.hidden = true;

      loadForecast(slug);
    }

    function showStorePicker() {
      currentStoreEl.hidden = true;
      storeSearch.value = '';
      storeSearch.focus();
    }

    // --- Geolocation ---
    async function geolocateAndSort() {
      geoBtn.disabled = true;
      try {
        // Try browser geolocation first
        const pos = await new Promise((resolve, reject) => {
          if (!navigator.geolocation) return reject(new Error('No geolocation'));
          navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 5000 });
        });
        userLat = pos.coords.latitude;
        userLng = pos.coords.longitude;
      } catch (e) {
        // Fall back to IP-based
        try {
          const resp = await fetch(WORKER_BASE + '/api/v1/geolocate');
          const geo = await resp.json();
          if (geo.lat && geo.lon) {
            userLat = geo.lat;
            userLng = geo.lon;
          }
        } catch (err) {
          console.debug('Geolocation unavailable:', err);
        }
      }
      geoBtn.disabled = false;
      // If we got coords, show sorted results immediately
      if (userLat !== null && allStores.length > 0) {
        const sorted = allStores.map(s => {
          s._dist = (s.lat != null && s.lng != null) ? haversine(userLat, userLng, s.lat, s.lng) : Infinity;
          return s;
        }).sort((a, b) => a._dist - b._dist);
        renderDropdown(sorted.slice(0, 8));
        storeSearch.focus();
      }
    }

    // --- Forecast loading ---
    async function loadForecast(slug) {
      // Show loading
      todaySection.hidden = true;
      weekSection.hidden = true;
      errorState.hidden = true;
      todayLoading.hidden = false;

      try {
        const [flavorsResp, forecastResp] = await Promise.all([
          fetch(WORKER_BASE + '/api/v1/flavors?slug=' + encodeURIComponent(slug)),
          fetch(WORKER_BASE + '/api/v1/forecast/' + encodeURIComponent(slug)),
        ]);

        let confirmedFlavors = [];
        let fetchedAt = null;
        if (flavorsResp.ok) {
          const cData = await flavorsResp.json();
          confirmedFlavors = (cData.flavors || []).map(f => ({
            date: f.date,
            title: f.title,
            description: f.description || '',
          }));
          fetchedAt = cData.fetched_at || null;
        }

        let forecast = null;
        if (forecastResp.ok) {
          forecast = await forecastResp.json();
        }

        const today = new Date();
        today.setHours(12, 0, 0, 0);
        const timeline = buildTimeline(confirmedFlavors, forecast, today);

        todayLoading.hidden = true;

        if (timeline.length > 0) {
          renderTodayCard(timeline[0], slug, fetchedAt, forecast);
          renderWeekStrip(timeline.slice(1), fetchedAt);
        } else {
          renderTodayCard({ date: toISODate(today), type: 'none' }, slug, fetchedAt, forecast);
        }
      } catch (err) {
        console.error('Forecast load error:', err);
        todayLoading.hidden = true;
        errorMessage.textContent = 'Something went wrong loading the forecast.';
        errorState.hidden = false;
      }
    }

    function buildTimeline(confirmedFlavors, forecast, today) {
      const timeline = [];
      for (let i = 0; i < 7; i++) {
        const date = addDays(today, i);
        const dateStr = toISODate(date);

        const confirmed = confirmedFlavors.find(f => f.date === dateStr);
        if (confirmed) {
          timeline.push({ date: dateStr, type: 'confirmed', flavor: confirmed.title, description: confirmed.description || '' });
          continue;
        }

        const forecastDay = forecast && forecast.days
          ? forecast.days.find(d => d.date === dateStr)
          : null;
        if (forecastDay && forecastDay.predictions && forecastDay.predictions.length > 0) {
          timeline.push({
            date: dateStr,
            type: 'predicted',
            flavor: forecastDay.predictions[0].flavor,
            probability: forecastDay.predictions[0].probability,
            predictions: forecastDay.predictions.slice(0, 3),
          });
          continue;
        }

        timeline.push({ date: dateStr, type: 'none' });
      }
      return timeline;
    }

    // --- Rendering ---
    function renderTodayCard(day, slug, fetchedAt, forecast) {
      const store = allStores.find(s => s.slug === slug);
      const brand = brandFromSlug(slug);
      const color = BRAND_COLORS[brand] || '#005696';
      todayAccent.style.background = color;

      if (day.type === 'confirmed') {
        todayBadge.textContent = 'Confirmed';
        todayBadge.className = 'day-card-badge day-card-badge-confirmed';
        todayCone.innerHTML = renderMiniConeHDSVG(day.flavor, 5);
        todayCone.hidden = false;
        todayFlavor.textContent = day.flavor;
        todayFlavor.style.color = '';
        todayDesc.textContent = day.description || '';
        todayDesc.hidden = !day.description;
        todayPredictions.innerHTML = '';
      } else if (day.type === 'predicted') {
        todayBadge.textContent = 'Predicted';
        todayBadge.className = 'day-card-badge day-card-badge-predicted';
        todayCone.innerHTML = renderMiniConeHDSVG(day.flavor, 5);
        todayCone.hidden = false;
        todayFlavor.textContent = day.flavor;
        todayFlavor.style.color = '';
        todayDesc.textContent = '';
        todayDesc.hidden = true;

        // Show top predictions with bars
        if (day.predictions && day.predictions.length > 0) {
          const maxProb = day.predictions[0].probability || 0.1;
          let html = '';
          for (const p of day.predictions) {
            const pct = (p.probability * 100).toFixed(1);
            const barWidth = Math.max(5, (p.probability / Math.max(maxProb, 0.01)) * 100);
            const conf = p.confidence || (p.probability > 0.10 ? 'high' : p.probability >= 0.05 ? 'medium' : 'low');
            html += '<div class="prediction-row">'
              + '<span class="prediction-name">' + renderMiniConeSVG(p.flavor) + escapeHtml(p.flavor) + '</span>'
              + '<div class="prediction-bar-wrap"><div class="prediction-bar prediction-bar-' + conf + '" style="width:' + barWidth + '%"></div></div>'
              + '<span class="prediction-pct">' + pct + '%</span>'
              + '</div>';
          }
          todayPredictions.innerHTML = html;
        } else {
          todayPredictions.innerHTML = '';
        }
      } else {
        todayBadge.textContent = '';
        todayBadge.className = 'day-card-badge';
        todayCone.innerHTML = '';
        todayCone.hidden = true;
        todayFlavor.textContent = 'No data yet';
        todayFlavor.style.color = '#999';
        todayDesc.textContent = 'Check back later \u2014 flavor data updates throughout the day.';
        todayDesc.hidden = false;
        todayPredictions.innerHTML = '';
      }

      todayStore.textContent = store ? store.name : slug;

      const freshness = fetchedAt ? 'Updated ' + timeSince(fetchedAt) : '';
      todayFreshness.textContent = freshness;

      todaySection.hidden = false;
    }

    function confidenceStripClass(day) {
      if (day.type === 'confirmed') return 'confidence-strip confidence-strip-confirmed';
      if (day.type === 'predicted') {
        var prob = day.probability || 0;
        if (prob > 0.10) return 'confidence-strip confidence-strip-high';
        if (prob >= 0.05) return 'confidence-strip confidence-strip-medium';
        return 'confidence-strip confidence-strip-low';
      }
      return 'confidence-strip confidence-strip-none';
    }

    function formatDateLabel(dateStr) {
      const today = new Date();
      today.setHours(12, 0, 0, 0);
      var todayStr = toISODate(today);
      var tomorrowStr = toISODate(addDays(today, 1));
      if (dateStr === todayStr) return 'Today';
      if (dateStr === tomorrowStr) return 'Tmrw';
      var d = new Date(dateStr + 'T12:00:00');
      return d.toLocaleDateString('en-US', { weekday: 'short' });
    }

    function renderWeekStrip(days, fetchedAt) {
      weekStrip.innerHTML = '';
      const today = new Date();
      today.setHours(12, 0, 0, 0);

      let hasAnyData = false;

      for (const day of days) {
        const d = new Date(day.date + 'T12:00:00');
        const dayName = formatDateLabel(day.date);
        const dateLabel = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

        const card = document.createElement('div');

        if (day.type === 'confirmed') {
          hasAnyData = true;
          card.className = 'week-day-card';
          card.innerHTML =
            '<div class="' + confidenceStripClass(day) + '"></div>'
            + '<div class="week-day-name">' + escapeHtml(dayName) + '</div>'
            + '<div class="week-day-date">' + escapeHtml(dateLabel) + '</div>'
            + '<div style="text-align:center;margin:0.25rem 0;">' + renderMiniConeSVG(day.flavor) + '</div>'
            + '<div class="week-day-flavor">' + escapeHtml(day.flavor) + '</div>'
            + '<div class="week-day-confidence" style="color:#2e7d32;">Confirmed</div>';
        } else if (day.type === 'predicted') {
          hasAnyData = true;
          const pct = day.probability ? (day.probability * 100).toFixed(0) + '%' : '';
          card.className = 'week-day-card week-day-card-predicted';
          card.innerHTML =
            '<div class="' + confidenceStripClass(day) + '"></div>'
            + '<div class="week-day-name">' + escapeHtml(dayName) + '</div>'
            + '<div class="week-day-date">' + escapeHtml(dateLabel) + '</div>'
            + '<div style="text-align:center;margin:0.25rem 0;">' + renderMiniConeSVG(day.flavor) + '</div>'
            + '<div class="week-day-flavor">' + escapeHtml(day.flavor) + '</div>'
            + (pct ? '<div class="week-day-confidence">' + pct + ' likely</div>' : '');
        } else {
          card.className = 'week-day-card week-day-card-none';
          card.innerHTML =
            '<div class="' + confidenceStripClass(day) + '"></div>'
            + '<div class="week-day-name">' + escapeHtml(dayName) + '</div>'
            + '<div class="week-day-date">' + escapeHtml(dateLabel) + '</div>'
            + '<div class="week-day-flavor" style="color:#999;font-style:italic;">No data</div>';
        }

        weekStrip.appendChild(card);
      }

      if (fetchedAt) {
        weekFreshness.textContent = 'Updated ' + timeSince(fetchedAt);
      } else {
        weekFreshness.textContent = '';
      }

      weekSection.hidden = !hasAnyData && days.every(d => d.type === 'none');
    }

    // --- Event handlers ---
    storeSearch.addEventListener('input', () => {
      const q = storeSearch.value.trim();
      if (q.length < 2) {
        storeDropdown.hidden = true;
        return;
      }
      const results = filterStores(q);
      renderDropdown(results);
    });

    storeSearch.addEventListener('focus', () => {
      const q = storeSearch.value.trim();
      if (q.length >= 2) {
        const results = filterStores(q);
        renderDropdown(results);
      }
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.location-bar-inner')) {
        storeDropdown.hidden = true;
      }
    });

    changeStoreBtn.addEventListener('click', showStorePicker);

    findStoreBtn.addEventListener('click', () => {
      storeSearch.focus();
    });

    geoBtn.addEventListener('click', geolocateAndSort);

    retryBtn.addEventListener('click', () => {
      if (currentSlug) {
        errorState.hidden = true;
        loadForecast(currentSlug);
      }
    });

    // --- Init ---
    async function init() {
      await Promise.all([loadStores(), loadFlavorColors()]);

      // Check localStorage for a saved store
      let savedSlug = null;
      try { savedSlug = localStorage.getItem('custard-primary'); } catch (e) {}

      if (savedSlug && allStores.find(s => s.slug === savedSlug)) {
        selectStore(savedSlug);
      } else {
        emptyState.hidden = false;
        todaySection.hidden = true;
        weekSection.hidden = true;
      }
    }

    init();

    // Register service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').catch(() => {});
    }
  </script>
</body>
</html>
