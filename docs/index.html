<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custard Forecast ‚Äî Today's Flavor of the Day</title>
  <meta name="description" content="Today's Flavor of the Day forecast for frozen custard shops. See confirmed flavors and predictions for the week ahead.">
  <meta property="og:title" content="Custard Forecast ‚Äî Today's Flavor of the Day">
  <meta property="og:description" content="Today's Flavor of the Day forecast for frozen custard shops near you.">
  <meta property="og:url" content="https://custard.chriskaschner.com/">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://custard.chriskaschner.com/og-calendar.png">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%8D%A6%3C/text%3E%3C/svg%3E">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#003366">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header class="forecast-header">
    <h1 style="color:#003366;font-size:1.5rem;">Custard Forecast</h1>
    <p style="color:#666;margin-top:0.25rem;font-size:0.875rem;">Today's flavor and the week ahead</p>

    <div class="location-bar">
      <div class="location-bar-inner">
        <div class="location-input-wrap">
          <input type="text" id="store-search" placeholder="Find your store..." autocomplete="off">
          <button id="geo-btn" class="location-geo-btn" title="Use my location">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"/>
              <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
            </svg>
          </button>
        </div>
        <div id="store-dropdown" class="store-dropdown" hidden></div>
        <div id="current-store" class="current-store-badge" hidden>
          <span id="current-store-name"></span>
          <button id="change-store-btn" class="change-store-btn">change</button>
        </div>
      </div>
    </div>

    <nav class="nav-links" style="margin-top:0.75rem;">
      <a href="index.html" class="nav-active">Forecast</a>
      <a href="calendar.html">Calendar</a>
      <a href="map.html">Map</a>
      <a href="radar.html">Radar</a>
      <a href="alerts.html">Alerts</a>
      <a href="siri.html">Siri</a>
      <a href="forecast-map.html">Fronts</a>
    </nav>
  </header>

  <main>
    <!-- Empty state: no store selected -->
    <section id="empty-state">
      <div class="hero-empty">
        <p class="hero-kicker">New here?</p>
        <h2>Forecast frozen custard flavors before you go.</h2>
        <p class="hero-subtitle">Custard Calendar tracks daily flavor schedules across 1,000+ stores so you can check today's scoop and the week ahead in one place.</p>
        <div class="hero-cta-row">
          <button class="btn-primary" id="find-store-btn">Find your store</button>
          <a href="map.html" class="btn-secondary">Browse coverage map</a>
        </div>
        <p class="hero-coverage">Coverage is strongest across Culver's locations nationwide plus Milwaukee-area independents: Kopp's, Gille's, Hefner's, Kraverz, and Oscar's.</p>
      </div>
      <div class="first-visit-guide">
        <h3>Start in 3 steps</h3>
        <ol>
          <li>Pick a store above, or use one of the quick start stores below.</li>
          <li>Check today's confirmed flavor and your week-ahead forecast.</li>
          <li>Use Calendar or Alerts so you do not miss favorite flavors.</li>
        </ol>
        <div id="quick-start-wrap" class="quick-start-wrap" hidden>
          <span class="quick-start-label">Quick start stores:</span>
          <div id="quick-start-stores" class="quick-start-stores"></div>
        </div>
      </div>
    </section>

    <!-- Loading skeleton -->
    <section id="today-loading" hidden>
      <div class="today-card-skeleton">
        <div class="skeleton-line skeleton-short"></div>
        <div class="skeleton-line skeleton-long"></div>
        <div class="skeleton-line skeleton-medium"></div>
        <div class="skeleton-line skeleton-short"></div>
      </div>
    </section>

    <!-- Error state -->
    <section id="error-state" hidden>
      <div class="error-card">
        <p id="error-message">Something went wrong loading the forecast.</p>
        <button class="btn-retry" id="retry-btn">Try again</button>
      </div>
    </section>

    <!-- Today's flavor hero card -->
    <section id="today-section" hidden>
      <div class="today-card">
        <div class="today-card-accent" id="today-accent"></div>
        <div class="today-card-body">
          <div class="today-card-header">
            <span class="today-card-label">Today's Flavor</span>
            <span id="today-badge" class="day-card-badge"></span>
          </div>
          <div class="today-flavor-body">
            <div class="today-flavor-cone" id="today-cone"></div>
            <div class="today-flavor-content">
              <div class="today-flavor-name" id="today-flavor"></div>
              <div class="today-flavor-desc" id="today-desc"></div>
              <div class="today-rarity" id="today-rarity" hidden></div>
            </div>
          </div>
          <div class="today-predictions" id="today-predictions"></div>
          <div class="today-meta">
            <span class="today-store" id="today-store"></span>
            <span class="freshness-ts" id="today-freshness"></span>
          </div>
        </div>
      </div>
    </section>

    <!-- Week strip -->
    <section id="week-section" hidden>
      <div class="week-header">
        <h2>Week Ahead</h2>
        <span class="freshness-ts" id="week-freshness"></span>
      </div>
      <div class="week-strip" id="week-strip"></div>
    </section>

    <section id="calendar-preview-section" class="calendar-preview-section">
      <div class="calendar-preview-head">
        <div>
          <h2>Calendar Preview</h2>
          <p>How your flavor subscription appears in calendar apps.</p>
        </div>
        <a href="calendar.html" class="calendar-preview-link">Set up subscription</a>
      </div>
      <div class="calendar-preview-grid">
        <article class="calendar-preview-surface">
          <h3 class="calendar-preview-app">Google Calendar style</h3>
          <div class="cal-event calendar-preview-event">
            <div id="sample-google-color" class="cal-event-color"></div>
            <div class="cal-event-body">
              <div id="sample-google-title" class="cal-event-title">üç¶ Flavor Preview</div>
              <div id="sample-google-date" class="cal-event-date"></div>
              <div id="sample-google-location" class="cal-event-location"></div>
              <div id="sample-google-desc" class="cal-event-desc"></div>
            </div>
          </div>
        </article>
        <article class="calendar-preview-surface">
          <h3 class="calendar-preview-app">Apple Calendar style</h3>
          <div class="apple-cal-card">
            <div class="apple-cal-row">
              <span id="sample-apple-dot" class="apple-cal-dot"></span>
              <div class="apple-cal-main">
                <div id="sample-apple-title" class="apple-cal-title">Flavor Preview</div>
                <div id="sample-apple-meta" class="apple-cal-meta"></div>
                <div id="sample-apple-location" class="apple-cal-location"></div>
              </div>
            </div>
          </div>
        </article>
      </div>
    </section>

  </main>

  <footer>
    <div class="footer-brands">Culver's / Kopp's / Gille's / Hefner's / Kraverz / Oscar's</div>
    <div class="footer-links">
      <a href="https://github.com/chriskaschner/custard-calendar">GitHub</a>
    </div>
    <p style="margin-top:0.5rem;">Not affiliated with any restaurant. Flavor data sourced from restaurant websites.</p>
  </footer>

  <script>
    const WORKER_BASE = 'https://custard-calendar.chris-kaschner.workers.dev';

    let flavorColorData = null;

    async function loadFlavorColors() {
      try {
        var resp = await fetch(WORKER_BASE + '/api/v1/flavor-colors');
        if (resp.ok) flavorColorData = await resp.json();
      } catch (e) {}
    }

    function getFlavorProfileLocal(flavorName) {
      if (!flavorColorData || !flavorName) return null;
      var key = flavorName.toLowerCase();
      var profiles = flavorColorData.profiles || {};
      if (profiles[key]) return profiles[key];
      var norm = key.replace(/\u2019/g, "'").replace(/\u2018/g, "'");
      if (profiles[norm]) return profiles[norm];
      return null;
    }

    function getFlavorBaseColor(flavorName) {
      if (!flavorColorData || !flavorName) return null;
      var key = flavorName.toLowerCase();
      var profiles = flavorColorData.profiles || {};
      var bc = flavorColorData.base_colors || {};
      if (profiles[key]) return bc[profiles[key].base] || null;
      var norm = key.replace(/\u2019/g, "'").replace(/\u2018/g, "'");
      if (profiles[norm]) return bc[profiles[norm].base] || null;
      if (key.includes('mint')) return bc.mint;
      if (key.includes('dark choc')) return bc.dark_chocolate;
      if (key.includes('chocolate') || key.includes('cocoa')) return bc.chocolate;
      if (key.includes('strawberry')) return bc.strawberry;
      if (key.includes('cheesecake')) return bc.cheesecake;
      if (key.includes('caramel')) return bc.caramel;
      if (key.includes('peach')) return bc.peach;
      if (key.includes('butter pecan')) return bc.butter_pecan;
      return bc.vanilla || null;
    }

    function resolveToppingSlots(profile) {
      var tops = (profile && profile.toppings) || [];
      var density = (profile && profile.density) || 'standard';
      if (density === 'pure') return [];
      if (density === 'double') {
        var sl = tops.length > 0 ? [tops[0], tops[0]] : [];
        if (tops.length > 1) sl.push(tops[1]);
        return sl;
      }
      if (density === 'explosion') return tops.slice(0, 4);
      if (density === 'overload') return tops.length > 0 ? [tops[0], tops[0]] : [];
      return tops.slice(0, 4);
    }

    function renderMiniConeSVG(flavorName, scale) {
      if (!flavorColorData || !flavorName) return '';
      var bc = flavorColorData.base_colors || {};
      var rc = flavorColorData.ribbon_colors || {};
      var tc = flavorColorData.topping_colors || {};
      var cc = flavorColorData.cone_colors || { waffle: '#D2691E', waffle_dark: '#B8860B' };
      var profile = getFlavorProfileLocal(flavorName);
      var baseColor = (profile ? bc[profile.base] : null) || getFlavorBaseColor(flavorName) || '#F5DEB3';
      var ribbonKey = profile ? profile.ribbon : null;
      var hasRibbon = ribbonKey && (!profile || profile.density !== 'pure');
      var ribbonColor = hasRibbon ? (rc[ribbonKey] || null) : null;
      var tSlotKeys = resolveToppingSlots(profile);
      var s = scale || 5;
      var rects = [];
      // Scoop base fill (rounded top + bottom)
      var scoopRows = [[2,6],[1,7],[1,7],[1,7],[1,7],[2,6]];
      for (var row = 0; row < scoopRows.length; row++) {
        var sc = scoopRows[row][0], ec = scoopRows[row][1];
        for (var col = sc; col <= ec; col++) {
          rects.push('<rect x="' + (col*s) + '" y="' + (row*s) + '" width="' + s + '" height="' + s + '" fill="' + baseColor + '"/>');
        }
      }
      // Fixed topping slots: T1(2,1) T2(6,1) T3(3,3) T4(5,2)
      var tSlots = [[2,1],[6,1],[3,3],[5,2]];
      for (var ti = 0; ti < tSlotKeys.length && ti < tSlots.length; ti++) {
        if (ti === 3 && hasRibbon) continue;
        var tColor = tc[tSlotKeys[ti]];
        if (!tColor) continue;
        rects.push('<rect x="' + (tSlots[ti][0]*s) + '" y="' + (tSlots[ti][1]*s) + '" width="' + s + '" height="' + s + '" fill="' + tColor + '"/>');
      }
      // Fixed ribbon slots: R1(3,0) R2(4,1) R3(5,2)
      if (ribbonColor) {
        var rSlots = [[3,0],[4,1],[5,2]];
        for (var ri = 0; ri < rSlots.length; ri++) {
          rects.push('<rect x="' + (rSlots[ri][0]*s) + '" y="' + (rSlots[ri][1]*s) + '" width="' + s + '" height="' + s + '" fill="' + ribbonColor + '"/>');
        }
      }
      // Cone checkerboard (rows 6-9) + tip (row 10)
      var coneRows = [[2,6],[2,6],[3,5],[3,5]];
      for (var cr = 0; cr < coneRows.length; cr++) {
        var csc = coneRows[cr][0], cec = coneRows[cr][1];
        for (var col2 = csc; col2 <= cec; col2++) {
          var wc = ((cr + col2) % 2 === 0) ? cc.waffle : cc.waffle_dark;
          rects.push('<rect x="' + (col2*s) + '" y="' + ((cr+6)*s) + '" width="' + s + '" height="' + s + '" fill="' + wc + '"/>');
        }
      }
      rects.push('<rect x="' + (4*s) + '" y="' + (10*s) + '" width="' + s + '" height="' + s + '" fill="' + cc.waffle_dark + '"/>');
      return '<svg class="mini-cone" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ' + (9*s) + ' ' + (11*s) + '" width="' + (9*s) + '" height="' + (11*s) + '" shape-rendering="crispEdges">' + rects.join('') + '</svg>';
    }

    function lightenHex(hex, amount) {
      var r = parseInt(hex.slice(1, 3), 16);
      var g = parseInt(hex.slice(3, 5), 16);
      var b = parseInt(hex.slice(5, 7), 16);
      var lr = Math.round(r + (255 - r) * amount);
      var lg = Math.round(g + (255 - g) * amount);
      var lb = Math.round(b + (255 - b) * amount);
      return '#' + [lr, lg, lb].map(function(c) { return c.toString(16).padStart(2, '0'); }).join('').toUpperCase();
    }

    function resolveHDToppingSlots(profile) {
      var tops = (profile && profile.toppings) || [];
      var density = (profile && profile.density) || 'standard';
      if (density === 'pure') return [];
      if (density === 'double') {
        if (tops.length === 0) return [];
        var primary = tops[0];
        var secondary = tops[1] || primary;
        return [primary, primary, secondary, primary, secondary, primary, secondary];
      }
      if (density === 'explosion') {
        if (tops.length === 0) return [];
        var slots = [];
        for (var i = 0; i < 8; i++) slots.push(tops[i % tops.length]);
        return slots;
      }
      if (density === 'overload') return tops.length > 0 ? [tops[0], tops[0], tops[0], tops[0], tops[0], tops[0]] : [];
      if (tops.length === 0) return [];
      var standardSlots = [];
      for (var si = 0; si < 6; si++) standardSlots.push(tops[si % tops.length]);
      return standardSlots;
    }

    function renderMiniConeHDSVG(flavorName, scale) {
      if (!flavorColorData || !flavorName) return '';
      var bc = flavorColorData.base_colors || {};
      var rc = flavorColorData.ribbon_colors || {};
      var tc = flavorColorData.topping_colors || {};
      var cc = flavorColorData.cone_colors || { waffle: '#D2691E', waffle_dark: '#B8860B' };
      var CONE_TIP = '#8B5A2B';

      var profile = getFlavorProfileLocal(flavorName);
      var baseColor = (profile ? bc[profile.base] : null) || getFlavorBaseColor(flavorName) || '#F5DEB3';
      var ribbonKey = profile ? profile.ribbon : null;
      var hasRibbon = ribbonKey && (!profile || profile.density !== 'pure');
      var ribbonColor = hasRibbon ? (rc[ribbonKey] || null) : null;
      var tSlotKeys = resolveHDToppingSlots(profile);
      var highlightColor = lightenHex(baseColor, 0.3);

      var s = scale || 5;
      var rects = [];

      var scoopRows = [[4,13],[2,15],[2,15],[2,15],[2,15],[2,15],[2,15],[2,15],[2,15],[2,15],[2,15],[4,13]];
      for (var row = 0; row < scoopRows.length; row++) {
        var sc = scoopRows[row][0], ec = scoopRows[row][1];
        for (var col = sc; col <= ec; col++) {
          rects.push('<rect x="' + (col*s) + '" y="' + (row*s) + '" width="' + s + '" height="' + s + '" fill="' + baseColor + '"/>');
        }
      }

      var hlSlots = [[4,0],[3,1]];
      for (var hi = 0; hi < hlSlots.length; hi++) {
        rects.push('<rect x="' + (hlSlots[hi][0]*s) + '" y="' + (hlSlots[hi][1]*s) + '" width="' + s + '" height="' + s + '" fill="' + highlightColor + '"/>');
      }

      var tSlots = [[4,2],[12,1],[6,3],[14,5],[3,6],[11,7],[5,9],[13,8]];
      for (var ti = 0; ti < tSlotKeys.length && ti < tSlots.length; ti++) {
        var tColor = tc[tSlotKeys[ti]];
        if (!tColor) continue;
        rects.push('<rect x="' + (tSlots[ti][0]*s) + '" y="' + (tSlots[ti][1]*s) + '" width="' + s + '" height="' + s + '" fill="' + tColor + '"/>');
      }

      if (ribbonColor) {
        var rSlots = [[7,1],[8,3],[9,4],[10,5],[9,7],[8,9]];
        for (var ri = 0; ri < rSlots.length; ri++) {
          rects.push('<rect x="' + (rSlots[ri][0]*s) + '" y="' + (rSlots[ri][1]*s) + '" width="' + s + '" height="' + s + '" fill="' + ribbonColor + '"/>');
        }
      }

      var coneRows = [[4,13],[4,13],[5,12],[5,12],[6,11],[6,11],[7,10],[7,10],[8,9]];
      for (var cr = 0; cr < coneRows.length; cr++) {
        var csc = coneRows[cr][0], cec = coneRows[cr][1];
        for (var col2 = csc; col2 <= cec; col2++) {
          var wc = ((cr + col2) % 2 === 0) ? cc.waffle : cc.waffle_dark;
          rects.push('<rect x="' + (col2*s) + '" y="' + ((cr+12)*s) + '" width="' + s + '" height="' + s + '" fill="' + wc + '"/>');
        }
      }
      rects.push('<rect x="' + (8*s) + '" y="' + (21*s) + '" width="' + s + '" height="' + s + '" fill="' + CONE_TIP + '"/>');
      rects.push('<rect x="' + (9*s) + '" y="' + (21*s) + '" width="' + s + '" height="' + s + '" fill="' + CONE_TIP + '"/>');

      return '<svg class="mini-cone" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ' + (18*s) + ' ' + (22*s) + '" width="' + (18*s) + '" height="' + (22*s) + '" shape-rendering="crispEdges">' + rects.join('') + '</svg>';
    }

    const BRAND_COLORS = {
      culvers: '#005696',
      kopps: '#000000',
      gilles: '#EBCC35',
      hefners: '#93BE46',
      kraverz: '#CE742D',
      oscars: '#BC272C',
    };

    const BRAND_DISPLAY = {
      kopps: "Kopp's",
      gilles: "Gille's",
      hefners: "Hefner's",
      kraverz: "Kraverz",
      oscars: "Oscar's",
    };

    // Brand detection from slug (mirrors Worker's BRAND_REGISTRY)
    function brandFromSlug(slug) {
      if (!slug) return 'culvers';
      if (slug.startsWith('kopps-')) return 'kopps';
      if (slug === 'gilles') return 'gilles';
      if (slug === 'hefners') return 'hefners';
      if (slug === 'kraverz') return 'kraverz';
      if (slug.startsWith('oscars')) return 'oscars';
      return 'culvers';
    }

    let allStores = [];
    let currentSlug = null;
    let userLat = null;
    let userLng = null;
    let dropdownStores = [];
    let dropdownActiveIndex = -1;

    // DOM refs
    const storeSearch = document.getElementById('store-search');
    const storeDropdown = document.getElementById('store-dropdown');
    const currentStoreEl = document.getElementById('current-store');
    const currentStoreName = document.getElementById('current-store-name');
    const changeStoreBtn = document.getElementById('change-store-btn');
    const geoBtn = document.getElementById('geo-btn');
    const findStoreBtn = document.getElementById('find-store-btn');
    const emptyState = document.getElementById('empty-state');
    const todayLoading = document.getElementById('today-loading');
    const errorState = document.getElementById('error-state');
    const errorMessage = document.getElementById('error-message');
    const retryBtn = document.getElementById('retry-btn');
    const todaySection = document.getElementById('today-section');
    const todayAccent = document.getElementById('today-accent');
    const todayBadge = document.getElementById('today-badge');
    const todayFlavor = document.getElementById('today-flavor');
    const todayCone = document.getElementById('today-cone');
    const todayDesc = document.getElementById('today-desc');
    const todayRarity = document.getElementById('today-rarity');
    const todayPredictions = document.getElementById('today-predictions');
    const todayStore = document.getElementById('today-store');
    const todayFreshness = document.getElementById('today-freshness');
    const weekSection = document.getElementById('week-section');
    const weekStrip = document.getElementById('week-strip');
    const weekFreshness = document.getElementById('week-freshness');
    const quickStartWrap = document.getElementById('quick-start-wrap');
    const quickStartStores = document.getElementById('quick-start-stores');
    const sampleGoogleColor = document.getElementById('sample-google-color');
    const sampleGoogleTitle = document.getElementById('sample-google-title');
    const sampleGoogleDate = document.getElementById('sample-google-date');
    const sampleGoogleLocation = document.getElementById('sample-google-location');
    const sampleGoogleDesc = document.getElementById('sample-google-desc');
    const sampleAppleDot = document.getElementById('sample-apple-dot');
    const sampleAppleTitle = document.getElementById('sample-apple-title');
    const sampleAppleMeta = document.getElementById('sample-apple-meta');
    const sampleAppleLocation = document.getElementById('sample-apple-location');

    // --- Utility ---
    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function toISODate(d) {
      return d.toISOString().slice(0, 10);
    }

    function addDays(d, n) {
      const r = new Date(d);
      r.setDate(r.getDate() + n);
      return r;
    }

    function timeSince(isoStr) {
      if (!isoStr) return '';
      const diff = Date.now() - new Date(isoStr).getTime();
      const mins = Math.floor(diff / 60000);
      if (mins < 1) return 'just now';
      if (mins < 60) return mins + ' min ago';
      const hrs = Math.floor(mins / 60);
      if (hrs < 24) return hrs + ' hr ago';
      const days = Math.floor(hrs / 24);
      return days + 'd ago';
    }

    function formatLongDateFromISO(dateStr) {
      const d = dateStr ? new Date(dateStr + 'T12:00:00') : new Date();
      return d.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      });
    }

    function updateCalendarPreview(day, store, accentColor) {
      if (!sampleGoogleTitle || !sampleAppleTitle) return;

      const dayDate = day && day.date ? day.date : toISODate(new Date());
      const flavor = day && day.flavor ? day.flavor : 'Flavor Preview';
      let status = 'Forecast';
      if (day && day.type === 'confirmed') status = 'Confirmed';
      if (day && day.type === 'predicted') status = 'Predicted';

      const location = store
        ? (store.address ? store.address + ', ' : '') + store.city + ', ' + store.state
        : 'Select a store to personalize this preview.';

      let detail = 'Daily flavor events sync automatically when you subscribe.';
      if (day && day.type === 'confirmed' && day.description) {
        detail = day.description;
      } else if (day && day.type === 'predicted') {
        detail = 'Likely flavor forecast based on recent schedule patterns.';
      }

      const color = accentColor || '#005696';
      sampleGoogleColor.style.background = color;
      sampleGoogleTitle.textContent = '\u{1F366} ' + flavor;
      sampleGoogleDate.textContent = formatLongDateFromISO(dayDate) + ' ¬∑ All-day';
      sampleGoogleLocation.textContent = '\u{1F4CD} ' + location;
      sampleGoogleDesc.textContent = detail + ' Status: ' + status + '.';

      sampleAppleDot.style.background = color;
      sampleAppleTitle.textContent = flavor;
      sampleAppleMeta.textContent = formatLongDateFromISO(dayDate) + ' ¬∑ ' + status;
      sampleAppleLocation.textContent = location;
    }

    function haversine(lat1, lng1, lat2, lng2) {
      const R = 3958.8;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLng / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function firstStoreMatching(predicate, usedSlugs) {
      for (const store of allStores) {
        if (usedSlugs.has(store.slug)) continue;
        if (predicate(store)) return store;
      }
      return null;
    }

    function buildQuickStartStores() {
      if (!allStores.length) return [];
      const picks = [];
      const used = new Set();

      function addPick(store) {
        if (!store || used.has(store.slug)) return;
        picks.push(store);
        used.add(store.slug);
      }

      const cityTargets = ['Madison', 'Milwaukee', 'Chicago', 'Minneapolis', 'Indianapolis'];
      for (const city of cityTargets) {
        addPick(firstStoreMatching(
          (s) => (s.city || '').toLowerCase() === city.toLowerCase(),
          used,
        ));
        if (picks.length >= 5) break;
      }

      if (picks.length < 5) {
        const wiStores = allStores
          .filter((s) => s.state === 'WI')
          .sort((a, b) => (a.city || '').localeCompare(b.city || ''));
        for (const store of wiStores) {
          addPick(store);
          if (picks.length >= 5) break;
        }
      }

      if (picks.length < 5) {
        const fallback = [...allStores].sort((a, b) => (a.city || '').localeCompare(b.city || ''));
        for (const store of fallback) {
          addPick(store);
          if (picks.length >= 5) break;
        }
      }

      return picks;
    }

    function renderQuickStartStores() {
      if (!quickStartWrap || !quickStartStores) return;
      const picks = buildQuickStartStores();
      if (picks.length === 0) {
        quickStartWrap.hidden = true;
        return;
      }
      quickStartStores.innerHTML = '';
      for (const store of picks) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'quick-start-chip';
        const brand = store.brand ? (BRAND_DISPLAY[store.brand] || store.brand) + ' \u2014 ' : '';
        btn.textContent = brand + store.city + ', ' + store.state;
        btn.addEventListener('click', () => selectStore(store.slug));
        quickStartStores.appendChild(btn);
      }
      quickStartWrap.hidden = false;
    }

    // --- Store loading ---
    async function loadStores() {
      try {
        const resp = await fetch('stores.json?v=' + new Date().toISOString().slice(0, 10));
        const data = await resp.json();
        allStores = data.stores || [];
      } catch (err) {
        console.error('Failed to load stores:', err);
      }
    }

    // --- Store picker ---
    function filterStores(query) {
      const q = query.toLowerCase().trim();
      if (!q) return [];
      let filtered = allStores.filter(s => {
        const searchable = (s.name + ' ' + s.city + ' ' + (s.address || '') + ' ' + s.slug + ' ' + (s.brand || '') + ' ' + (BRAND_DISPLAY[s.brand] || '')).toLowerCase();
        return searchable.includes(q);
      });

      // Sort by distance if available
      if (userLat !== null && userLng !== null) {
        filtered = filtered.map(s => {
          s._dist = (s.lat != null && s.lng != null)
            ? haversine(userLat, userLng, s.lat, s.lng) : Infinity;
          return s;
        }).sort((a, b) => a._dist - b._dist);
      }

      return filtered.slice(0, 8);
    }

    function hideStoreDropdown() {
      storeDropdown.hidden = true;
      dropdownStores = [];
      dropdownActiveIndex = -1;
      storeSearch.setAttribute('aria-expanded', 'false');
      storeSearch.removeAttribute('aria-activedescendant');
    }

    function setActiveDropdownIndex(nextIndex) {
      if (dropdownStores.length === 0) return;
      const clamped = Math.max(0, Math.min(nextIndex, dropdownStores.length - 1));
      dropdownActiveIndex = clamped;
      const items = storeDropdown.querySelectorAll('.store-dropdown-item');
      items.forEach((item, idx) => {
        const isActive = idx === dropdownActiveIndex;
        item.classList.toggle('is-active', isActive);
        item.setAttribute('aria-selected', isActive ? 'true' : 'false');
        if (isActive) {
          storeSearch.setAttribute('aria-activedescendant', item.id);
          item.scrollIntoView({ block: 'nearest' });
        }
      });
    }

    function moveDropdownSelection(delta) {
      if (storeDropdown.hidden || dropdownStores.length === 0) return;
      if (dropdownActiveIndex === -1) {
        setActiveDropdownIndex(delta > 0 ? 0 : dropdownStores.length - 1);
        return;
      }
      setActiveDropdownIndex(dropdownActiveIndex + delta);
    }

    function selectActiveDropdownStore() {
      if (dropdownStores.length === 0) return false;
      const activeIndex = dropdownActiveIndex >= 0 ? dropdownActiveIndex : 0;
      const store = dropdownStores[activeIndex];
      if (!store) return false;
      selectStore(store.slug);
      return true;
    }

    function renderDropdown(stores) {
      dropdownStores = stores.slice();
      dropdownActiveIndex = -1;
      storeSearch.removeAttribute('aria-activedescendant');
      if (dropdownStores.length === 0) {
        hideStoreDropdown();
        return;
      }
      storeDropdown.innerHTML = '';
      storeDropdown.setAttribute('role', 'listbox');
      for (let i = 0; i < dropdownStores.length; i++) {
        const store = dropdownStores[i];
        const item = document.createElement('div');
        item.className = 'store-dropdown-item';
        item.id = 'store-dropdown-item-' + i;
        item.setAttribute('role', 'option');
        item.setAttribute('aria-selected', 'false');
        item.dataset.index = String(i);
        const brand = store.brand ? (BRAND_DISPLAY[store.brand] || store.brand) : '';
        const prefix = brand ? brand + ' \u2014 ' : '';
        const dist = (store._dist != null && store._dist !== Infinity) ? ' (' + store._dist.toFixed(1) + ' mi)' : '';
        item.innerHTML = '<div class="store-dropdown-name">' + escapeHtml(prefix + store.name) + '</div>'
          + '<div class="store-dropdown-detail">' + escapeHtml(store.city + ', ' + store.state + ' \u2014 ' + (store.address || '')) + escapeHtml(dist) + '</div>';
        item.addEventListener('mouseenter', () => setActiveDropdownIndex(i));
        item.addEventListener('mousedown', (event) => event.preventDefault());
        item.addEventListener('click', () => selectStore(store.slug));
        storeDropdown.appendChild(item);
      }
      storeDropdown.hidden = false;
      storeSearch.setAttribute('aria-expanded', 'true');
    }

    function selectStore(slug) {
      currentSlug = slug;
      const store = allStores.find(s => s.slug === slug);
      if (!store) return;

      // Save to localStorage (shared with calendar page)
      try { localStorage.setItem('custard-primary', slug); } catch (e) {}

      // Update UI
      const brand = store.brand ? (BRAND_DISPLAY[store.brand] || store.brand) + ' \u2014 ' : '';
      currentStoreName.textContent = brand + store.city + ', ' + store.state + ' \u2014 ' + (store.address || '');
      currentStoreEl.hidden = false;
      storeSearch.value = '';
      hideStoreDropdown();
      emptyState.hidden = true;

      const brandKey = store.brand || brandFromSlug(slug);
      updateCalendarPreview(null, store, BRAND_COLORS[brandKey] || '#005696');

      loadForecast(slug);
    }

    function showStorePicker() {
      currentStoreEl.hidden = true;
      storeSearch.value = '';
      hideStoreDropdown();
      storeSearch.focus();
    }

    // --- Geolocation ---
    async function geolocateAndSort() {
      geoBtn.disabled = true;
      try {
        // Try browser geolocation first
        const pos = await new Promise((resolve, reject) => {
          if (!navigator.geolocation) return reject(new Error('No geolocation'));
          navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 5000 });
        });
        userLat = pos.coords.latitude;
        userLng = pos.coords.longitude;
      } catch (e) {
        // Fall back to IP-based
        try {
          const resp = await fetch(WORKER_BASE + '/api/v1/geolocate');
          const geo = await resp.json();
          if (geo.lat && geo.lon) {
            userLat = geo.lat;
            userLng = geo.lon;
          }
        } catch (err) {
          console.debug('Geolocation unavailable:', err);
        }
      }
      geoBtn.disabled = false;
      // If we got coords, show sorted results immediately
      if (userLat !== null && allStores.length > 0) {
        const sorted = allStores.map(s => {
          s._dist = (s.lat != null && s.lng != null) ? haversine(userLat, userLng, s.lat, s.lng) : Infinity;
          return s;
        }).sort((a, b) => a._dist - b._dist);
        renderDropdown(sorted.slice(0, 8));
        storeSearch.focus();
      }
    }

    // --- Forecast loading ---
    async function loadForecast(slug) {
      // Show loading
      todaySection.hidden = true;
      weekSection.hidden = true;
      errorState.hidden = true;
      todayLoading.hidden = false;

      try {
        const [flavorsResp, forecastResp, todayResp] = await Promise.all([
          fetch(WORKER_BASE + '/api/v1/flavors?slug=' + encodeURIComponent(slug)),
          fetch(WORKER_BASE + '/api/v1/forecast/' + encodeURIComponent(slug)),
          fetch(WORKER_BASE + '/api/v1/today?slug=' + encodeURIComponent(slug)),
        ]);

        let confirmedFlavors = [];
        let fetchedAt = null;
        if (flavorsResp.ok) {
          const cData = await flavorsResp.json();
          confirmedFlavors = (cData.flavors || []).map(f => ({
            date: f.date,
            title: f.title,
            description: f.description || '',
          }));
          fetchedAt = cData.fetched_at || null;
        }

        let forecast = null;
        if (forecastResp.ok) {
          forecast = await forecastResp.json();
        }

        let todayData = null;
        if (todayResp.ok) {
          todayData = await todayResp.json();
        }

        const today = new Date();
        today.setHours(12, 0, 0, 0);
        const timeline = buildTimeline(confirmedFlavors, forecast, today);

        todayLoading.hidden = true;

        if (timeline.length > 0) {
          renderTodayCard(timeline[0], slug, fetchedAt, forecast, todayData);
          renderWeekStrip(timeline.slice(1), fetchedAt);
        } else {
          renderTodayCard({ date: toISODate(today), type: 'none' }, slug, fetchedAt, forecast, todayData);
        }
      } catch (err) {
        console.error('Forecast load error:', err);
        todayLoading.hidden = true;
        errorMessage.textContent = 'Something went wrong loading the forecast.';
        errorState.hidden = false;
      }
    }

    function buildTimeline(confirmedFlavors, forecast, today) {
      const timeline = [];
      for (let i = 0; i < 7; i++) {
        const date = addDays(today, i);
        const dateStr = toISODate(date);

        const confirmed = confirmedFlavors.find(f => f.date === dateStr);
        if (confirmed) {
          timeline.push({ date: dateStr, type: 'confirmed', flavor: confirmed.title, description: confirmed.description || '' });
          continue;
        }

        const forecastDay = forecast && forecast.days
          ? forecast.days.find(d => d.date === dateStr)
          : null;
        if (forecastDay && forecastDay.predictions && forecastDay.predictions.length > 0) {
          timeline.push({
            date: dateStr,
            type: 'predicted',
            flavor: forecastDay.predictions[0].flavor,
            probability: forecastDay.predictions[0].probability,
            predictions: forecastDay.predictions.slice(0, 3),
          });
          continue;
        }

        timeline.push({ date: dateStr, type: 'none' });
      }
      return timeline;
    }

    // --- Rendering ---
    function renderRarity(rarity) {
      if (!rarity) {
        todayRarity.hidden = true;
        return;
      }
      var html = '';
      if (rarity.label) {
        var cssClass = 'rarity-badge rarity-badge-' + rarity.label.toLowerCase().replace(/\s+/g, '-');
        html += '<span class="' + cssClass + '">' + escapeHtml(rarity.label) + '</span>';
        if (rarity.avg_gap_days) {
          html += 'Shows up roughly every ' + rarity.avg_gap_days + ' days at your store';
        }
      } else if (rarity.avg_gap_days) {
        html += 'Back in about ' + rarity.avg_gap_days + ' days';
      }
      if (html) {
        todayRarity.innerHTML = html;
        todayRarity.hidden = false;
      } else {
        todayRarity.hidden = true;
      }
    }

    function renderTodayCard(day, slug, fetchedAt, forecast, todayData) {
      const store = allStores.find(s => s.slug === slug);
      const brand = brandFromSlug(slug);
      const color = BRAND_COLORS[brand] || '#005696';
      todayAccent.style.background = color;

      if (day.type === 'confirmed') {
        todayBadge.textContent = 'Confirmed';
        todayBadge.className = 'day-card-badge day-card-badge-confirmed';
        todayCone.innerHTML = renderMiniConeHDSVG(day.flavor, 5);
        todayCone.hidden = false;
        todayFlavor.textContent = day.flavor;
        todayFlavor.style.color = '';
        todayDesc.textContent = day.description || '';
        todayDesc.hidden = !day.description;
        todayPredictions.innerHTML = '';
        renderRarity(todayData && todayData.rarity);
      } else if (day.type === 'predicted') {
        todayBadge.textContent = 'Predicted';
        todayBadge.className = 'day-card-badge day-card-badge-predicted';
        todayCone.innerHTML = renderMiniConeHDSVG(day.flavor, 5);
        todayCone.hidden = false;
        todayFlavor.textContent = day.flavor;
        todayFlavor.style.color = '';
        todayDesc.textContent = '';
        todayDesc.hidden = true;

        // Show top predictions with bars
        if (day.predictions && day.predictions.length > 0) {
          const maxProb = day.predictions[0].probability || 0.1;
          let html = '';
          for (const p of day.predictions) {
            const pct = (p.probability * 100).toFixed(1);
            const barWidth = Math.max(5, (p.probability / Math.max(maxProb, 0.01)) * 100);
            const conf = p.confidence || (p.probability > 0.10 ? 'high' : p.probability >= 0.05 ? 'medium' : 'low');
            html += '<div class="prediction-row">'
              + '<span class="prediction-name">' + renderMiniConeSVG(p.flavor) + escapeHtml(p.flavor) + '</span>'
              + '<div class="prediction-bar-wrap"><div class="prediction-bar prediction-bar-' + conf + '" style="width:' + barWidth + '%"></div></div>'
              + '<span class="prediction-pct">' + pct + '%</span>'
              + '</div>';
          }
          todayPredictions.innerHTML = html;
        } else {
          todayPredictions.innerHTML = '';
        }
        renderRarity(null);
      } else {
        todayBadge.textContent = '';
        todayBadge.className = 'day-card-badge';
        todayCone.innerHTML = '';
        todayCone.hidden = true;
        todayFlavor.textContent = 'No data yet';
        todayFlavor.style.color = '#999';
        todayDesc.textContent = 'Check back later \u2014 flavor data updates throughout the day.';
        todayDesc.hidden = false;
        todayPredictions.innerHTML = '';
        renderRarity(null);
      }

      todayStore.textContent = store ? store.name : slug;

      const freshness = fetchedAt ? 'Updated ' + timeSince(fetchedAt) : '';
      todayFreshness.textContent = freshness;

      todaySection.hidden = false;
      updateCalendarPreview(day, store, color);
    }

    function confidenceStripClass(day) {
      if (day.type === 'confirmed') return 'confidence-strip confidence-strip-confirmed';
      if (day.type === 'predicted') {
        var prob = day.probability || 0;
        if (prob > 0.10) return 'confidence-strip confidence-strip-high';
        if (prob >= 0.05) return 'confidence-strip confidence-strip-medium';
        return 'confidence-strip confidence-strip-low';
      }
      return 'confidence-strip confidence-strip-none';
    }

    function formatDateLabel(dateStr) {
      const today = new Date();
      today.setHours(12, 0, 0, 0);
      var todayStr = toISODate(today);
      var tomorrowStr = toISODate(addDays(today, 1));
      if (dateStr === todayStr) return 'Today';
      if (dateStr === tomorrowStr) return 'Tmrw';
      var d = new Date(dateStr + 'T12:00:00');
      return d.toLocaleDateString('en-US', { weekday: 'short' });
    }

    function renderWeekStrip(days, fetchedAt) {
      weekStrip.innerHTML = '';
      const today = new Date();
      today.setHours(12, 0, 0, 0);

      let hasAnyData = false;

      for (const day of days) {
        const d = new Date(day.date + 'T12:00:00');
        const dayName = formatDateLabel(day.date);
        const dateLabel = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

        const card = document.createElement('div');

        if (day.type === 'confirmed') {
          hasAnyData = true;
          card.className = 'week-day-card';
          card.innerHTML =
            '<div class="' + confidenceStripClass(day) + '"></div>'
            + '<div class="week-day-name">' + escapeHtml(dayName) + '</div>'
            + '<div class="week-day-date">' + escapeHtml(dateLabel) + '</div>'
            + '<div style="text-align:center;margin:0.25rem 0;">' + renderMiniConeSVG(day.flavor) + '</div>'
            + '<div class="week-day-flavor">' + escapeHtml(day.flavor) + '</div>'
            + '<div class="week-day-confidence" style="color:#2e7d32;">Confirmed</div>';
        } else if (day.type === 'predicted') {
          hasAnyData = true;
          const pct = day.probability ? (day.probability * 100).toFixed(0) + '%' : '';
          card.className = 'week-day-card week-day-card-predicted';
          card.innerHTML =
            '<div class="' + confidenceStripClass(day) + '"></div>'
            + '<div class="week-day-name">' + escapeHtml(dayName) + '</div>'
            + '<div class="week-day-date">' + escapeHtml(dateLabel) + '</div>'
            + '<div style="text-align:center;margin:0.25rem 0;">' + renderMiniConeSVG(day.flavor) + '</div>'
            + '<div class="week-day-flavor">' + escapeHtml(day.flavor) + '</div>'
            + (pct ? '<div class="week-day-confidence">' + pct + ' likely</div>' : '');
        } else {
          card.className = 'week-day-card week-day-card-none';
          card.innerHTML =
            '<div class="' + confidenceStripClass(day) + '"></div>'
            + '<div class="week-day-name">' + escapeHtml(dayName) + '</div>'
            + '<div class="week-day-date">' + escapeHtml(dateLabel) + '</div>'
            + '<div class="week-day-flavor" style="color:#999;font-style:italic;">No data</div>';
        }

        weekStrip.appendChild(card);
      }

      if (fetchedAt) {
        weekFreshness.textContent = 'Updated ' + timeSince(fetchedAt);
      } else {
        weekFreshness.textContent = '';
      }

      weekSection.hidden = !hasAnyData && days.every(d => d.type === 'none');
    }

    // --- Event handlers ---
    storeSearch.addEventListener('input', () => {
      const q = storeSearch.value.trim();
      if (q.length < 2) {
        hideStoreDropdown();
        return;
      }
      const results = filterStores(q);
      renderDropdown(results);
    });

    storeSearch.addEventListener('focus', () => {
      const q = storeSearch.value.trim();
      if (q.length >= 2) {
        const results = filterStores(q);
        renderDropdown(results);
      }
    });

    storeSearch.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowDown') {
        if (storeDropdown.hidden) {
          const q = storeSearch.value.trim();
          if (q.length >= 2) renderDropdown(filterStores(q));
        }
        if (!storeDropdown.hidden) {
          event.preventDefault();
          moveDropdownSelection(1);
        }
        return;
      }

      if (event.key === 'ArrowUp') {
        if (!storeDropdown.hidden) {
          event.preventDefault();
          moveDropdownSelection(-1);
        }
        return;
      }

      if (event.key === 'Enter') {
        if (!storeDropdown.hidden && dropdownStores.length > 0) {
          event.preventDefault();
          selectActiveDropdownStore();
        }
        return;
      }

      if (event.key === 'Escape') {
        hideStoreDropdown();
      }
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.location-bar-inner')) {
        hideStoreDropdown();
      }
    });

    changeStoreBtn.addEventListener('click', showStorePicker);

    findStoreBtn.addEventListener('click', () => {
      document.querySelector('.location-bar').scrollIntoView({ behavior: 'smooth', block: 'center' });
      storeSearch.focus();
    });

    geoBtn.addEventListener('click', geolocateAndSort);

    retryBtn.addEventListener('click', () => {
      if (currentSlug) {
        errorState.hidden = true;
        loadForecast(currentSlug);
      }
    });

    // --- Init ---
    async function init() {
      await Promise.all([loadStores(), loadFlavorColors()]);
      renderQuickStartStores();
      updateCalendarPreview(null, null, '#005696');

      // Check localStorage for a saved store
      let savedSlug = null;
      try { savedSlug = localStorage.getItem('custard-primary'); } catch (e) {}

      if (savedSlug && allStores.find(s => s.slug === savedSlug)) {
        selectStore(savedSlug);
      } else {
        emptyState.hidden = false;
        todaySection.hidden = true;
        weekSection.hidden = true;
      }
    }

    init();

    // Register service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').catch(() => {});
    }
  </script>
</body>
</html>
