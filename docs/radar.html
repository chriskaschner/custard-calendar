<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flavor Radar ‚Äî Custard Calendar</title>
  <meta name="description" content="Your 7-day personalized flavor outlook. See confirmed and predicted Flavors of the Day at your favorite shop.">
  <meta property="og:title" content="Flavor Radar ‚Äî Custard Calendar">
  <meta property="og:description" content="Your 7-day personalized flavor outlook for frozen custard shops.">
  <meta property="og:url" content="https://custard.chriskaschner.com/radar.html">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://custard.chriskaschner.com/og-calendar.png">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üç¶</text></svg>">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <h1>Flavor Radar</h1>
    <p>Your 7-day flavor outlook</p>
    <nav class="nav-links">
      <a href="index.html">Forecast</a>
      <a href="calendar.html">Calendar</a>
      <a href="map.html">Map</a>
      <a href="radar.html" class="nav-active">Radar</a>
      <a href="alerts.html">Alerts</a>
      <a href="siri.html">Siri</a>
      <a href="forecast-map.html">Fronts</a>
      <a href="quiz.html">Quiz</a>
      <a href="widget.html">Widget</a>
    </nav>
  </header>

  <main>
    <section id="store-selector">
      <h2>1. Pick your store</h2>
      <div class="filter-row">
        <div class="filter-group">
          <label for="state-filter">State</label>
          <select id="state-filter">
            <option value="">All States</option>
          </select>
        </div>
        <div class="filter-group">
          <label for="city-search">Search</label>
          <input type="text" id="city-search" placeholder="City or store name...">
        </div>
      </div>

      <div id="store-selected" class="selected-badge" hidden></div>
      <select id="store-select" size="6">
        <option value="" disabled selected>Loading stores...</option>
      </select>
    </section>

    <section id="radar-empty-state" hidden>
      <div class="hero-empty">
        <p class="hero-kicker">Flavor Intelligence</p>
        <h2>Radar is your decision layer for where to go next.</h2>
        <p class="hero-subtitle">Load one store to see confirmed vs estimated flavor odds, anomaly signals, and better nearby alternatives in one pass.</p>
        <div class="hero-cta-row">
          <button class="btn-primary" id="radar-start-btn" type="button">Start with a recommended store</button>
          <button class="btn-secondary" id="radar-browse-btn" type="button">Browse stores</button>
          <a class="btn-secondary" href="map.html">Open Flavor Map</a>
        </div>
        <p id="radar-geo-context" class="hero-coverage"></p>
        <div id="radar-quick-start-wrap" class="quick-start-wrap" hidden>
          <span class="quick-start-label">Quick start stores:</span>
          <div id="radar-quick-start-stores" class="quick-start-stores"></div>
        </div>
      </div>
    </section>

    <section id="flavor-section" hidden>
      <h2>2. Pick up to 3 favorite flavors</h2>
      <p class="hint">We'll highlight these in your forecast.</p>

      <div class="filter-row">
        <div class="filter-group">
          <label for="flavor-search">Search flavors</label>
          <input type="text" id="flavor-search" placeholder="Type a flavor name...">
        </div>
      </div>

      <div id="flavor-results" class="flavor-results" hidden></div>

      <div id="selected-flavors" class="selected-badges"></div>
    </section>

    <section id="timeline-section" hidden>
      <h2>7-Day Outlook</h2>
      <p class="hint">Confirmed cards show store schedule data. Watch cards flag reliability concerns. Estimated cards are model-based.</p>
      <div id="timeline" class="day-cards"></div>
      <div id="trust-banner" class="trust-banner" hidden></div>
    </section>

    <section id="radar-actions-section" hidden>
      <h2>3. Take action</h2>
      <p id="radar-actions-context" class="hint"></p>
      <div class="hero-cta-row radar-action-row">
        <a id="radar-action-map" class="btn-secondary" href="map.html">Open map for this store</a>
        <a id="radar-action-alerts" class="btn-secondary" href="alerts.html">Set flavor alerts</a>
        <a id="radar-action-calendar" class="btn-primary" href="#">Subscribe to calendar</a>
      </div>
    </section>

    <section id="radar-signals-section" hidden>
      <h2 class="signals-header">Flavor Signals</h2>
      <div id="radar-signals-list" class="signals-list"></div>
    </section>

    <section id="radar-historical-context-section" hidden>
      <h2>Historical Context</h2>
      <div id="radar-historical-context-card"></div>
    </section>

    <section id="next-best-section" hidden>
      <h2>Next Best Store</h2>
      <p class="hint">When your favorites are weak at this store, we'll suggest nearby alternatives with stronger odds.</p>
      <div class="phase2-controls">
        <label for="drive-radius">Drive radius</label>
        <select id="drive-radius">
          <option value="10">10 mi</option>
          <option value="25" selected>25 mi</option>
          <option value="50">50 mi</option>
        </select>
        <button id="refresh-next-best" class="btn btn-search" type="button">Refresh</button>
      </div>
      <div id="next-best-status" class="hint"></div>
      <div id="next-best-list" class="next-best-list"></div>
    </section>

    <section id="accuracy-section" hidden>
      <h2>Forecast Accuracy Dashboard</h2>
      <p class="hint">Live quality signals for this store's 7-day model output.</p>
      <div class="accuracy-grid">
        <div class="accuracy-card">
          <div class="accuracy-label">Expected Top-1 Hit (Proxy)</div>
          <div class="accuracy-value" id="acc-top1">--</div>
          <div class="accuracy-note">Average top prediction probability across the week.</div>
        </div>
        <div class="accuracy-card">
          <div class="accuracy-label">Coverage</div>
          <div class="accuracy-value" id="acc-coverage">--</div>
          <div class="accuracy-note" id="acc-coverage-note">--</div>
        </div>
        <div class="accuracy-card">
          <div class="accuracy-label">Confidence Mix</div>
          <div class="accuracy-value" id="acc-confidence">--</div>
          <div class="accuracy-note">Certainty breakdown (Confirmed / Estimated).</div>
        </div>
        <div class="accuracy-card">
          <div class="accuracy-label">Model Depth</div>
          <div class="accuracy-value" id="acc-depth">--</div>
          <div class="accuracy-note" id="acc-depth-note">--</div>
        </div>
      </div>
    </section>

    <section id="favorites-section" hidden>
      <div id="overdue-section" class="overdue-section" hidden>
        <h3>Overdue favorites</h3>
        <div id="overdue-list"></div>
      </div>
      <div id="similar-section" class="similar-section" hidden>
        <h3>Similar flavors in the forecast</h3>
        <div id="similar-list"></div>
      </div>
    </section>
  </main>

  <footer>
    <p>Not affiliated with any restaurant. Flavor data sourced from restaurant websites. Predictions are estimates based on historical patterns.</p>
  </footer>

  <style>
    #store-select {
      width: 100%;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.8125rem;
      margin-top: 0.5rem;
    }

    #radar-empty-state, #flavor-section, #timeline-section, #radar-actions-section, #radar-historical-context-section, #next-best-section, #accuracy-section, #favorites-section {
      margin-top: 2rem;
    }

    #flavor-section h2, #timeline-section h2, #radar-actions-section h2, #radar-historical-context-section h2, #next-best-section h2, #accuracy-section h2 {
      font-size: 1rem;
      color: #003366;
      margin-bottom: 0.5rem;
    }

    .radar-action-row {
      justify-content: flex-start;
    }

    .radar-action-row .btn-primary,
    .radar-action-row .btn-secondary {
      font-size: 0.875rem;
      padding: 0.625rem 1rem;
    }

    .flavor-results {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      margin-bottom: 0.75rem;
    }

    .flavor-result-item {
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      font-size: 0.875rem;
    }

    .flavor-result-item:last-child {
      border-bottom: none;
    }

    .flavor-result-item:hover {
      background: #f0f4f8;
    }

    .flavor-result-item .flavor-name {
      font-weight: 600;
      color: #1a1a1a;
    }

    .flavor-result-item .flavor-desc {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.125rem;
    }

    .day-card-body {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      margin-top: 0.25rem;
    }

    .day-card-cone {
      flex-shrink: 0;
    }

    .day-card-text {
      flex: 1;
      min-width: 0;
    }

    .day-card-flavor {
      font-size: 1.0625rem;
      font-weight: 700;
      color: #1a1a1a;
    }

    .day-card-desc {
      font-size: 0.8125rem;
      color: #666;
      margin-top: 0.25rem;
      line-height: 1.4;
    }

    .day-card-nodata {
      font-style: italic;
      color: #999;
      font-size: 0.8125rem;
    }

    .star-indicator {
      color: #f9a825;
      margin-right: 0.25rem;
    }

    .intel-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      margin-top: 0.25rem;
    }

    .intel-badges-inline {
      margin-top: 0.1rem;
    }

    .intel-badge {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 0.1rem 0.45rem;
      font-size: 0.6875rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      border: 1px solid transparent;
      white-space: nowrap;
    }

    .intel-badge-rarity {
      background: #eef4ff;
      color: #0d3b7a;
      border-color: #bdd6ff;
    }

    .intel-badge-streak {
      background: #fff3e0;
      color: #9a5a00;
      border-color: #ffd8a8;
    }

    .intel-badge-overdue {
      background: #f3f3ff;
      color: #5c3cb0;
      border-color: #ddd3ff;
    }

    .intel-badge-cadence {
      background: #e9f7ef;
      color: #1f7a3b;
      border-color: #b8e3c8;
    }

    .phase2-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
    }

    .phase2-controls label {
      font-size: 0.8125rem;
      color: #666;
      font-weight: 600;
    }

    .phase2-controls select {
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.8125rem;
      padding: 0.35rem 0.45rem;
      background: white;
    }

    .next-best-list {
      display: grid;
      gap: 0.75rem;
      margin-top: 0.75rem;
    }

    .next-best-card {
      border: 1px solid #d9e4ef;
      border-left: 4px solid #003366;
      border-radius: 8px;
      padding: 0.75rem;
      background: #fbfdff;
    }

    .next-best-title {
      font-size: 0.875rem;
      font-weight: 700;
      color: #003366;
      margin-bottom: 0.3rem;
      line-height: 1.35;
    }

    .next-best-detail {
      font-size: 0.8125rem;
      color: #555;
      line-height: 1.4;
      margin-bottom: 0.35rem;
    }

    .next-best-links a {
      font-size: 0.75rem;
      font-weight: 600;
      color: #005696;
      text-decoration: none;
      border-bottom: 1px dotted #005696;
    }

    .next-best-links a:hover {
      color: #003366;
      border-bottom-color: #003366;
    }

    .next-best-badge {
      display: inline-block;
      font-size: 0.6875rem;
      font-weight: 700;
      padding: 0.1rem 0.45rem;
      border-radius: 4px;
      vertical-align: middle;
      margin-left: 0.3rem;
    }
    .next-best-badge-confirmed {
      background: #005696;
      color: #fff;
    }

    .accuracy-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.75rem;
      margin-top: 0.75rem;
    }

    .accuracy-card {
      border: 1px solid #d9e4ef;
      border-radius: 8px;
      background: #fbfdff;
      padding: 0.75rem;
    }

    .accuracy-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #6a7c90;
      margin-bottom: 0.25rem;
      font-weight: 700;
    }

    .accuracy-value {
      font-size: 1.15rem;
      color: #003366;
      font-weight: 800;
      margin-bottom: 0.25rem;
    }

    .accuracy-note {
      font-size: 0.75rem;
      color: #666;
      line-height: 1.3;
    }

    @media (max-width: 640px) {
      .accuracy-grid {
        grid-template-columns: 1fr;
      }

      .radar-action-row .btn-primary,
      .radar-action-row .btn-secondary {
        width: 100%;
      }
    }
  </style>

  <script src="planner-shared.js"></script>
  <script>var WORKER_BASE = CustardPlanner.WORKER_BASE;</script>
  <script src="cone-renderer.js"></script>
  <script>
    const STORAGE_KEY = 'custard-radar';
    const MAX_FAVORITES = 3;

    var BRAND_DISPLAY = CustardPlanner.BRAND_DISPLAY;
    var brandFromSlug = CustardPlanner.brandFromSlug;
    var SIMILARITY_GROUPS = CustardPlanner.SIMILARITY_GROUPS;
    var getPrimaryStoreSlug = CustardPlanner.getPrimaryStoreSlug || function () { return null; };
    var setPrimaryStoreSlug = CustardPlanner.setPrimaryStoreSlug || function () { return false; };

    let allStores = [];
    let flavorCatalog = [];
    let selectedSlug = null;
    let selectedFlavors = new Set();
    // flavorColorData provided by cone-renderer.js

    // DOM elements
    const stateFilter = document.getElementById('state-filter');
    const citySearch = document.getElementById('city-search');
    const storeSelect = document.getElementById('store-select');
    const storeSelected = document.getElementById('store-selected');
    const radarEmptyState = document.getElementById('radar-empty-state');
    const radarStartBtn = document.getElementById('radar-start-btn');
    const radarBrowseBtn = document.getElementById('radar-browse-btn');
    const radarGeoContext = document.getElementById('radar-geo-context');
    const radarQuickStartWrap = document.getElementById('radar-quick-start-wrap');
    const radarQuickStartStores = document.getElementById('radar-quick-start-stores');
    const flavorSection = document.getElementById('flavor-section');
    const flavorSearch = document.getElementById('flavor-search');
    const flavorResults = document.getElementById('flavor-results');
    const selectedFlavorsEl = document.getElementById('selected-flavors');
    const timelineSection = document.getElementById('timeline-section');
    const timelineEl = document.getElementById('timeline');
    const trustBanner = document.getElementById('trust-banner');
    const radarActionsSection = document.getElementById('radar-actions-section');
    const radarActionsContext = document.getElementById('radar-actions-context');
    const radarActionMap = document.getElementById('radar-action-map');
    const radarActionAlerts = document.getElementById('radar-action-alerts');
    const radarActionCalendar = document.getElementById('radar-action-calendar');
    const radarHistoricalContextSection = document.getElementById('radar-historical-context-section');
    const radarHistoricalContextCard = document.getElementById('radar-historical-context-card');
    const nextBestSection = document.getElementById('next-best-section');
    const driveRadius = document.getElementById('drive-radius');
    const refreshNextBestBtn = document.getElementById('refresh-next-best');
    const nextBestStatus = document.getElementById('next-best-status');
    const nextBestList = document.getElementById('next-best-list');
    const accuracySection = document.getElementById('accuracy-section');
    const accTop1 = document.getElementById('acc-top1');
    const accCoverage = document.getElementById('acc-coverage');
    const accCoverageNote = document.getElementById('acc-coverage-note');
    const accConfidence = document.getElementById('acc-confidence');
    const accDepth = document.getElementById('acc-depth');
    const accDepthNote = document.getElementById('acc-depth-note');
    const favoritesSection = document.getElementById('favorites-section');
    const overdueSection = document.getElementById('overdue-section');
    const overdueList = document.getElementById('overdue-list');
    const similarSection = document.getElementById('similar-section');
    const similarList = document.getElementById('similar-list');

    // Phase 2 caches
    const forecastCacheBySlug = new Map();
    const confirmedCacheBySlug = new Map();
    const flavorMetricsCache = new Map();
    const flavorMetricsInflight = new Map();
    const flavorStatsCache = new Map();
    const flavorStatsInflight = new Map();
    let cachedStoreMetrics = null;
    let cachedStoreMetricsSlug = null;
    let storeFlavorCounts = new Map();
    let storeActiveStreaks = new Map();
    let detectedGeo = null;
    let radarOnboardingViewTracked = false;

    // --- Utilities ---
    function toISODate(d) {
      return d.toISOString().slice(0, 10);
    }

    function addDays(d, n) {
      const r = new Date(d);
      r.setDate(r.getDate() + n);
      return r;
    }

    function formatDate(dateStr) {
      const d = new Date(dateStr + 'T12:00:00');
      const today = new Date();
      today.setHours(12, 0, 0, 0);
      const todayStr = toISODate(today);
      const tomorrowStr = toISODate(addDays(today, 1));

      let label = d.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
      if (dateStr === todayStr) label = 'Today \u2014 ' + label;
      else if (dateStr === tomorrowStr) label = 'Tomorrow \u2014 ' + label;
      return label;
    }

    var escapeHtml = CustardPlanner.escapeHtml;

    var normalize = CustardPlanner.normalize;

    function timeSince(iso) {
      if (!iso) return 'Unknown';
      const then = new Date(iso).getTime();
      if (!Number.isFinite(then)) return 'Unknown';
      const deltaMs = Date.now() - then;
      const mins = Math.max(0, Math.round(deltaMs / 60000));
      if (mins < 1) return 'Just now';
      if (mins < 60) return mins + ' min ago';
      const hrs = Math.round(mins / 60);
      if (hrs < 24) return hrs + ' hr ago';
      const days = Math.round(hrs / 24);
      return days + ' day' + (days === 1 ? '' : 's') + ' ago';
    }

    function emitRadarEvent(eventType, action, extra) {
      if (!CustardPlanner || typeof CustardPlanner.emitInteractionEvent !== 'function') return;
      const payload = {
        event_type: eventType,
        page: 'radar',
        action: action,
      };
      if (extra && typeof extra === 'object') {
        for (const [key, value] of Object.entries(extra)) {
          payload[key] = value;
        }
      }
      CustardPlanner.emitInteractionEvent(payload);
    }

    var haversineMiles = CustardPlanner.haversineMiles;

    function selectedStore() {
      return allStores.find(s => s.slug === selectedSlug) || null;
    }

    function findStoreBySlug(slug) {
      if (!slug) return null;
      return allStores.find(s => s.slug === slug) || null;
    }

    function storeLabel(store) {
      if (!store) return '';
      const brand = store.brand ? (BRAND_DISPLAY[store.brand] || store.brand) : '';
      const prefix = brand ? brand + ' \u2014 ' : '';
      return prefix + store.city + ', ' + store.state + ' \u2014 ' + store.address;
    }

    function getRecommendedStoreSlug() {
      const filtered = getFilteredStores();
      if (!filtered.length) return null;
      const geoCity = (detectedGeo && detectedGeo.city ? String(detectedGeo.city) : '').trim().toLowerCase();
      if (geoCity) {
        const cityMatch = filtered.find(s => String(s.city || '').trim().toLowerCase() === geoCity);
        if (cityMatch) return cityMatch.slug;
      }
      return filtered[0].slug;
    }

    function renderRadarQuickStart(stores) {
      radarQuickStartStores.innerHTML = '';
      const picks = (stores || []).slice(0, 6);
      if (!picks.length) {
        radarQuickStartWrap.hidden = true;
        return;
      }
      for (const store of picks) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'quick-start-chip';
        btn.textContent = store.city + ', ' + store.state;
        btn.addEventListener('click', () => {
          emitRadarEvent('onboarding_click', 'quick_start_chip', { store_slug: store.slug });
          selectStore(store.slug);
        });
        radarQuickStartStores.appendChild(btn);
      }
      radarQuickStartWrap.hidden = false;
    }

    function renderRadarEntryState() {
      const hasSelection = !!selectedSlug;
      radarEmptyState.hidden = hasSelection;
      if (hasSelection) return;
      if (!radarOnboardingViewTracked) {
        emitRadarEvent('onboarding_view', 'empty_state');
        radarOnboardingViewTracked = true;
      }

      flavorSection.hidden = true;
      timelineSection.hidden = true;
      radarActionsSection.hidden = true;
      radarHistoricalContextSection.hidden = true;
      nextBestSection.hidden = true;
      accuracySection.hidden = true;
      favoritesSection.hidden = true;
      document.getElementById('radar-signals-section').hidden = true;
      trustBanner.hidden = true;

      const parts = [];
      if (detectedGeo && detectedGeo.city && detectedGeo.state) {
        parts.push('Detected near ' + detectedGeo.city + ', ' + detectedGeo.state + '.');
      } else if (detectedGeo && detectedGeo.state) {
        parts.push('Detected state: ' + detectedGeo.state + '.');
      }
      parts.push('Pick a store to unlock Radar signals, confidence trends, and next-best alternatives.');
      radarGeoContext.textContent = parts.join(' ');

      renderRadarQuickStart(getFilteredStores());
    }

    function primaryContextFlavor() {
      if (selectedFlavors.size > 0) {
        return [...selectedFlavors][0];
      }
      for (const day of cachedTimeline) {
        if (day.type === 'confirmed' && day.flavor) return day.flavor;
        if (day.type === 'predicted' && day.predictions && day.predictions[0]) {
          return day.predictions[0].flavor;
        }
      }
      return '';
    }

    async function renderRadarHistoricalContext() {
      if (!selectedSlug) {
        radarHistoricalContextSection.hidden = true;
        return;
      }
      const flavorName = primaryContextFlavor();
      if (!flavorName) {
        radarHistoricalContextSection.hidden = true;
        return;
      }

      try {
        const [flavorContext, storeContext] = await Promise.all([
          CustardPlanner.fetchFlavorHistoricalContext(WORKER_BASE, flavorName),
          CustardPlanner.fetchStoreHistoricalContext(WORKER_BASE, selectedSlug),
        ]);
        const html = CustardPlanner.historicalContextHTML({
          flavorContext,
          storeContext,
          flavorLabel: flavorName,
        });
        if (!html) {
          radarHistoricalContextSection.hidden = true;
          return;
        }
        radarHistoricalContextCard.innerHTML = html;
        radarHistoricalContextSection.hidden = false;
      } catch (_) {
        radarHistoricalContextSection.hidden = true;
      }
    }

    function updateRadarActions() {
      if (!selectedSlug) {
        radarActionsSection.hidden = true;
        return;
      }
      const store = findStoreBySlug(selectedSlug);
      if (!store) {
        radarActionsSection.hidden = true;
        return;
      }

      const location = store.city && store.state ? (store.city + ', ' + store.state) : store.name;
      radarActionsContext.textContent = 'Using ' + location + ' as your action hub for map, alerts, and calendar subscription.';
      radarActionMap.href = 'map.html?location=' + encodeURIComponent(location);
      radarActionAlerts.href = 'alerts.html';
      radarActionCalendar.href = CustardPlanner.calendarIcsUrl(WORKER_BASE, selectedSlug);
      radarActionsSection.hidden = false;
    }

    function isFavorite(flavorName) {
      const n = normalize(flavorName);
      for (const fav of selectedFlavors) {
        if (normalize(fav) === n) return true;
      }
      return false;
    }

    var findSimilarFlavors = CustardPlanner.findSimilarToFavorites;

    // --- localStorage ---
    function savePrefs() {
      const data = { store: selectedSlug, favorites: [...selectedFlavors] };
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch (e) {}
    }

    function loadPrefs() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (e) { return null; }
    }

    // --- Store loading ---
    async function loadStores(defaultState) {
      try {
        const resp = await fetch('stores.json?v=' + new Date().toISOString().slice(0, 10));
        const data = await resp.json();
        allStores = data.stores || [];
        populateStateFilter();
        if (defaultState && stateFilter.querySelector('option[value="' + defaultState + '"]')) {
          stateFilter.value = defaultState;
        }
        renderStoreList();
      } catch (err) {
        storeSelect.innerHTML = '<option disabled>Failed to load stores</option>';
      }
    }

    async function detectState() {
      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/geolocate');
        const data = await resp.json();
        return {
          state: data.state || 'WI',
          city: data.city || '',
        };
      } catch (e) {
        // Geolocate blocked (CORS / offline) -- default to WI
        return { state: 'WI', city: '' };
      }
    }

    async function loadCatalog() {
      // Try local static file first (works on any origin), fall back to API
      try {
        const resp = await fetch('flavors.json?v=' + new Date().toISOString().slice(0, 10));
        if (resp.ok) {
          const data = await resp.json();
          flavorCatalog = data.flavors || [];
          return;
        }
      } catch (e) {}
      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/flavors/catalog');
        const data = await resp.json();
        flavorCatalog = data.flavors || [];
      } catch (err) {
        console.error('Failed to load flavor catalog:', err);
      }
    }

    // loadFlavorColors, renderMiniConeSVG, renderMiniConeHDSVG etc. provided by cone-renderer.js

    function populateStateFilter() {
      const states = [...new Set(allStores.map(s => s.state))].sort();
      for (const state of states) {
        const opt = document.createElement('option');
        opt.value = state;
        opt.textContent = state;
        stateFilter.appendChild(opt);
      }
    }

    function getFilteredStores() {
      const state = stateFilter.value;
      const query = citySearch.value.toLowerCase().trim();
      return allStores.filter(s => {
        if (state && s.state !== state) return false;
        if (query) {
          const searchable = (s.name + ' ' + s.city + ' ' + s.address + ' ' + s.slug).toLowerCase();
          return searchable.includes(query);
        }
        return true;
      });
    }

    function renderStoreList() {
      const filtered = getFilteredStores();
      storeSelect.innerHTML = '';
      if (filtered.length === 0) {
        storeSelect.innerHTML = '<option disabled>No stores match your search</option>';
      } else {
        for (const store of filtered) {
          const opt = document.createElement('option');
          opt.value = store.slug;
          const brand = store.brand ? (BRAND_DISPLAY[store.brand] || store.brand) : '';
          const prefix = brand ? brand + ' \u2014 ' : '';
          opt.textContent = prefix + store.city + ', ' + store.state + ' \u2014 ' + store.address;
          if (store.slug === selectedSlug) opt.selected = true;
          storeSelect.appendChild(opt);
        }
      }
      if (!selectedSlug) renderRadarEntryState();
    }

    function selectStore(slug) {
      const store = findStoreBySlug(slug);
      if (!store) return;
      selectedSlug = slug;
      storeSelect.value = slug;
      storeSelected.textContent = storeLabel(store);
      storeSelected.hidden = false;
      flavorSection.hidden = false;
      radarHistoricalContextSection.hidden = true;
      setPrimaryStoreSlug(slug);
      savePrefs();
      updateRadarActions();
      renderRadarEntryState();
      fetchAndRenderTimeline();
    }

    // --- Flavor picker ---
    function searchFlavors(query) {
      if (!query || query.length < 2) {
        flavorResults.hidden = true;
        return;
      }

      const q = query.toLowerCase();
      const matches = flavorCatalog.filter(f => {
        if (selectedFlavors.has(f.title)) return false;
        const inTitle = f.title.toLowerCase().includes(q);
        const inDesc = f.description && f.description.toLowerCase().includes(q);
        return inTitle || inDesc;
      }).slice(0, 10);

      flavorResults.innerHTML = '';
      if (matches.length === 0) {
        flavorResults.innerHTML = '<div class="flavor-result-item"><span class="flavor-desc">No matching flavors found</span></div>';
        flavorResults.hidden = false;
        return;
      }

      for (const f of matches) {
        const item = document.createElement('div');
        item.className = 'flavor-result-item';
        item.innerHTML = '<div class="flavor-name">' + escapeHtml(f.title) + '</div><div class="flavor-desc">' + escapeHtml(f.description || '') + '</div>';
        item.addEventListener('click', () => addFlavor(f.title));
        flavorResults.appendChild(item);
      }
      flavorResults.hidden = false;
    }

    function addFlavor(title) {
      if (selectedFlavors.size >= MAX_FAVORITES) return;
      selectedFlavors.add(title);
      flavorSearch.value = '';
      flavorResults.hidden = true;
      renderSelectedFlavors();
      savePrefs();
      renderTimelineHighlights();
    }

    function removeFlavor(title) {
      selectedFlavors.delete(title);
      renderSelectedFlavors();
      savePrefs();
      renderTimelineHighlights();
    }

    function renderSelectedFlavors() {
      selectedFlavorsEl.innerHTML = '';
      for (const title of selectedFlavors) {
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = title;
        const removeBtn = document.createElement('button');
        removeBtn.textContent = '\u00d7';
        removeBtn.title = 'Remove';
        removeBtn.onclick = () => removeFlavor(title);
        badge.appendChild(removeBtn);
        selectedFlavorsEl.appendChild(badge);
      }
    }

    // --- Timeline ---
    let cachedConfirmed = [];
    let cachedForecast = null;
    let cachedTimeline = [];

    async function fetchForecastForSlug(slug) {
      if (forecastCacheBySlug.has(slug)) {
        return forecastCacheBySlug.get(slug);
      }
      const p = fetch(WORKER_BASE + '/api/v1/forecast/' + encodeURIComponent(slug))
        .then((resp) => resp.ok ? resp.json() : null)
        .catch(() => null);
      forecastCacheBySlug.set(slug, p);
      return p;
    }

    async function fetchConfirmedFlavors(slug) {
      if (confirmedCacheBySlug.has(slug)) {
        return confirmedCacheBySlug.get(slug);
      }
      const p = fetch(WORKER_BASE + '/api/v1/flavors?slug=' + encodeURIComponent(slug))
        .then((resp) => resp.ok ? resp.json() : null)
        .catch(() => null);
      confirmedCacheBySlug.set(slug, p);
      return p;
    }

    async function loadStoreMetrics(slug) {
      if (!slug) return;
      if (cachedStoreMetricsSlug === slug) return;

      cachedStoreMetrics = null;
      cachedStoreMetricsSlug = slug;
      storeFlavorCounts = new Map();
      storeActiveStreaks = new Map();

      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/metrics/store/' + encodeURIComponent(slug));
        if (!resp.ok) return;
        const data = await resp.json();
        cachedStoreMetrics = data;

        for (const row of (data.recent_history || [])) {
          const key = normalize(row.flavor);
          storeFlavorCounts.set(key, (storeFlavorCounts.get(key) || 0) + 1);
        }
        for (const streak of (data.active_streaks || [])) {
          const key = normalize(streak.flavor);
          if (streak.length >= 2) {
            storeActiveStreaks.set(key, streak.length);
          }
        }
      } catch (err) {
        console.debug('Store metrics unavailable:', err);
      }
    }

    async function loadFlavorMetrics(flavorName) {
      const key = normalize(flavorName);
      if (!key) return null;
      if (flavorMetricsCache.has(key)) return flavorMetricsCache.get(key);
      if (flavorMetricsInflight.has(key)) return flavorMetricsInflight.get(key);

      const p = fetch(WORKER_BASE + '/api/v1/metrics/flavor/' + encodeURIComponent(key))
        .then((resp) => resp.ok ? resp.json() : null)
        .then((data) => {
          flavorMetricsCache.set(key, data);
          flavorMetricsInflight.delete(key);
          return data;
        })
        .catch(() => {
          flavorMetricsInflight.delete(key);
          return null;
        });
      flavorMetricsInflight.set(key, p);
      return p;
    }

    function flavorStatsKey(slug, flavorName) {
      const storeSlug = String(slug || '').trim().toLowerCase();
      const normalized = normalize(flavorName);
      if (!storeSlug || !normalized) return '';
      return storeSlug + '::' + normalized;
    }

    async function loadStoreFlavorStats(slug, flavorName) {
      const key = flavorStatsKey(slug, flavorName);
      if (!key) return null;
      if (flavorStatsCache.has(key)) return flavorStatsCache.get(key);
      if (flavorStatsInflight.has(key)) return flavorStatsInflight.get(key);

      const p = fetch(
        WORKER_BASE + '/api/v1/flavor-stats/' + encodeURIComponent(slug) + '?flavor=' + encodeURIComponent(flavorName)
      )
        .then((resp) => resp.ok ? resp.json() : null)
        .then((data) => {
          flavorStatsCache.set(key, data);
          flavorStatsInflight.delete(key);
          return data;
        })
        .catch(() => {
          flavorStatsInflight.delete(key);
          return null;
        });
      flavorStatsInflight.set(key, p);
      return p;
    }

    async function preloadFlavorMetrics() {
      const unique = new Set();
      for (const day of cachedTimeline) {
        if (day.type === 'confirmed' && day.flavor) {
          unique.add(day.flavor);
        }
        if (day.type === 'predicted') {
          for (const p of day.predictions.slice(0, 3)) {
            unique.add(p.flavor);
          }
        }
      }
      for (const f of selectedFlavors) unique.add(f);
      const flavorList = [...unique];
      await Promise.all(flavorList.map(loadFlavorMetrics));
      if (selectedSlug) {
        // Keep per-store cadence lookups bounded for predictable page performance.
        await Promise.all(flavorList.slice(0, 12).map((f) => loadStoreFlavorStats(selectedSlug, f)));
      }
      computeRarityPercentiles();
    }

    // Percentile-based rarity: ranks flavors relative to the loaded dataset
    let rarityPercentileMap = new Map(); // normalized_flavor -> percentile (0-100)

    function computeRarityPercentiles() {
      rarityPercentileMap = new Map();
      const entries = [];
      for (const [key, metrics] of flavorMetricsCache) {
        if (!metrics) continue;
        const total = Number(metrics.total_appearances || 0);
        entries.push({ key, total });
      }

      // Sample floor: skip all badges if fewer than 10 distinct flavors
      if (entries.length < 10) return;

      // Sort ascending by appearance count
      entries.sort((a, b) => a.total - b.total);

      // Assign percentile rank
      for (let i = 0; i < entries.length; i++) {
        const percentile = (i / (entries.length - 1)) * 100;
        rarityPercentileMap.set(entries[i].key, percentile);
      }
    }

    function rarityBadge(flavorName) {
      const key = normalize(flavorName);
      const percentile = rarityPercentileMap.get(key);
      if (percentile === undefined) return null;
      if (percentile <= 10) return 'Ultra Rare';
      if (percentile <= 25) return 'Rare';
      if (percentile <= 50) return 'Uncommon';
      if (percentile <= 75) return 'Common';
      return 'Staple';
    }

    function streakBadge(flavorName) {
      const key = normalize(flavorName);
      const streakLen = storeActiveStreaks.get(key);
      if (streakLen && streakLen >= 2) {
        return streakLen + '-day streak';
      }
      const monthlyCount = storeFlavorCounts.get(key) || 0;
      if (monthlyCount >= 3) {
        return monthlyCount + 'x this month';
      }
      return null;
    }

    function overdueBadge(flavorName, day) {
      if (!day || day.type !== 'predicted' || !Array.isArray(day.overdue)) return null;
      const key = normalize(flavorName);
      const entry = day.overdue.find((o) => normalize(o.flavor) === key);
      if (!entry || !entry.avg_gap) return null;
      const ratio = entry.days_since / Math.max(entry.avg_gap, 1);
      if (ratio >= 1.5) return 'Overdue return';
      return null;
    }

    function cadenceBadge(flavorName) {
      if (!selectedSlug) return null;
      const key = flavorStatsKey(selectedSlug, flavorName);
      if (!key) return null;
      const stats = flavorStatsCache.get(key);
      if (!stats) return null;
      const avgGap = Number(stats.avg_gap_days);
      if (!Number.isFinite(avgGap)) return null;
      if (avgGap < 2 || avgGap > 180) return null;
      return 'Every ' + Math.round(avgGap) + ' days';
    }

    function renderFlavorBadges(flavorName, day, inline = false) {
      const chips = [];
      const rarity = rarityBadge(flavorName);
      const cadence = cadenceBadge(flavorName);
      const streak = streakBadge(flavorName);
      const overdue = overdueBadge(flavorName, day);
      if (rarity) chips.push({ type: 'rarity', label: rarity });
      if (cadence) chips.push({ type: 'cadence', label: cadence });
      if (streak) chips.push({ type: 'streak', label: streak });
      if (overdue) chips.push({ type: 'overdue', label: overdue });
      if (chips.length === 0) return '';
      return '<div class="intel-badges' + (inline ? ' intel-badges-inline' : '') + '">' +
        chips.slice(0, 2).map((chip) =>
          '<span class="intel-badge intel-badge-' + chip.type + '">' + escapeHtml(chip.label) + '</span>'
        ).join('') +
      '</div>';
    }

    function renderAccuracyDashboard() {
      if (!selectedSlug || cachedTimeline.length === 0) {
        accuracySection.hidden = true;
        return;
      }

      const predicted = cachedTimeline.filter(d => d.type === 'predicted');
      const confirmed = cachedTimeline.filter(d => d.type === 'confirmed');
      const coveredDays = predicted.length + confirmed.length;
      const topScores = [];
      const certaintyCounts = { confirmed: confirmed.length, estimated: 0, none: 0 };

      for (const day of confirmed) {
        topScores.push(1.0);
      }
      for (const day of predicted) {
        const top = day.predictions[0];
        if (top && Number.isFinite(top.probability)) {
          topScores.push(top.probability);
          certaintyCounts.estimated++;
        }
      }

      const avgTop = topScores.length
        ? (topScores.reduce((sum, p) => sum + p, 0) / topScores.length)
        : 0;
      accTop1.textContent = (avgTop * 100).toFixed(1) + '%';
      accCoverage.textContent = Math.round((coveredDays / 7) * 100) + '%';
      accCoverageNote.textContent = coveredDays + '/7 days with confirmed or estimated data';
      accConfidence.textContent = certaintyCounts.confirmed + ' Confirmed / ' + certaintyCounts.estimated + ' Estimated';

      if (cachedForecast && cachedForecast.history_depth) {
        accDepth.textContent = cachedForecast.history_depth.toLocaleString();
        accDepthNote.textContent = 'observations, updated ' + timeSince(cachedForecast.generated_at);
      } else {
        accDepth.textContent = '--';
        accDepthNote.textContent = 'Forecast history depth unavailable';
      }

      accuracySection.hidden = false;
    }

    function computePrimaryFavoriteScores() {
      const scores = new Map();
      for (const fav of selectedFlavors) {
        scores.set(normalize(fav), 0);
      }

      for (const day of cachedTimeline) {
        if (day.type === 'confirmed') {
          const k = normalize(day.flavor);
          if (scores.has(k)) scores.set(k, 1);
          continue;
        }
        if (day.type === 'predicted') {
          for (const p of day.predictions || []) {
            const k = normalize(p.flavor);
            if (scores.has(k)) {
              const current = scores.get(k) || 0;
              if (p.probability > current) scores.set(k, p.probability);
            }
          }
        }
      }
      return scores;
    }

    function findBestPredictionForFlavor(forecast, flavorName) {
      if (!forecast || !Array.isArray(forecast.days)) return null;
      const key = normalize(flavorName);
      let best = null;
      for (const day of forecast.days) {
        for (const p of (day.predictions || [])) {
          if (normalize(p.flavor) !== key) continue;
          if (!best || p.probability > best.probability) {
            best = {
              date: day.date,
              probability: p.probability,
              certainty_tier: 'estimated',
            };
          }
        }
      }
      return best;
    }

    function buildCandidateStores(radiusMiles) {
      const primary = selectedStore();
      if (!primary) return [];
      const baseLat = Number(primary.lat);
      const baseLng = Number(primary.lng);
      const hasCoords = Number.isFinite(baseLat) && Number.isFinite(baseLng);

      const candidates = allStores
        .filter(s => s.slug !== selectedSlug)
        .map((s) => {
          const lat = Number(s.lat);
          const lng = Number(s.lng);
          let dist = null;
          if (hasCoords && Number.isFinite(lat) && Number.isFinite(lng)) {
            dist = haversineMiles(baseLat, baseLng, lat, lng);
          }
          return { ...s, _distanceMiles: dist };
        })
        .filter((s) => {
          if (!hasCoords) return s.state === primary.state;
          return s._distanceMiles !== null && s._distanceMiles <= radiusMiles;
        })
        .sort((a, b) => {
          if (a._distanceMiles === null && b._distanceMiles === null) return 0;
          if (a._distanceMiles === null) return 1;
          if (b._distanceMiles === null) return -1;
          return a._distanceMiles - b._distanceMiles;
        });

      return candidates.slice(0, 24);
    }

    async function renderNextBestStoreRecommendations() {
      if (!selectedSlug || selectedFlavors.size === 0 || cachedTimeline.length === 0) {
        nextBestSection.hidden = true;
        return;
      }

      nextBestSection.hidden = false;
      nextBestList.innerHTML = '';
      nextBestStatus.textContent = 'Scanning nearby stores...';

      const radiusMiles = parseInt(driveRadius.value, 10) || 25;
      const candidates = buildCandidateStores(radiusMiles);
      if (candidates.length === 0) {
        nextBestStatus.textContent = 'No nearby stores found in your selected radius.';
        return;
      }

      // Build primary store's flavor set for comparison
      const primaryScores = computePrimaryFavoriteScores();
      const primaryConfirmedFlavors = new Set();
      for (const day of cachedTimeline) {
        if (day.type === 'confirmed') {
          primaryConfirmedFlavors.add(normalize(day.flavor));
        }
      }

      const favorites = [...selectedFlavors];
      const predictedRecs = [];
      const confirmedRecs = [];
      let forecastCount = 0;
      let confirmedOnlyCount = 0;

      await Promise.all(candidates.map(async (store) => {
        // Try forecast first
        const forecast = await fetchForecastForSlug(store.slug);
        if (forecast) {
          forecastCount++;
          for (const fav of favorites) {
            const best = findBestPredictionForFlavor(forecast, fav);
            if (!best) continue;

            const primaryScore = primaryScores.get(normalize(fav)) || 0;
            const minLift = primaryScore < 0.05 ? 0.04 : 0.02;
            if (best.probability < primaryScore + minLift) continue;

            predictedRecs.push({
              store,
              sourceType: 'predicted',
              flavor: fav,
              date: best.date,
              probability: best.probability,
              certainty_tier: best.certainty_tier,
              primaryScore,
              delta: best.probability - primaryScore,
            });
          }
          return;
        }

        // Fallback: confirmed schedule for non-forecast stores
        const confirmed = await fetchConfirmedFlavors(store.slug);
        if (confirmed && confirmed.flavors && confirmed.flavors.length > 0) {
          confirmedOnlyCount++;
          const todayStr = new Date().toISOString().slice(0, 10);
          for (const fav of favorites) {
            const favKey = normalize(fav);
            // Only recommend if flavor appears in candidate's confirmed schedule
            // on today or a future date, and NOT in primary store's confirmed schedule
            const match = confirmed.flavors.find(f => normalize(f.title) === favKey && f.date >= todayStr);
            if (!match) continue;
            if (primaryConfirmedFlavors.has(favKey)) continue;

            confirmedRecs.push({
              store,
              sourceType: 'confirmed',
              flavor: fav,
              date: match.date,
            });
          }
        }
      }));

      // Display order: confirmed first (certainty > probability), predicted second
      const allRecs = [];

      // Confirmed recs: sort by distance
      confirmedRecs.sort((a, b) => ((a.store._distanceMiles || 999) - (b.store._distanceMiles || 999)));
      for (const rec of confirmedRecs) allRecs.push(rec);

      // Predicted recs: sort by lift delta
      predictedRecs.sort((a, b) => (b.delta - a.delta) || (b.probability - a.probability) || ((a.store._distanceMiles || 999) - (b.store._distanceMiles || 999)));
      for (const rec of predictedRecs) allRecs.push(rec);

      if (allRecs.length === 0) {
        const checkedCount = forecastCount + confirmedOnlyCount;
        if (checkedCount === 0) {
          nextBestStatus.textContent = candidates.length + ' nearby stores checked \u2014 no flavor data available yet.';
        } else {
          nextBestStatus.textContent = 'No stronger nearby alternatives found this week.';
        }
        return;
      }

      // Dedupe by flavor, keeping first (confirmed wins over predicted due to sort order)
      const byFlavor = new Map();
      for (const rec of allRecs) {
        const key = normalize(rec.flavor);
        if (!byFlavor.has(key)) byFlavor.set(key, rec);
      }
      const picks = [...byFlavor.values()].slice(0, 3);

      const statusParts = ['Checked ' + candidates.length + ' nearby stores'];
      if (forecastCount > 0) statusParts.push(forecastCount + ' forecast-enabled');
      if (confirmedOnlyCount > 0) statusParts.push(confirmedOnlyCount + ' confirmed-only');
      nextBestStatus.textContent = statusParts.join(', ') + '.';

      nextBestList.innerHTML = picks.map((rec) => {
        const locationQ = rec.store.city && rec.store.state
          ? rec.store.city + ', ' + rec.store.state
          : rec.store.name;
        const mapHref = 'map.html?flavor=' + encodeURIComponent(rec.flavor) +
          '&location=' + encodeURIComponent(locationQ);
        const distText = Number.isFinite(rec.store._distanceMiles)
          ? rec.store._distanceMiles.toFixed(1) + ' mi'
          : 'distance unknown';

        if (rec.sourceType === 'confirmed') {
          return (
            '<div class="next-best-card">' +
              '<div class="next-best-title">' + escapeHtml(rec.flavor) + ': confirmed at ' + escapeHtml(rec.store.name) + '</div>' +
              '<div class="next-best-detail">' +
                escapeHtml(formatDate(rec.date)) +
                ' <span class="next-best-badge next-best-badge-confirmed">Confirmed</span>' +
              '</div>' +
              '<div class="next-best-detail">' +
                escapeHtml(rec.store.address || locationQ) + ' \u2014 ' + distText +
              '</div>' +
              '<div class="next-best-links"><a href="' + mapHref + '">See on map</a></div>' +
            '</div>'
          );
        }

        return (
          '<div class="next-best-card">' +
            '<div class="next-best-title">' + escapeHtml(rec.flavor) + ': better odds at ' + escapeHtml(rec.store.name) + '</div>' +
            '<div class="next-best-detail">' +
              escapeHtml(formatDate(rec.date)) + ' \u2014 ' +
              'Estimated' +
              ' vs ' + (rec.primaryScore * 100).toFixed(1) + '% at your primary store.' +
            '</div>' +
            '<div class="next-best-detail">' +
              escapeHtml(rec.store.address || locationQ) + ' \u2014 ' + distText +
            '</div>' +
            '<div class="next-best-links"><a href="' + mapHref + '">See on map</a></div>' +
          '</div>'
        );
      }).join('');
    }

    function buildTimeline(confirmedFlavors, forecast, today) {
      return CustardPlanner.buildTimeline(confirmedFlavors, forecast, today, { maxPredictions: 5 });
    }

    async function fetchAndRenderTimeline() {
      if (!selectedSlug) return;
      timelineSection.hidden = false;
      timelineEl.innerHTML = '<p style="color:#666;font-size:0.875rem;">Loading forecast...</p>';

      try {
        const [confirmedResp, forecastResp] = await Promise.all([
          fetch(WORKER_BASE + '/api/v1/flavors?slug=' + encodeURIComponent(selectedSlug)),
          fetchForecastForSlug(selectedSlug),
        ]);

        cachedConfirmed = [];
        if (confirmedResp.ok) {
          const cData = await confirmedResp.json();
          cachedConfirmed = (cData.flavors || []).map(f => ({
            date: f.date,
            title: f.title,
            description: f.description || '',
          }));
        }

        cachedForecast = forecastResp || null;

        const today = new Date();
        today.setHours(12, 0, 0, 0);
        cachedTimeline = buildTimeline(cachedConfirmed, cachedForecast, today);
        await loadStoreMetrics(selectedSlug);
        renderTimeline();
        renderFavoritesIntel();
        renderAccuracyDashboard();
        await renderRadarHistoricalContext();
        await renderNextBestStoreRecommendations();
        preloadFlavorMetrics().then(() => {
          renderTimeline();
        });

        if (cachedForecast && cachedForecast.history_depth) {
          trustBanner.textContent = 'Predictions based on ' + cachedForecast.history_depth + ' historical observations for this store.';
          trustBanner.hidden = false;
        } else {
          trustBanner.hidden = true;
        }

        // Fetch reliability and show Watch banner if needed
        CustardPlanner.fetchReliability(WORKER_BASE, selectedSlug).then(function (rel) {
          var banner = CustardPlanner.watchBannerHTML(rel);
          if (banner) {
            trustBanner.insertAdjacentHTML('afterend', banner);
          }
        });

        // Fetch flavor signals
        fetchRadarSignals(selectedSlug);

      } catch (err) {
        console.error('Timeline fetch error:', err);
        timelineEl.innerHTML = '<p style="color:#c00;font-size:0.875rem;">Failed to load forecast data. Please try again.</p>';
      }
    }

    function fetchRadarSignals(slug) {
      CustardPlanner.fetchSignals(WORKER_BASE, slug, document.getElementById('radar-signals-section'), document.getElementById('radar-signals-list'));
    }

    var certaintyStripClass = CustardPlanner.confidenceStripClass;

    function renderTimeline() {
      timelineEl.innerHTML = '';
      for (const day of cachedTimeline) {
        const card = document.createElement('div');

        if (day.type === 'confirmed') {
          const hasFav = isFavorite(day.flavor);
          card.className = 'day-card day-card-confirmed' + (hasFav ? ' day-card-highlight' : '');
          card.innerHTML =
            '<div class="' + certaintyStripClass(day) + '"></div>' +
            '<div class="day-card-header">' +
              '<span class="day-card-date">' + escapeHtml(formatDate(day.date)) + '</span>' +
              '<span class="day-card-badge day-card-badge-confirmed">Confirmed</span>' +
            '</div>' +
            '<div class="day-card-body">' +
              '<div class="day-card-cone">' + renderMiniConeHDSVG(day.flavor, 5) + '</div>' +
              '<div class="day-card-text">' +
                '<div class="day-card-flavor">' +
                  (hasFav ? '<span class="star-indicator">*</span>' : '') + escapeHtml(day.flavor) +
                '</div>' +
                renderFlavorBadges(day.flavor, day) +
                (day.description ? '<div class="day-card-desc">' + escapeHtml(day.description) + '</div>' : '') +
              '</div>' +
            '</div>';

        } else if (day.type === 'predicted') {
          const anyFav = day.predictions.some(p => isFavorite(p.flavor));
          card.className = 'day-card day-card-predicted' + (anyFav ? ' day-card-highlight' : '');

          let html =
            '<div class="' + certaintyStripClass(day) + '"></div>' +
            '<div class="day-card-header">' +
              '<span class="day-card-date">' + escapeHtml(formatDate(day.date)) + '</span>' +
              '<span class="day-card-badge day-card-badge-estimated">Estimated</span>' +
            '</div>';

          const maxProb = day.predictions[0] ? day.predictions[0].probability : 0.1;
          for (const p of day.predictions) {
            const barWidth = Math.max(5, (p.probability / Math.max(maxProb, 0.01)) * 100);
            const fav = isFavorite(p.flavor);
            const flavorBase = getFlavorBaseColor(p.flavor);
            const barStyle = flavorBase
              ? 'width:' + barWidth + '%;background:' + flavorBase + ';opacity:0.6'
              : 'width:' + barWidth + '%';
            const barClass = flavorBase ? 'prediction-bar' : 'prediction-bar prediction-bar-estimated';
            html +=
              '<div class="prediction-row">' +
                '<span class="prediction-name' + (fav ? ' prediction-name-favorite' : '') + '">' +
                  renderMiniConeSVG(p.flavor, 5) +
                  (fav ? '<span class="star-indicator">*</span>' : '') +
                  escapeHtml(p.flavor) +
                '</span>' +
                renderFlavorBadges(p.flavor, day, true) +
                '<div class="prediction-bar-wrap">' +
                  '<div class="' + barClass + '" style="' + barStyle + '"></div>' +
                '</div>' +
                '<span class="prediction-pct" style="font-size:0.7rem;color:#999;">Est.</span>' +
              '</div>';
          }
          card.innerHTML = html;

        } else {
          card.className = 'day-card day-card-none';
          card.innerHTML =
            '<div class="confidence-strip confidence-strip-none"></div>' +
            '<div class="day-card-header">' +
              '<span class="day-card-date">' + escapeHtml(formatDate(day.date)) + '</span>' +
            '</div>' +
            '<div class="day-card-nodata">No forecast data yet</div>';
        }

        timelineEl.appendChild(card);
      }
    }

    function renderTimelineHighlights() {
      // Re-render to update favorite highlights without refetching
      if (cachedTimeline.length > 0) {
        renderTimeline();
        renderFavoritesIntel();
        renderAccuracyDashboard();
        void renderRadarHistoricalContext();
        void renderNextBestStoreRecommendations();
      }
    }

    // --- Favorites intelligence ---
    function renderFavoritesIntel() {
      if (selectedFlavors.size === 0) {
        favoritesSection.hidden = true;
        return;
      }

      // Collect all overdue favorites from predicted days
      const allOverdue = [];
      const seenOverdue = new Set();
      for (const day of cachedTimeline) {
        if (day.type === 'predicted' && day.overdue) {
          for (const o of day.overdue) {
            if (isFavorite(o.flavor) && !seenOverdue.has(normalize(o.flavor))) {
              seenOverdue.add(normalize(o.flavor));
              allOverdue.push(o);
            }
          }
        }
      }

      if (allOverdue.length > 0) {
        overdueList.innerHTML = '';
        for (const o of allOverdue) {
          const item = document.createElement('div');
          item.className = 'overdue-item';
          item.innerHTML =
            '<span class="overdue-flavor">' + escapeHtml(o.flavor) + '</span>' +
            '<span class="overdue-detail">' + o.days_since + ' days since last (avg ' + Math.round(o.avg_gap) + ' days)</span>';
          overdueList.appendChild(item);
        }
        overdueSection.hidden = false;
      } else {
        overdueSection.hidden = true;
      }

      // Similar flavors in forecast
      const similarNames = findSimilarFlavors(selectedFlavors);
      if (similarNames.length > 0) {
        // Check which similar flavors appear in predictions
        const forecastFlavors = new Set();
        for (const day of cachedTimeline) {
          if (day.type === 'predicted') {
            for (const p of day.predictions) {
              forecastFlavors.add(normalize(p.flavor));
            }
          }
        }

        const inForecast = similarNames.filter(s => forecastFlavors.has(s));
        if (inForecast.length > 0) {
          similarList.innerHTML = '';
          for (const name of inForecast.slice(0, 5)) {
            const item = document.createElement('div');
            item.className = 'similar-item';
            // Title-case the name
            const display = name.replace(/\b\w/g, c => c.toUpperCase());
            item.innerHTML = '<span>' + escapeHtml(display) + '</span>';
            similarList.appendChild(item);
          }
          similarSection.hidden = false;
        } else {
          similarSection.hidden = true;
        }
      } else {
        similarSection.hidden = true;
      }

      favoritesSection.hidden = overdueSection.hidden && similarSection.hidden;
    }

    // --- Event handlers ---
    stateFilter.addEventListener('change', renderStoreList);
    citySearch.addEventListener('input', renderStoreList);
    storeSelect.addEventListener('change', () => {
      if (storeSelect.value) selectStore(storeSelect.value);
    });
    flavorSearch.addEventListener('input', () => searchFlavors(flavorSearch.value));
    flavorSearch.addEventListener('focus', () => searchFlavors(flavorSearch.value));
    driveRadius.addEventListener('change', () => { void renderNextBestStoreRecommendations(); });
    refreshNextBestBtn.addEventListener('click', () => { void renderNextBestStoreRecommendations(); });
    radarStartBtn.addEventListener('click', () => {
      const slug = getRecommendedStoreSlug();
      if (slug) {
        emitRadarEvent('onboarding_click', 'start_recommended', { store_slug: slug });
        selectStore(slug);
      }
    });
    radarBrowseBtn.addEventListener('click', () => {
      emitRadarEvent('onboarding_click', 'browse_stores');
      document.getElementById('store-selector').scrollIntoView({ behavior: 'smooth', block: 'center' });
      citySearch.focus();
    });

    document.addEventListener('click', (e) => {
      if (!e.target.closest('#flavor-section')) {
        flavorResults.hidden = true;
      }
    });

    // --- Init ---
    async function init() {
      const prefs = loadPrefs();
      const savedPrimary = getPrimaryStoreSlug();
      // Detect location only when we don't already have a persisted store choice.
      const geoPromise = (prefs && prefs.store) || savedPrimary
        ? Promise.resolve({ state: null, city: '' })
        : detectState();
      const [geo] = await Promise.all([
        geoPromise,
        loadCatalog(),
        loadFlavorColors(),
      ]);
      detectedGeo = geo || { state: null, city: '' };
      await loadStores(detectedGeo.state);

      if (prefs) {
        if (prefs.favorites) {
          for (const f of prefs.favorites.slice(0, MAX_FAVORITES)) {
            selectedFlavors.add(f);
          }
          renderSelectedFlavors();
        }
      }

      let initialSlug = null;
      if (prefs && prefs.store && findStoreBySlug(prefs.store)) {
        initialSlug = prefs.store;
      } else if (savedPrimary && findStoreBySlug(savedPrimary)) {
        const store = findStoreBySlug(savedPrimary);
        if (store && store.state && stateFilter.querySelector('option[value="' + store.state + '"]')) {
          stateFilter.value = store.state;
          renderStoreList();
        }
        initialSlug = savedPrimary;
      } else {
        initialSlug = getRecommendedStoreSlug();
      }

      if (initialSlug) {
        selectStore(initialSlug);
      } else {
        renderRadarEntryState();
      }
    }

    init();
  </script>
</body>
</html>
