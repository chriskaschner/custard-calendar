<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flavor Radar ‚Äî Custard Calendar</title>
  <meta name="description" content="Your 7-day personalized flavor outlook. See confirmed and predicted Flavors of the Day at your favorite shop.">
  <meta property="og:title" content="Flavor Radar ‚Äî Custard Calendar">
  <meta property="og:description" content="Your 7-day personalized flavor outlook for frozen custard shops.">
  <meta property="og:url" content="https://custard.chriskaschner.com/radar.html">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://custard.chriskaschner.com/og-calendar.png">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üç¶</text></svg>">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <h1>Flavor Radar</h1>
    <p>Your 7-day flavor outlook</p>
    <nav class="nav-links">
      <a href="index.html">Forecast</a>
      <a href="calendar.html">Calendar</a>
      <a href="map.html">Map</a>
      <a href="radar.html" class="nav-active">Radar</a>
      <a href="alerts.html">Alerts</a>
      <a href="siri.html">Siri</a>
    </nav>
  </header>

  <main>
    <section id="store-selector">
      <h2>1. Pick your store</h2>
      <div class="filter-row">
        <div class="filter-group">
          <label for="state-filter">State</label>
          <select id="state-filter">
            <option value="">All States</option>
          </select>
        </div>
        <div class="filter-group">
          <label for="city-search">Search</label>
          <input type="text" id="city-search" placeholder="City or store name...">
        </div>
      </div>

      <div id="store-selected" class="selected-badge" hidden></div>
      <select id="store-select" size="6">
        <option value="" disabled selected>Loading stores...</option>
      </select>
    </section>

    <section id="flavor-section" hidden>
      <h2>2. Pick up to 3 favorite flavors</h2>
      <p class="hint">We'll highlight these in your forecast.</p>

      <div class="filter-row">
        <div class="filter-group">
          <label for="flavor-search">Search flavors</label>
          <input type="text" id="flavor-search" placeholder="Type a flavor name...">
        </div>
      </div>

      <div id="flavor-results" class="flavor-results" hidden></div>

      <div id="selected-flavors" class="selected-badges"></div>
    </section>

    <section id="timeline-section" hidden>
      <h2>7-Day Outlook</h2>
      <div id="timeline" class="day-cards"></div>
      <div id="trust-banner" class="trust-banner" hidden></div>
    </section>

    <section id="next-best-section" hidden>
      <h2>Next Best Store</h2>
      <p class="hint">When your favorites are weak at this store, we'll suggest nearby alternatives with stronger odds.</p>
      <div class="phase2-controls">
        <label for="drive-radius">Drive radius</label>
        <select id="drive-radius">
          <option value="10">10 mi</option>
          <option value="25" selected>25 mi</option>
          <option value="50">50 mi</option>
        </select>
        <button id="refresh-next-best" class="btn btn-search" type="button">Refresh</button>
      </div>
      <div id="next-best-status" class="hint"></div>
      <div id="next-best-list" class="next-best-list"></div>
    </section>

    <section id="accuracy-section" hidden>
      <h2>Forecast Accuracy Dashboard</h2>
      <p class="hint">Live quality signals for this store's 7-day model output.</p>
      <div class="accuracy-grid">
        <div class="accuracy-card">
          <div class="accuracy-label">Expected Top-1 Hit (Proxy)</div>
          <div class="accuracy-value" id="acc-top1">--</div>
          <div class="accuracy-note">Average top prediction probability across the week.</div>
        </div>
        <div class="accuracy-card">
          <div class="accuracy-label">Coverage</div>
          <div class="accuracy-value" id="acc-coverage">--</div>
          <div class="accuracy-note" id="acc-coverage-note">--</div>
        </div>
        <div class="accuracy-card">
          <div class="accuracy-label">Confidence Mix</div>
          <div class="accuracy-value" id="acc-confidence">--</div>
          <div class="accuracy-note">Top prediction confidence by day (High/Med/Low).</div>
        </div>
        <div class="accuracy-card">
          <div class="accuracy-label">Model Depth</div>
          <div class="accuracy-value" id="acc-depth">--</div>
          <div class="accuracy-note" id="acc-depth-note">--</div>
        </div>
      </div>
    </section>

    <section id="favorites-section" hidden>
      <div id="overdue-section" class="overdue-section" hidden>
        <h3>Overdue favorites</h3>
        <div id="overdue-list"></div>
      </div>
      <div id="similar-section" class="similar-section" hidden>
        <h3>Similar flavors in the forecast</h3>
        <div id="similar-list"></div>
      </div>
    </section>
  </main>

  <footer>
    <p>Not affiliated with any restaurant. Flavor data sourced from restaurant websites. Predictions are estimates based on historical patterns.</p>
  </footer>

  <style>
    #store-select {
      width: 100%;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.8125rem;
      margin-top: 0.5rem;
    }

    #flavor-section, #timeline-section, #next-best-section, #accuracy-section, #favorites-section {
      margin-top: 2rem;
    }

    #flavor-section h2, #timeline-section h2, #next-best-section h2, #accuracy-section h2 {
      font-size: 1rem;
      color: #003366;
      margin-bottom: 0.5rem;
    }

    .flavor-results {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
      margin-bottom: 0.75rem;
    }

    .flavor-result-item {
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      font-size: 0.875rem;
    }

    .flavor-result-item:last-child {
      border-bottom: none;
    }

    .flavor-result-item:hover {
      background: #f0f4f8;
    }

    .flavor-result-item .flavor-name {
      font-weight: 600;
      color: #1a1a1a;
    }

    .flavor-result-item .flavor-desc {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.125rem;
    }

    .day-card-flavor {
      font-size: 1.0625rem;
      font-weight: 700;
      color: #1a1a1a;
    }

    .day-card-desc {
      font-size: 0.8125rem;
      color: #666;
      margin-top: 0.25rem;
      line-height: 1.4;
    }

    .day-card-nodata {
      font-style: italic;
      color: #999;
      font-size: 0.8125rem;
    }

    .star-indicator {
      color: #f9a825;
      margin-right: 0.25rem;
    }

    .intel-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      margin-top: 0.25rem;
    }

    .intel-badges-inline {
      margin-top: 0.1rem;
    }

    .intel-badge {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 0.1rem 0.45rem;
      font-size: 0.6875rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      border: 1px solid transparent;
      white-space: nowrap;
    }

    .intel-badge-rarity {
      background: #eef4ff;
      color: #0d3b7a;
      border-color: #bdd6ff;
    }

    .intel-badge-streak {
      background: #fff3e0;
      color: #9a5a00;
      border-color: #ffd8a8;
    }

    .intel-badge-overdue {
      background: #f3f3ff;
      color: #5c3cb0;
      border-color: #ddd3ff;
    }

    .phase2-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
    }

    .phase2-controls label {
      font-size: 0.8125rem;
      color: #666;
      font-weight: 600;
    }

    .phase2-controls select {
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.8125rem;
      padding: 0.35rem 0.45rem;
      background: white;
    }

    .next-best-list {
      display: grid;
      gap: 0.75rem;
      margin-top: 0.75rem;
    }

    .next-best-card {
      border: 1px solid #d9e4ef;
      border-left: 4px solid #003366;
      border-radius: 8px;
      padding: 0.75rem;
      background: #fbfdff;
    }

    .next-best-title {
      font-size: 0.875rem;
      font-weight: 700;
      color: #003366;
      margin-bottom: 0.3rem;
      line-height: 1.35;
    }

    .next-best-detail {
      font-size: 0.8125rem;
      color: #555;
      line-height: 1.4;
      margin-bottom: 0.35rem;
    }

    .next-best-links a {
      font-size: 0.75rem;
      font-weight: 600;
      color: #005696;
      text-decoration: none;
      border-bottom: 1px dotted #005696;
    }

    .next-best-links a:hover {
      color: #003366;
      border-bottom-color: #003366;
    }

    .next-best-badge {
      display: inline-block;
      font-size: 0.6875rem;
      font-weight: 700;
      padding: 0.1rem 0.45rem;
      border-radius: 4px;
      vertical-align: middle;
      margin-left: 0.3rem;
    }
    .next-best-badge-confirmed {
      background: #005696;
      color: #fff;
    }

    .accuracy-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.75rem;
      margin-top: 0.75rem;
    }

    .accuracy-card {
      border: 1px solid #d9e4ef;
      border-radius: 8px;
      background: #fbfdff;
      padding: 0.75rem;
    }

    .accuracy-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #6a7c90;
      margin-bottom: 0.25rem;
      font-weight: 700;
    }

    .accuracy-value {
      font-size: 1.15rem;
      color: #003366;
      font-weight: 800;
      margin-bottom: 0.25rem;
    }

    .accuracy-note {
      font-size: 0.75rem;
      color: #666;
      line-height: 1.3;
    }

    @media (max-width: 640px) {
      .accuracy-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>

  <script>
    const WORKER_BASE = 'https://custard-calendar.chris-kaschner.workers.dev';
    const STORAGE_KEY = 'custard-radar';
    const MAX_FAVORITES = 3;

    // Similarity groups ‚Äî mirrored from worker/src/flavor-matcher.js
    const SIMILARITY_GROUPS = {
      mint: ['andes mint avalanche', 'mint cookie', 'mint explosion'],
      chocolate: ['chocolate caramel twist', 'chocolate heath crunch', 'chocolate volcano', 'dark chocolate decadence', 'dark chocolate pb crunch', 'chocolate oreo volcano'],
      caramel: ['caramel cashew', 'caramel fudge cookie dough', 'caramel pecan', 'caramel turtle', 'salted caramel pecan pie', 'chocolate caramel twist'],
      cheesecake: ['oreo cheesecake', 'oreo cookie cheesecake', 'raspberry cheesecake', 'strawberry cheesecake', 'turtle cheesecake'],
      turtle: ['turtle', 'turtle dove', 'turtle cheesecake', 'caramel turtle'],
      cookie: ['crazy for cookie dough', 'caramel fudge cookie dough', 'mint cookie', 'oreo cookie cheesecake', 'oreo cookies and cream'],
      peanutButter: ['dark chocolate pb crunch', 'peanut butter cup', 'reeses peanut butter cup'],
      berry: ['blackberry cobbler', 'raspberry cheesecake', 'strawberry cheesecake', 'lemon berry layer cake'],
      pecan: ['butter pecan', 'caramel pecan', 'salted caramel pecan pie', 'georgia peach pecan'],
    };

    let allStores = [];
    let flavorCatalog = [];
    let selectedSlug = null;
    let selectedFlavors = new Set();

    // DOM elements
    const stateFilter = document.getElementById('state-filter');
    const citySearch = document.getElementById('city-search');
    const storeSelect = document.getElementById('store-select');
    const storeSelected = document.getElementById('store-selected');
    const flavorSection = document.getElementById('flavor-section');
    const flavorSearch = document.getElementById('flavor-search');
    const flavorResults = document.getElementById('flavor-results');
    const selectedFlavorsEl = document.getElementById('selected-flavors');
    const timelineSection = document.getElementById('timeline-section');
    const timelineEl = document.getElementById('timeline');
    const trustBanner = document.getElementById('trust-banner');
    const nextBestSection = document.getElementById('next-best-section');
    const driveRadius = document.getElementById('drive-radius');
    const refreshNextBestBtn = document.getElementById('refresh-next-best');
    const nextBestStatus = document.getElementById('next-best-status');
    const nextBestList = document.getElementById('next-best-list');
    const accuracySection = document.getElementById('accuracy-section');
    const accTop1 = document.getElementById('acc-top1');
    const accCoverage = document.getElementById('acc-coverage');
    const accCoverageNote = document.getElementById('acc-coverage-note');
    const accConfidence = document.getElementById('acc-confidence');
    const accDepth = document.getElementById('acc-depth');
    const accDepthNote = document.getElementById('acc-depth-note');
    const favoritesSection = document.getElementById('favorites-section');
    const overdueSection = document.getElementById('overdue-section');
    const overdueList = document.getElementById('overdue-list');
    const similarSection = document.getElementById('similar-section');
    const similarList = document.getElementById('similar-list');

    // Phase 2 caches
    const forecastCacheBySlug = new Map();
    const confirmedCacheBySlug = new Map();
    const flavorMetricsCache = new Map();
    const flavorMetricsInflight = new Map();
    let cachedStoreMetrics = null;
    let cachedStoreMetricsSlug = null;
    let storeFlavorCounts = new Map();
    let storeActiveStreaks = new Map();

    // --- Utilities ---
    function toISODate(d) {
      return d.toISOString().slice(0, 10);
    }

    function addDays(d, n) {
      const r = new Date(d);
      r.setDate(r.getDate() + n);
      return r;
    }

    function formatDate(dateStr) {
      const d = new Date(dateStr + 'T12:00:00');
      const today = new Date();
      today.setHours(12, 0, 0, 0);
      const todayStr = toISODate(today);
      const tomorrowStr = toISODate(addDays(today, 1));

      let label = d.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
      if (dateStr === todayStr) label = 'Today -- ' + label;
      else if (dateStr === tomorrowStr) label = 'Tomorrow -- ' + label;
      return label;
    }

    function escapeHtml(str) {
      return String(str || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function normalize(s) {
      return String(s || '').toLowerCase().replace(/[^a-z0-9 ]/g, '').trim();
    }

    function timeSince(iso) {
      if (!iso) return 'Unknown';
      const then = new Date(iso).getTime();
      if (!Number.isFinite(then)) return 'Unknown';
      const deltaMs = Date.now() - then;
      const mins = Math.max(0, Math.round(deltaMs / 60000));
      if (mins < 1) return 'Just now';
      if (mins < 60) return mins + ' min ago';
      const hrs = Math.round(mins / 60);
      if (hrs < 24) return hrs + ' hr ago';
      const days = Math.round(hrs / 24);
      return days + ' day' + (days === 1 ? '' : 's') + ' ago';
    }

    function haversineMiles(lat1, lon1, lat2, lon2) {
      const toRad = (d) => d * Math.PI / 180;
      const R = 3958.8;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    function selectedStore() {
      return allStores.find(s => s.slug === selectedSlug) || null;
    }

    function isFavorite(flavorName) {
      const n = normalize(flavorName);
      for (const fav of selectedFlavors) {
        if (normalize(fav) === n) return true;
      }
      return false;
    }

    function findSimilarFlavors(favorites) {
      const favNorms = [...favorites].map(normalize);
      const similar = new Set();
      for (const fav of favNorms) {
        for (const group of Object.values(SIMILARITY_GROUPS)) {
          if (group.includes(fav)) {
            for (const f of group) {
              if (!favNorms.includes(f)) similar.add(f);
            }
          }
        }
      }
      return [...similar];
    }

    // --- localStorage ---
    function savePrefs() {
      const data = { store: selectedSlug, favorites: [...selectedFlavors] };
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch (e) {}
    }

    function loadPrefs() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (e) { return null; }
    }

    // --- Store loading ---
    async function loadStores(defaultState) {
      try {
        const resp = await fetch('stores.json?v=' + new Date().toISOString().slice(0, 10));
        const data = await resp.json();
        allStores = data.stores || [];
        populateStateFilter();
        if (defaultState && stateFilter.querySelector('option[value="' + defaultState + '"]')) {
          stateFilter.value = defaultState;
        }
        renderStoreList();
      } catch (err) {
        storeSelect.innerHTML = '<option disabled>Failed to load stores</option>';
      }
    }

    async function detectState() {
      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/geolocate');
        const data = await resp.json();
        return data.state || 'WI';
      } catch (e) {
        // Geolocate blocked (CORS / offline) -- default to WI
        return 'WI';
      }
    }

    async function loadCatalog() {
      // Try local static file first (works on any origin), fall back to API
      try {
        const resp = await fetch('flavors.json?v=' + new Date().toISOString().slice(0, 10));
        if (resp.ok) {
          const data = await resp.json();
          flavorCatalog = data.flavors || [];
          return;
        }
      } catch (e) {}
      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/flavors/catalog');
        const data = await resp.json();
        flavorCatalog = data.flavors || [];
      } catch (err) {
        console.error('Failed to load flavor catalog:', err);
      }
    }

    function populateStateFilter() {
      const states = [...new Set(allStores.map(s => s.state))].sort();
      for (const state of states) {
        const opt = document.createElement('option');
        opt.value = state;
        opt.textContent = state;
        stateFilter.appendChild(opt);
      }
    }

    function getFilteredStores() {
      const state = stateFilter.value;
      const query = citySearch.value.toLowerCase().trim();
      return allStores.filter(s => {
        if (state && s.state !== state) return false;
        if (query) {
          const searchable = (s.name + ' ' + s.city + ' ' + s.address + ' ' + s.slug).toLowerCase();
          return searchable.includes(query);
        }
        return true;
      });
    }

    function renderStoreList() {
      const filtered = getFilteredStores();
      storeSelect.innerHTML = '';
      if (filtered.length === 0) {
        storeSelect.innerHTML = '<option disabled>No stores match your search</option>';
      } else {
        for (const store of filtered) {
          const opt = document.createElement('option');
          opt.value = store.slug;
          opt.textContent = store.city + ', ' + store.state + ' \u2014 ' + store.address;
          if (store.slug === selectedSlug) opt.selected = true;
          storeSelect.appendChild(opt);
        }
      }
    }

    function selectStore(slug) {
      selectedSlug = slug;
      const store = allStores.find(s => s.slug === slug);
      if (store) {
        storeSelected.textContent = store.city + ', ' + store.state + ' \u2014 ' + store.address;
        storeSelected.hidden = false;
      }
      flavorSection.hidden = false;
      savePrefs();
      fetchAndRenderTimeline();
    }

    // --- Flavor picker ---
    function searchFlavors(query) {
      if (!query || query.length < 2) {
        flavorResults.hidden = true;
        return;
      }

      const q = query.toLowerCase();
      const matches = flavorCatalog.filter(f => {
        if (selectedFlavors.has(f.title)) return false;
        const inTitle = f.title.toLowerCase().includes(q);
        const inDesc = f.description && f.description.toLowerCase().includes(q);
        return inTitle || inDesc;
      }).slice(0, 10);

      flavorResults.innerHTML = '';
      if (matches.length === 0) {
        flavorResults.innerHTML = '<div class="flavor-result-item"><span class="flavor-desc">No matching flavors found</span></div>';
        flavorResults.hidden = false;
        return;
      }

      for (const f of matches) {
        const item = document.createElement('div');
        item.className = 'flavor-result-item';
        item.innerHTML = '<div class="flavor-name">' + escapeHtml(f.title) + '</div><div class="flavor-desc">' + escapeHtml(f.description || '') + '</div>';
        item.addEventListener('click', () => addFlavor(f.title));
        flavorResults.appendChild(item);
      }
      flavorResults.hidden = false;
    }

    function addFlavor(title) {
      if (selectedFlavors.size >= MAX_FAVORITES) return;
      selectedFlavors.add(title);
      flavorSearch.value = '';
      flavorResults.hidden = true;
      renderSelectedFlavors();
      savePrefs();
      renderTimelineHighlights();
    }

    function removeFlavor(title) {
      selectedFlavors.delete(title);
      renderSelectedFlavors();
      savePrefs();
      renderTimelineHighlights();
    }

    function renderSelectedFlavors() {
      selectedFlavorsEl.innerHTML = '';
      for (const title of selectedFlavors) {
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = title;
        const removeBtn = document.createElement('button');
        removeBtn.textContent = '\u00d7';
        removeBtn.title = 'Remove';
        removeBtn.onclick = () => removeFlavor(title);
        badge.appendChild(removeBtn);
        selectedFlavorsEl.appendChild(badge);
      }
    }

    // --- Timeline ---
    let cachedConfirmed = [];
    let cachedForecast = null;
    let cachedTimeline = [];

    async function fetchForecastForSlug(slug) {
      if (forecastCacheBySlug.has(slug)) {
        return forecastCacheBySlug.get(slug);
      }
      const p = fetch(WORKER_BASE + '/api/v1/forecast/' + encodeURIComponent(slug))
        .then((resp) => resp.ok ? resp.json() : null)
        .catch(() => null);
      forecastCacheBySlug.set(slug, p);
      return p;
    }

    async function fetchConfirmedFlavors(slug) {
      if (confirmedCacheBySlug.has(slug)) {
        return confirmedCacheBySlug.get(slug);
      }
      const p = fetch(WORKER_BASE + '/api/v1/flavors?slug=' + encodeURIComponent(slug))
        .then((resp) => resp.ok ? resp.json() : null)
        .catch(() => null);
      confirmedCacheBySlug.set(slug, p);
      return p;
    }

    async function loadStoreMetrics(slug) {
      if (!slug) return;
      if (cachedStoreMetricsSlug === slug) return;

      cachedStoreMetrics = null;
      cachedStoreMetricsSlug = slug;
      storeFlavorCounts = new Map();
      storeActiveStreaks = new Map();

      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/metrics/store/' + encodeURIComponent(slug));
        if (!resp.ok) return;
        const data = await resp.json();
        cachedStoreMetrics = data;

        for (const row of (data.recent_history || [])) {
          const key = normalize(row.flavor);
          storeFlavorCounts.set(key, (storeFlavorCounts.get(key) || 0) + 1);
        }
        for (const streak of (data.active_streaks || [])) {
          const key = normalize(streak.flavor);
          if (streak.length >= 2) {
            storeActiveStreaks.set(key, streak.length);
          }
        }
      } catch (err) {
        console.debug('Store metrics unavailable:', err);
      }
    }

    async function loadFlavorMetrics(flavorName) {
      const key = normalize(flavorName);
      if (!key) return null;
      if (flavorMetricsCache.has(key)) return flavorMetricsCache.get(key);
      if (flavorMetricsInflight.has(key)) return flavorMetricsInflight.get(key);

      const p = fetch(WORKER_BASE + '/api/v1/metrics/flavor/' + encodeURIComponent(key))
        .then((resp) => resp.ok ? resp.json() : null)
        .then((data) => {
          flavorMetricsCache.set(key, data);
          flavorMetricsInflight.delete(key);
          return data;
        })
        .catch(() => {
          flavorMetricsInflight.delete(key);
          return null;
        });
      flavorMetricsInflight.set(key, p);
      return p;
    }

    async function preloadFlavorMetrics() {
      const unique = new Set();
      for (const day of cachedTimeline) {
        if (day.type === 'confirmed' && day.flavor) {
          unique.add(day.flavor);
        }
        if (day.type === 'predicted') {
          for (const p of day.predictions.slice(0, 3)) {
            unique.add(p.flavor);
          }
        }
      }
      for (const f of selectedFlavors) unique.add(f);
      await Promise.all([...unique].map(loadFlavorMetrics));
      computeRarityPercentiles();
    }

    // Percentile-based rarity: ranks flavors relative to the loaded dataset
    let rarityPercentileMap = new Map(); // normalized_flavor -> percentile (0-100)

    function computeRarityPercentiles() {
      rarityPercentileMap = new Map();
      const entries = [];
      for (const [key, metrics] of flavorMetricsCache) {
        if (!metrics) continue;
        const total = Number(metrics.total_appearances || 0);
        entries.push({ key, total });
      }

      // Sample floor: skip all badges if fewer than 10 distinct flavors
      if (entries.length < 10) return;

      // Sort ascending by appearance count
      entries.sort((a, b) => a.total - b.total);

      // Assign percentile rank
      for (let i = 0; i < entries.length; i++) {
        const percentile = (i / (entries.length - 1)) * 100;
        rarityPercentileMap.set(entries[i].key, percentile);
      }
    }

    function rarityBadge(flavorName) {
      const key = normalize(flavorName);
      const percentile = rarityPercentileMap.get(key);
      if (percentile === undefined) return null;
      if (percentile <= 10) return 'Ultra Rare';
      if (percentile <= 25) return 'Rare';
      if (percentile <= 50) return 'Uncommon';
      return null;
    }

    function streakBadge(flavorName) {
      const key = normalize(flavorName);
      const streakLen = storeActiveStreaks.get(key);
      if (streakLen && streakLen >= 2) {
        return streakLen + '-day streak';
      }
      const monthlyCount = storeFlavorCounts.get(key) || 0;
      if (monthlyCount >= 3) {
        return monthlyCount + 'x this month';
      }
      return null;
    }

    function overdueBadge(flavorName, day) {
      if (!day || day.type !== 'predicted' || !Array.isArray(day.overdue)) return null;
      const key = normalize(flavorName);
      const entry = day.overdue.find((o) => normalize(o.flavor) === key);
      if (!entry || !entry.avg_gap) return null;
      const ratio = entry.days_since / Math.max(entry.avg_gap, 1);
      if (ratio >= 1.5) return 'Overdue return';
      return null;
    }

    function renderFlavorBadges(flavorName, day, inline = false) {
      const chips = [];
      const rarity = rarityBadge(flavorName);
      const streak = streakBadge(flavorName);
      const overdue = overdueBadge(flavorName, day);
      if (rarity) chips.push({ type: 'rarity', label: rarity });
      if (streak) chips.push({ type: 'streak', label: streak });
      if (overdue) chips.push({ type: 'overdue', label: overdue });
      if (chips.length === 0) return '';
      return '<div class="intel-badges' + (inline ? ' intel-badges-inline' : '') + '">' +
        chips.slice(0, 2).map((chip) =>
          '<span class="intel-badge intel-badge-' + chip.type + '">' + escapeHtml(chip.label) + '</span>'
        ).join('') +
      '</div>';
    }

    function renderAccuracyDashboard() {
      if (!selectedSlug || cachedTimeline.length === 0) {
        accuracySection.hidden = true;
        return;
      }

      const predicted = cachedTimeline.filter(d => d.type === 'predicted');
      const confirmed = cachedTimeline.filter(d => d.type === 'confirmed');
      const coveredDays = predicted.length + confirmed.length;
      const topScores = [];
      const confidenceCounts = { high: 0, medium: 0, low: 0 };

      for (const day of confirmed) {
        topScores.push(1.0);
      }
      for (const day of predicted) {
        const top = day.predictions[0];
        if (top && Number.isFinite(top.probability)) {
          topScores.push(top.probability);
          const conf = top.confidence || (top.probability > 0.10 ? 'high' : top.probability >= 0.05 ? 'medium' : 'low');
          if (confidenceCounts[conf] !== undefined) confidenceCounts[conf]++;
        }
      }

      const avgTop = topScores.length
        ? (topScores.reduce((sum, p) => sum + p, 0) / topScores.length)
        : 0;
      accTop1.textContent = (avgTop * 100).toFixed(1) + '%';
      accCoverage.textContent = Math.round((coveredDays / 7) * 100) + '%';
      accCoverageNote.textContent = coveredDays + '/7 days with confirmed or predicted data';
      accConfidence.textContent = confidenceCounts.high + ' / ' + confidenceCounts.medium + ' / ' + confidenceCounts.low;

      if (cachedForecast && cachedForecast.history_depth) {
        accDepth.textContent = cachedForecast.history_depth.toLocaleString();
        accDepthNote.textContent = 'observations, updated ' + timeSince(cachedForecast.generated_at);
      } else {
        accDepth.textContent = '--';
        accDepthNote.textContent = 'Forecast history depth unavailable';
      }

      accuracySection.hidden = false;
    }

    function computePrimaryFavoriteScores() {
      const scores = new Map();
      for (const fav of selectedFlavors) {
        scores.set(normalize(fav), 0);
      }

      for (const day of cachedTimeline) {
        if (day.type === 'confirmed') {
          const k = normalize(day.flavor);
          if (scores.has(k)) scores.set(k, 1);
          continue;
        }
        if (day.type === 'predicted') {
          for (const p of day.predictions || []) {
            const k = normalize(p.flavor);
            if (scores.has(k)) {
              const current = scores.get(k) || 0;
              if (p.probability > current) scores.set(k, p.probability);
            }
          }
        }
      }
      return scores;
    }

    function findBestPredictionForFlavor(forecast, flavorName) {
      if (!forecast || !Array.isArray(forecast.days)) return null;
      const key = normalize(flavorName);
      let best = null;
      for (const day of forecast.days) {
        for (const p of (day.predictions || [])) {
          if (normalize(p.flavor) !== key) continue;
          if (!best || p.probability > best.probability) {
            best = {
              date: day.date,
              probability: p.probability,
              confidence: p.confidence || (p.probability > 0.10 ? 'high' : p.probability >= 0.05 ? 'medium' : 'low'),
            };
          }
        }
      }
      return best;
    }

    function buildCandidateStores(radiusMiles) {
      const primary = selectedStore();
      if (!primary) return [];
      const baseLat = Number(primary.lat);
      const baseLng = Number(primary.lng);
      const hasCoords = Number.isFinite(baseLat) && Number.isFinite(baseLng);

      const candidates = allStores
        .filter(s => s.slug !== selectedSlug)
        .map((s) => {
          const lat = Number(s.lat);
          const lng = Number(s.lng);
          let dist = null;
          if (hasCoords && Number.isFinite(lat) && Number.isFinite(lng)) {
            dist = haversineMiles(baseLat, baseLng, lat, lng);
          }
          return { ...s, _distanceMiles: dist };
        })
        .filter((s) => {
          if (!hasCoords) return s.state === primary.state;
          return s._distanceMiles !== null && s._distanceMiles <= radiusMiles;
        })
        .sort((a, b) => {
          if (a._distanceMiles === null && b._distanceMiles === null) return 0;
          if (a._distanceMiles === null) return 1;
          if (b._distanceMiles === null) return -1;
          return a._distanceMiles - b._distanceMiles;
        });

      return candidates.slice(0, 24);
    }

    async function renderNextBestStoreRecommendations() {
      if (!selectedSlug || selectedFlavors.size === 0 || cachedTimeline.length === 0) {
        nextBestSection.hidden = true;
        return;
      }

      nextBestSection.hidden = false;
      nextBestList.innerHTML = '';
      nextBestStatus.textContent = 'Scanning nearby stores...';

      const radiusMiles = parseInt(driveRadius.value, 10) || 25;
      const candidates = buildCandidateStores(radiusMiles);
      if (candidates.length === 0) {
        nextBestStatus.textContent = 'No nearby stores found in your selected radius.';
        return;
      }

      // Build primary store's flavor set for comparison
      const primaryScores = computePrimaryFavoriteScores();
      const primaryConfirmedFlavors = new Set();
      for (const day of cachedTimeline) {
        if (day.type === 'confirmed') {
          primaryConfirmedFlavors.add(normalize(day.flavor));
        }
      }

      const favorites = [...selectedFlavors];
      const predictedRecs = [];
      const confirmedRecs = [];
      let forecastCount = 0;
      let confirmedOnlyCount = 0;

      await Promise.all(candidates.map(async (store) => {
        // Try forecast first
        const forecast = await fetchForecastForSlug(store.slug);
        if (forecast) {
          forecastCount++;
          for (const fav of favorites) {
            const best = findBestPredictionForFlavor(forecast, fav);
            if (!best) continue;

            const primaryScore = primaryScores.get(normalize(fav)) || 0;
            const minLift = primaryScore < 0.05 ? 0.04 : 0.02;
            if (best.probability < primaryScore + minLift) continue;

            predictedRecs.push({
              store,
              sourceType: 'predicted',
              flavor: fav,
              date: best.date,
              probability: best.probability,
              confidence: best.confidence,
              primaryScore,
              delta: best.probability - primaryScore,
            });
          }
          return;
        }

        // Fallback: confirmed schedule for non-forecast stores
        const confirmed = await fetchConfirmedFlavors(store.slug);
        if (confirmed && confirmed.flavors && confirmed.flavors.length > 0) {
          confirmedOnlyCount++;
          for (const fav of favorites) {
            const favKey = normalize(fav);
            // Only recommend if flavor appears in candidate's confirmed schedule
            // but NOT in primary store's confirmed schedule
            const match = confirmed.flavors.find(f => normalize(f.title) === favKey);
            if (!match) continue;
            if (primaryConfirmedFlavors.has(favKey)) continue;

            confirmedRecs.push({
              store,
              sourceType: 'confirmed',
              flavor: fav,
              date: match.date,
            });
          }
        }
      }));

      // Display order: confirmed first (certainty > probability), predicted second
      const allRecs = [];

      // Confirmed recs: sort by distance
      confirmedRecs.sort((a, b) => ((a.store._distanceMiles || 999) - (b.store._distanceMiles || 999)));
      for (const rec of confirmedRecs) allRecs.push(rec);

      // Predicted recs: sort by lift delta
      predictedRecs.sort((a, b) => (b.delta - a.delta) || (b.probability - a.probability) || ((a.store._distanceMiles || 999) - (b.store._distanceMiles || 999)));
      for (const rec of predictedRecs) allRecs.push(rec);

      if (allRecs.length === 0) {
        const checkedCount = forecastCount + confirmedOnlyCount;
        if (checkedCount === 0) {
          nextBestStatus.textContent = candidates.length + ' nearby stores checked -- no flavor data available yet.';
        } else {
          nextBestStatus.textContent = 'No stronger nearby alternatives found this week.';
        }
        return;
      }

      // Dedupe by flavor, keeping first (confirmed wins over predicted due to sort order)
      const byFlavor = new Map();
      for (const rec of allRecs) {
        const key = normalize(rec.flavor);
        if (!byFlavor.has(key)) byFlavor.set(key, rec);
      }
      const picks = [...byFlavor.values()].slice(0, 3);

      const statusParts = ['Checked ' + candidates.length + ' nearby stores'];
      if (forecastCount > 0) statusParts.push(forecastCount + ' forecast-enabled');
      if (confirmedOnlyCount > 0) statusParts.push(confirmedOnlyCount + ' confirmed-only');
      nextBestStatus.textContent = statusParts.join(', ') + '.';

      nextBestList.innerHTML = picks.map((rec) => {
        const locationQ = rec.store.city && rec.store.state
          ? rec.store.city + ', ' + rec.store.state
          : rec.store.name;
        const mapHref = 'map.html?flavor=' + encodeURIComponent(rec.flavor) +
          '&location=' + encodeURIComponent(locationQ);
        const distText = Number.isFinite(rec.store._distanceMiles)
          ? rec.store._distanceMiles.toFixed(1) + ' mi'
          : 'distance unknown';

        if (rec.sourceType === 'confirmed') {
          return (
            '<div class="next-best-card">' +
              '<div class="next-best-title">' + escapeHtml(rec.flavor) + ': confirmed at ' + escapeHtml(rec.store.name) + '</div>' +
              '<div class="next-best-detail">' +
                escapeHtml(formatDate(rec.date)) +
                ' <span class="next-best-badge next-best-badge-confirmed">Confirmed</span>' +
              '</div>' +
              '<div class="next-best-detail">' +
                escapeHtml(rec.store.address || locationQ) + ' -- ' + distText +
              '</div>' +
              '<div class="next-best-links"><a href="' + mapHref + '">See on map</a></div>' +
            '</div>'
          );
        }

        return (
          '<div class="next-best-card">' +
            '<div class="next-best-title">' + escapeHtml(rec.flavor) + ': better odds at ' + escapeHtml(rec.store.name) + '</div>' +
            '<div class="next-best-detail">' +
              escapeHtml(formatDate(rec.date)) + ' -- ' +
              (rec.probability * 100).toFixed(1) + '% (' + escapeHtml(rec.confidence) + ')' +
              ' vs ' + (rec.primaryScore * 100).toFixed(1) + '% at your primary store.' +
            '</div>' +
            '<div class="next-best-detail">' +
              escapeHtml(rec.store.address || locationQ) + ' -- ' + distText +
            '</div>' +
            '<div class="next-best-links"><a href="' + mapHref + '">See on map</a></div>' +
          '</div>'
        );
      }).join('');
    }

    function findForecastDay(forecast, dateStr) {
      if (!forecast) return null;
      // Multi-day format
      if (forecast.days) {
        return forecast.days.find(d => d.date === dateStr) || null;
      }
      // Legacy single-day format
      if (forecast.date === dateStr) return forecast;
      return null;
    }

    function buildTimeline(confirmedFlavors, forecast, today) {
      const timeline = [];
      for (let i = 0; i < 7; i++) {
        const date = addDays(today, i);
        const dateStr = toISODate(date);

        const confirmed = confirmedFlavors.find(f => f.date === dateStr);
        if (confirmed) {
          timeline.push({ date: dateStr, type: 'confirmed', flavor: confirmed.title, description: confirmed.description || '' });
          continue;
        }

        const forecastDay = findForecastDay(forecast, dateStr);
        if (forecastDay && forecastDay.predictions && forecastDay.predictions.length > 0) {
          timeline.push({ date: dateStr, type: 'predicted', predictions: forecastDay.predictions.slice(0, 5), overdue: forecastDay.overdue_flavors || [] });
          continue;
        }

        timeline.push({ date: dateStr, type: 'none' });
      }
      return timeline;
    }

    async function fetchAndRenderTimeline() {
      if (!selectedSlug) return;
      timelineSection.hidden = false;
      timelineEl.innerHTML = '<p style="color:#666;font-size:0.875rem;">Loading forecast...</p>';

      try {
        const [confirmedResp, forecastResp] = await Promise.all([
          fetch(WORKER_BASE + '/api/v1/flavors?slug=' + encodeURIComponent(selectedSlug)),
          fetchForecastForSlug(selectedSlug),
        ]);

        cachedConfirmed = [];
        if (confirmedResp.ok) {
          const cData = await confirmedResp.json();
          cachedConfirmed = (cData.flavors || []).map(f => ({
            date: f.date,
            title: f.title,
            description: f.description || '',
          }));
        }

        cachedForecast = forecastResp || null;

        const today = new Date();
        today.setHours(12, 0, 0, 0);
        cachedTimeline = buildTimeline(cachedConfirmed, cachedForecast, today);
        await loadStoreMetrics(selectedSlug);
        renderTimeline();
        renderFavoritesIntel();
        renderAccuracyDashboard();
        await renderNextBestStoreRecommendations();
        preloadFlavorMetrics().then(() => {
          renderTimeline();
        });

        if (cachedForecast && cachedForecast.history_depth) {
          trustBanner.textContent = 'Predictions based on ' + cachedForecast.history_depth + ' historical observations for this store.';
          trustBanner.hidden = false;
        } else {
          trustBanner.hidden = true;
        }

      } catch (err) {
        console.error('Timeline fetch error:', err);
        timelineEl.innerHTML = '<p style="color:#c00;font-size:0.875rem;">Failed to load forecast data. Please try again.</p>';
      }
    }

    function renderTimeline() {
      timelineEl.innerHTML = '';
      for (const day of cachedTimeline) {
        const card = document.createElement('div');

        if (day.type === 'confirmed') {
          const hasFav = isFavorite(day.flavor);
          card.className = 'day-card' + (hasFav ? ' day-card-highlight' : '');
          card.innerHTML =
            '<div class="day-card-header">' +
              '<span class="day-card-date">' + escapeHtml(formatDate(day.date)) + '</span>' +
              '<span class="day-card-badge day-card-badge-confirmed">Confirmed</span>' +
            '</div>' +
            '<div class="day-card-flavor">' + (hasFav ? '<span class="star-indicator">*</span>' : '') + escapeHtml(day.flavor) + '</div>' +
            renderFlavorBadges(day.flavor, day) +
            (day.description ? '<div class="day-card-desc">' + escapeHtml(day.description) + '</div>' : '');

        } else if (day.type === 'predicted') {
          const anyFav = day.predictions.some(p => isFavorite(p.flavor));
          card.className = 'day-card day-card-predicted' + (anyFav ? ' day-card-highlight' : '');

          let html =
            '<div class="day-card-header">' +
              '<span class="day-card-date">' + escapeHtml(formatDate(day.date)) + '</span>' +
              '<span class="day-card-badge day-card-badge-predicted">Predicted</span>' +
            '</div>';

          const maxProb = day.predictions[0] ? day.predictions[0].probability : 0.1;
          for (const p of day.predictions) {
            const pct = (p.probability * 100).toFixed(1);
            const barWidth = Math.max(5, (p.probability / Math.max(maxProb, 0.01)) * 100);
            const conf = p.confidence || (p.probability > 0.10 ? 'high' : p.probability >= 0.05 ? 'medium' : 'low');
            const fav = isFavorite(p.flavor);
            html +=
              '<div class="prediction-row">' +
                '<span class="prediction-name' + (fav ? ' prediction-name-favorite' : '') + '">' +
                  (fav ? '<span class="star-indicator">*</span>' : '') +
                  escapeHtml(p.flavor) +
                '</span>' +
                renderFlavorBadges(p.flavor, day, true) +
                '<div class="prediction-bar-wrap">' +
                  '<div class="prediction-bar prediction-bar-' + conf + '" style="width:' + barWidth + '%"></div>' +
                '</div>' +
                '<span class="prediction-pct">' + pct + '%</span>' +
              '</div>';
          }
          card.innerHTML = html;

        } else {
          card.className = 'day-card day-card-none';
          card.innerHTML =
            '<div class="day-card-header">' +
              '<span class="day-card-date">' + escapeHtml(formatDate(day.date)) + '</span>' +
            '</div>' +
            '<div class="day-card-nodata">No forecast data yet</div>';
        }

        timelineEl.appendChild(card);
      }
    }

    function renderTimelineHighlights() {
      // Re-render to update favorite highlights without refetching
      if (cachedTimeline.length > 0) {
        renderTimeline();
        renderFavoritesIntel();
        renderAccuracyDashboard();
        void renderNextBestStoreRecommendations();
      }
    }

    // --- Favorites intelligence ---
    function renderFavoritesIntel() {
      if (selectedFlavors.size === 0) {
        favoritesSection.hidden = true;
        return;
      }

      // Collect all overdue favorites from predicted days
      const allOverdue = [];
      const seenOverdue = new Set();
      for (const day of cachedTimeline) {
        if (day.type === 'predicted' && day.overdue) {
          for (const o of day.overdue) {
            if (isFavorite(o.flavor) && !seenOverdue.has(normalize(o.flavor))) {
              seenOverdue.add(normalize(o.flavor));
              allOverdue.push(o);
            }
          }
        }
      }

      if (allOverdue.length > 0) {
        overdueList.innerHTML = '';
        for (const o of allOverdue) {
          const item = document.createElement('div');
          item.className = 'overdue-item';
          item.innerHTML =
            '<span class="overdue-flavor">' + escapeHtml(o.flavor) + '</span>' +
            '<span class="overdue-detail">' + o.days_since + ' days since last (avg ' + Math.round(o.avg_gap) + ' days)</span>';
          overdueList.appendChild(item);
        }
        overdueSection.hidden = false;
      } else {
        overdueSection.hidden = true;
      }

      // Similar flavors in forecast
      const similarNames = findSimilarFlavors(selectedFlavors);
      if (similarNames.length > 0) {
        // Check which similar flavors appear in predictions
        const forecastFlavors = new Set();
        for (const day of cachedTimeline) {
          if (day.type === 'predicted') {
            for (const p of day.predictions) {
              forecastFlavors.add(normalize(p.flavor));
            }
          }
        }

        const inForecast = similarNames.filter(s => forecastFlavors.has(s));
        if (inForecast.length > 0) {
          similarList.innerHTML = '';
          for (const name of inForecast.slice(0, 5)) {
            const item = document.createElement('div');
            item.className = 'similar-item';
            // Title-case the name
            const display = name.replace(/\b\w/g, c => c.toUpperCase());
            item.innerHTML = '<span>' + escapeHtml(display) + '</span>';
            similarList.appendChild(item);
          }
          similarSection.hidden = false;
        } else {
          similarSection.hidden = true;
        }
      } else {
        similarSection.hidden = true;
      }

      favoritesSection.hidden = overdueSection.hidden && similarSection.hidden;
    }

    // --- Event handlers ---
    stateFilter.addEventListener('change', renderStoreList);
    citySearch.addEventListener('input', renderStoreList);
    storeSelect.addEventListener('change', () => selectStore(storeSelect.value));
    flavorSearch.addEventListener('input', () => searchFlavors(flavorSearch.value));
    flavorSearch.addEventListener('focus', () => searchFlavors(flavorSearch.value));
    driveRadius.addEventListener('change', () => { void renderNextBestStoreRecommendations(); });
    refreshNextBestBtn.addEventListener('click', () => { void renderNextBestStoreRecommendations(); });

    document.addEventListener('click', (e) => {
      if (!e.target.closest('#flavor-section')) {
        flavorResults.hidden = true;
      }
    });

    // --- Init ---
    async function init() {
      const prefs = loadPrefs();
      // Detect state from Cloudflare geoIP, but don't block store loading on it
      const statePromise = prefs && prefs.store ? Promise.resolve(null) : detectState();
      const [detectedState] = await Promise.all([
        statePromise,
        loadCatalog(),
      ]);
      await loadStores(detectedState);

      if (prefs) {
        if (prefs.favorites) {
          for (const f of prefs.favorites.slice(0, MAX_FAVORITES)) {
            selectedFlavors.add(f);
          }
          renderSelectedFlavors();
        }
        if (prefs.store) {
          selectStore(prefs.store);
        }
      }
    }

    init();
  </script>
</body>
</html>
