<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://static.cloudflareinsights.com https://unpkg.com; style-src 'self' 'unsafe-inline' https://unpkg.com; img-src 'self' data: https:; connect-src 'self' https:; font-src 'self' data:; base-uri 'self'; frame-ancestors 'none'">
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <title>Flavor Fronts — Weather Map Forecast</title>
  <meta name="description" content="Weather-map style flavor forecast. See where your favorite custard flavors are strongest across nearby stores over the next 7 days.">
  <meta property="og:title" content="Flavor Fronts — Weather Map Forecast">
  <meta property="og:description" content="Track flavor fronts and forecast strength by store over the next 7 days.">
  <meta property="og:url" content="https://custard.chriskaschner.com/forecast-map.html">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://custard.chriskaschner.com/og/page/fronts.svg">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha384-sHL9NAb7lN7rfvG5lfHpm643Xkcjzp4jFvuavGOndn6pjVqS6ny56CAt3nsEVT4H" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha384-cxOPjt7s7Iz04uaHJceBmS+qpjv2JkIHNVcuOrM+YHwZOmJGBXI00mdUXEq65HTH" crossorigin=""></script>
  <script src="vendor/leaflet-heat-0.2.0.js"></script>
  <!-- Cloudflare Web Analytics --><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "c050ff4e79d54b2abbb60587137d0bb2"}'></script><!-- End Cloudflare Web Analytics -->
</head>
<body>
  <header class="forecast-header">
    <h1 style="color:#005696;font-size:1.5rem;">Flavor Fronts</h1>
    <p style="color:#666;margin-top:0.25rem;font-size:0.875rem;">Weather-map style flavor movement across nearby stores</p>
    <nav class="nav-links" style="margin-top:0.75rem;">
      <a href="index.html">Forecast</a>
      <a href="calendar.html">Calendar</a>
      <a href="map.html">Map</a>
      <a href="radar.html">Radar</a>
      <a href="alerts.html">Alerts</a>
      <a href="siri.html">Siri</a>
      <a href="forecast-map.html" class="nav-active">Fronts</a>
      <a href="quiz.html">Quiz</a>
      <a href="widget.html">Widget</a>
      <a href="scoop.html">The Scoop</a>
    </nav>
  </header>

  <main>
    <section class="panel fronts-controls">
      <div class="view-mode-toggle">
        <button class="view-mode-btn active" data-mode="confirmed" id="mode-confirmed">Confirmed Today</button>
        <button class="view-mode-btn" data-mode="forecast" id="mode-forecast">Forecast</button>
      </div>
      <div class="fronts-control-grid">
        <div class="fronts-control-block">
          <label for="fronts-location">Location</label>
          <div class="location-row">
            <input id="fronts-location" type="text" placeholder="City, state or ZIP">
            <button id="fronts-geo" class="icon-btn" title="Use my location" aria-label="Use my location">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M12 2v4M12 18v4M2 12h4M18 12h4"></path>
              </svg>
            </button>
            <button id="fronts-refresh" class="btn-search">Load Fronts</button>
          </div>
        </div>

        <div class="fronts-control-block">
          <label for="fronts-flavor">Flavor Front</label>
          <select id="fronts-flavor">
            <option value="">Load a location first...</option>
          </select>
        </div>
      </div>
    </section>

    <section class="fronts-layout">
      <div class="fronts-map-shell">
        <div id="fronts-map"></div>

        <div class="fronts-overlay-card fronts-legend-card" aria-label="Map legend">
          <h3>Flavor Intensity</h3>
          <div class="fronts-legend-scale">
            <span class="fronts-legend-band"></span>
            <ul>
              <li>Extreme</li>
              <li>Heavy</li>
              <li>Moderate</li>
              <li>Light</li>
            </ul>
          </div>
        </div>

        <div class="fronts-overlay-card fronts-timeline-card">
          <button id="fronts-play" class="fronts-play-btn" aria-label="Play timeline">
            <span id="fronts-play-icon">&#9654;</span>
          </button>
          <div class="fronts-timeline-main">
            <div class="fronts-timeline-head">
              <div>
                <strong>7-Day Front Forecast</strong>
                <div id="fronts-time-label" class="fronts-time-label">Today</div>
              </div>
              <div id="fronts-active-flavor" class="fronts-active-flavor">No front selected</div>
            </div>
            <input id="fronts-day" type="range" min="0" max="6" step="1" value="0">
            <div class="fronts-tick-row">
              <span>Today</span>
              <span>Day 2</span>
              <span>Day 3</span>
              <span>Day 4</span>
              <span>Day 5</span>
              <span>Day 6</span>
              <span>Day 7</span>
            </div>
            <div class="fronts-status-row">
              <span id="fronts-day-label" class="fronts-day-label">Today</span>
              <span id="fronts-status" class="fronts-status">Select a location to build your local forecast map.</span>
            </div>
          </div>
        </div>
      </div>

      <aside class="panel fronts-side">
        <h2>Front Summary</h2>
        <div class="fronts-metrics">
          <div class="fronts-metric">
            <span class="fronts-metric-label">Stores loaded</span>
            <strong id="metric-stores">0</strong>
          </div>
          <div class="fronts-metric">
            <span class="fronts-metric-label">Active front zones</span>
            <strong id="metric-active">0</strong>
          </div>
          <div class="fronts-metric">
            <span class="fronts-metric-label">Strongest signal</span>
            <strong id="metric-peak">-</strong>
          </div>
        </div>

        <h3>Top Hotspots</h3>
        <ul id="fronts-hotspots" class="fronts-hotspots">
          <li>Load a location to see hotspots.</li>
        </ul>

        <h3>How to Read This</h3>
        <p class="fronts-note">Each marker is a nearby store. Bigger and warmer markers mean a stronger chance of the selected flavor on the selected day.</p>
        <p class="fronts-note">Today uses confirmed flavor data. Future days show estimated flavors from historical patterns.</p>
      </aside>
    </section>
  </main>

  <footer>
    <div class="footer-brands">Confirmed flavor coverage with optional 7-day forecast overlay.</div>
    <p style="margin-top:0.5rem;">Not affiliated with any restaurant. Forecasts are probabilistic and can change.</p>
    <div class="page-share-mount" id="page-share"></div>
  </footer>

  <script src="planner-shared.js"></script>
  <script>CustardPlanner.initShareButton('page-share');</script>
  <script>
    const WORKER_BASE = CustardPlanner.WORKER_BASE;

    const frontsLocationInput = document.getElementById('fronts-location');
    const frontsGeoBtn = document.getElementById('fronts-geo');
    const frontsRefreshBtn = document.getElementById('fronts-refresh');
    const frontsDayInput = document.getElementById('fronts-day');
    const frontsDayLabel = document.getElementById('fronts-day-label');
    const frontsTimeLabel = document.getElementById('fronts-time-label');
    const frontsPlayBtn = document.getElementById('fronts-play');
    const frontsPlayIcon = document.getElementById('fronts-play-icon');
    const frontsActiveFlavor = document.getElementById('fronts-active-flavor');
    const frontsFlavorSelect = document.getElementById('fronts-flavor');
    const frontsStatus = document.getElementById('fronts-status');

    const metricStores = document.getElementById('metric-stores');
    const metricActive = document.getElementById('metric-active');
    const metricPeak = document.getElementById('metric-peak');
    const frontsHotspots = document.getElementById('fronts-hotspots');

    const map = L.map('fronts-map', { zoomControl: false }).setView([43.0, -89.5], 7);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 18,
    }).addTo(map);
    L.control.zoom({ position: 'topright' }).addTo(map);

    const baseLayer = L.layerGroup().addTo(map);
    const signalLayer = L.layerGroup().addTo(map);
    const heatLayer = L.heatLayer([], {
      radius: 45,
      blur: 40,
      maxZoom: 10,
      minOpacity: 0.15,
      gradient: {
        0.15: '#51d8ff',
        0.35: '#1f6bff',
        0.55: '#8c3dff',
        0.75: '#e83e8c',
        1.0: '#fff59d',
      },
    }).addTo(map);

    let nearbyStores = [];
    const forecastCache = new Map();
    let selectedFlavorKey = '';
    let autoPlayTimer = null;
    let pulseAnimationFrame = null;
    let pulseMarkers = [];
    let isAutoPlaying = false;
    let viewMode = 'confirmed'; // 'confirmed' or 'forecast'
    let isTransitioning = false;

    var FLAVOR_FAMILIES = CustardPlanner.FLAVOR_FAMILIES;
    var getFamilyForFlavor = CustardPlanner.getFamilyForFlavor;
    var getFamilyColor = CustardPlanner.getFamilyColor;

    function toISODate(dateObj) {
      return dateObj.toISOString().slice(0, 10);
    }

    function addDays(dateObj, days) {
      const out = new Date(dateObj);
      out.setDate(out.getDate() + days);
      return out;
    }

    var normalizeFlavor = CustardPlanner.normalize;

    var escapeHtml = CustardPlanner.escapeHtml;

    function currentDateAtNoon() {
      const now = new Date();
      now.setHours(12, 0, 0, 0);
      return now;
    }

    function activeDateFromSlider() {
      const dayOffset = Number(frontsDayInput.value || 0);
      return addDays(currentDateAtNoon(), dayOffset);
    }

    function formatDayLabel(dayOffset, activeDate) {
      if (dayOffset === 0) return 'Today';
      if (dayOffset === 1) return 'Tomorrow';
      return activeDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
    }

    function updateDayLabel() {
      const dayOffset = Number(frontsDayInput.value || 0);
      const activeDate = activeDateFromSlider();
      frontsDayLabel.textContent = formatDayLabel(dayOffset, activeDate);
      frontsTimeLabel.textContent = activeDate.toLocaleDateString('en-US', {
        weekday: 'long',
        month: 'short',
        day: 'numeric',
      });
    }

    function setStatus(message, tone) {
      frontsStatus.textContent = message;
      frontsStatus.className = 'fronts-status';
      if (tone === 'error') frontsStatus.classList.add('fronts-status-error');
      if (tone === 'loading') frontsStatus.classList.add('fronts-status-loading');
      if (tone === 'success') frontsStatus.classList.add('fronts-status-success');
    }

    function updateTimelineTicks() {
      var ticks = document.querySelectorAll('.fronts-tick-row span');
      if (!ticks.length) return;
      ticks.forEach(function(tick, i) {
        // Only today (i === 0) has confirmed data from nearby-flavors
        var hasConfirmed = (i === 0);
        tick.style.fontWeight = hasConfirmed ? '700' : '400';
        tick.style.color = hasConfirmed ? '#005696' : '#9fb1d1';
      });
    }

    function flavorMapForDay(dayIso, dayOffset) {
      const scoreMap = new Map();

      function addScore(flavorName, score) {
        const key = normalizeFlavor(flavorName);
        if (!key || !score || score <= 0) return;
        const prior = scoreMap.get(key) || { name: flavorName, score: 0 };
        prior.score += score;
        // Keep the longest / most descriptive display name we've seen
        if ((flavorName || '').length > (prior.name || '').length) prior.name = flavorName;
        scoreMap.set(key, prior);
      }

      for (const store of nearbyStores) {
        if (dayOffset === 0 && store.flavor) {
          addScore(store.flavor, 1);
        }

        const forecast = forecastCache.get(store.slug);
        if (!forecast || !Array.isArray(forecast.days)) continue;
        const day = forecast.days.find((d) => d.date === dayIso);
        if (!day || !Array.isArray(day.predictions)) continue;

        for (const prediction of day.predictions.slice(0, 4)) {
          const probability = Number(prediction.probability || 0);
          if (probability > 0) addScore(prediction.flavor, probability);
        }
      }

      return [...scoreMap.entries()]
        .map(([key, v]) => ({ key, name: v.name, score: v.score }))
        .sort((a, b) => b.score - a.score);
    }

    function populateFlavorSelect() {
      const dayOffset = Number(frontsDayInput.value || 0);
      const dayIso = toISODate(activeDateFromSlider());
      const topFlavors = flavorMapForDay(dayIso, dayOffset).slice(0, 14);

      frontsFlavorSelect.innerHTML = '';
      if (topFlavors.length === 0) {
        frontsFlavorSelect.innerHTML = '<option value="">No forecast flavors available</option>';
        frontsFlavorSelect.disabled = true;
        selectedFlavorKey = '';
        frontsActiveFlavor.textContent = 'No front selected';
        return;
      }

      frontsFlavorSelect.disabled = false;
      const hasPrevious = topFlavors.some((f) => f.key === selectedFlavorKey);
      if (!hasPrevious) selectedFlavorKey = topFlavors[0].key;

      for (const flavor of topFlavors) {
        const option = document.createElement('option');
        option.value = flavor.key;
        option.textContent = flavor.name + ' (' + flavor.score.toFixed(1) + ')';
        if (flavor.key === selectedFlavorKey) option.selected = true;
        frontsFlavorSelect.appendChild(option);
      }
      frontsActiveFlavor.textContent = topFlavors.find((f) => f.key === selectedFlavorKey)?.name || 'No front selected';
    }

    function signalForStore(store, dayIso, dayOffset, flavorKey) {
      if (!flavorKey) return null;

      if (dayOffset === 0 && normalizeFlavor(store.flavor) === flavorKey) {
        return {
          score: 1,
          mode: 'confirmed',
          detail: 'Confirmed today',
        };
      }

      const forecast = forecastCache.get(store.slug);
      if (!forecast || !Array.isArray(forecast.days)) return null;

      const day = forecast.days.find((d) => d.date === dayIso);
      if (!day || !Array.isArray(day.predictions)) return null;

      const prediction = day.predictions.find((p) => normalizeFlavor(p.flavor) === flavorKey);
      if (!prediction) return null;

      const score = Number(prediction.probability || 0);
      if (score <= 0) return null;

      return {
        score,
        mode: 'predicted',
        detail: Math.round(score * 100) + '% forecast',
      };
    }

    function signalColor(signal) {
      if (!signal) return '#94a3b8';
      if (signal.mode === 'confirmed') return '#005696';
      if (signal.score >= 0.18) return '#dc2626';
      if (signal.score >= 0.12) return '#f97316';
      if (signal.score >= 0.08) return '#f59e0b';
      if (signal.score >= 0.05) return '#65a30d';
      return '#0ea5e9';
    }

    function signalRadius(signal) {
      if (!signal) return 3;
      return Math.min(20, 5 + signal.score * 26);
    }

    function signalHeatIntensity(signal) {
      if (!signal) return 0;
      if (signal.mode === 'confirmed') return 1;
      return Math.min(1, signal.score / 0.2);
    }

    function stopPulseAnimation() {
      if (pulseAnimationFrame) {
        cancelAnimationFrame(pulseAnimationFrame);
        pulseAnimationFrame = null;
      }
    }

    function startPulseAnimation() {
      stopPulseAnimation();
      if (!pulseMarkers.length) return;

      function animate(ts) {
        const wave = (Math.sin(ts / 380) + 1) / 2;
        for (const pulse of pulseMarkers) {
          pulse.marker.setRadius(pulse.baseRadius + wave * pulse.bump);
          pulse.marker.setStyle({ fillOpacity: Math.min(0.96, pulse.baseOpacity + wave * 0.18) });
        }
        pulseAnimationFrame = requestAnimationFrame(animate);
      }
      pulseAnimationFrame = requestAnimationFrame(animate);
    }

    function setAutoPlayState(active) {
      isAutoPlaying = active;
      frontsPlayIcon.innerHTML = active ? '&#10074;&#10074;' : '&#9654;';
      frontsPlayBtn.setAttribute('aria-label', active ? 'Pause timeline' : 'Play timeline');
    }

    function stopAutoPlay() {
      if (autoPlayTimer) {
        clearInterval(autoPlayTimer);
        autoPlayTimer = null;
      }
      setAutoPlayState(false);
    }

    function startAutoPlay() {
      if (!nearbyStores.length) return;
      stopAutoPlay();
      setAutoPlayState(true);
      autoPlayTimer = setInterval(function() {
        var slider = document.getElementById('fronts-day');
        var next = (parseInt(slider.value) + 1) % 7;
        smoothTransition(next);
      }, 2500);
    }

    function smoothTransition(targetDay) {
      if (isTransitioning) return;
      isTransitioning = true;

      var fadeOutStart = performance.now();
      var fadeOutDuration = 200;

      function animateFadeOut(ts) {
        var progress = Math.min(1, (ts - fadeOutStart) / fadeOutDuration);
        var ease = progress * progress; // ease-in

        signalLayer.eachLayer(function(layer) {
          if (layer.setStyle) layer.setStyle({ fillOpacity: 0.7 * (1 - ease), opacity: 0.9 * (1 - ease) });
        });

        if (progress < 1) {
          requestAnimationFrame(animateFadeOut);
        } else {
          // Switch day
          var slider = document.getElementById('fronts-day');
          slider.value = targetDay;
          updateDayLabel();
          populateFlavorSelect();
          renderMapSignals();

          // Fade in
          var fadeInStart = performance.now();
          var fadeInDuration = 200;

          function animateFadeIn(ts2) {
            var p2 = Math.min(1, (ts2 - fadeInStart) / fadeInDuration);
            var ease2 = 1 - (1 - p2) * (1 - p2); // ease-out

            signalLayer.eachLayer(function(layer) {
              if (layer.setStyle) layer.setStyle({ fillOpacity: 0.7 * ease2, opacity: 0.9 * ease2 });
            });

            if (p2 < 1) {
              requestAnimationFrame(animateFadeIn);
            } else {
              isTransitioning = false;
            }
          }
          requestAnimationFrame(animateFadeIn);
        }
      }
      requestAnimationFrame(animateFadeOut);
    }

    function toggleAutoPlay() {
      if (isAutoPlaying) stopAutoPlay();
      else startAutoPlay();
    }

    function renderMapSignals() {
      baseLayer.clearLayers();
      signalLayer.clearLayers();
      heatLayer.setLatLngs([]);
      pulseMarkers = [];

      if (viewMode === 'confirmed') {
        renderConfirmedFronts();
        return;
      }

      const dayOffset = Number(frontsDayInput.value || 0);
      const dayIso = toISODate(activeDateFromSlider());
      const flavorKey = frontsFlavorSelect.value;
      selectedFlavorKey = flavorKey;

      let activeCount = 0;
      const hotspots = [];
      const heatPoints = [];

      for (const store of nearbyStores) {
        if (!store.lat || !store.lon) continue;

        // Base point so the region stays readable even when no signal is active.
        L.circleMarker([store.lat, store.lon], {
          radius: 3,
          color: '#e2e8f0',
          weight: 1,
          fillColor: '#cbd5e1',
          fillOpacity: 0.45,
        }).addTo(baseLayer);

        const signal = signalForStore(store, dayIso, dayOffset, flavorKey);
        if (!signal || signal.score < 0.03) continue;

        activeCount += 1;
        hotspots.push({ store, signal });
        heatPoints.push([store.lat, store.lon, signalHeatIntensity(signal)]);

        const marker = L.circleMarker([store.lat, store.lon], {
          radius: signalRadius(signal),
          color: '#0b1220',
          weight: 1.2,
          fillColor: signalColor(signal),
          fillOpacity: Math.min(0.9, 0.45 + signal.score),
        });

        const todayFlavorLine = store.flavor ? '<div><strong>Today:</strong> ' + escapeHtml(store.flavor) + '</div>' : '';
        const lat = Number(store.lat);
        const lon = Number(store.lon || store.lng);
        const popupCtas = CustardPlanner.actionCTAsHTML({
          slug: store.slug,
          storeName: store.name || store.slug,
          lat: Number.isFinite(lat) ? lat : null,
          lon: Number.isFinite(lon) ? lon : null,
          workerBase: WORKER_BASE,
          actions: store.flavor ? ['directions', 'alert', 'calendar'] : ['alert', 'calendar'],
        });
        const popup = '<div class="fronts-popup">'
          + '<div><strong>' + escapeHtml(store.name || store.slug) + '</strong></div>'
          + '<div>' + escapeHtml(store.address || '') + '</div>'
          + todayFlavorLine
          + '<div><strong>Signal:</strong> ' + escapeHtml(signal.detail) + '</div>'
          + popupCtas
          + '</div>';

        marker.bindPopup(popup);
        marker.on('popupopen', function () {
          CustardPlanner.emitInteractionEvent({
            event_type: 'popup_open',
            action: 'store_popup',
            store_slug: store.slug || null,
            flavor: store.flavor || null,
            certainty_tier: store.flavor ? 'confirmed' : 'none',
          });
        });
        marker.addTo(signalLayer);
        pulseMarkers.push({
          marker,
          baseRadius: signalRadius(signal),
          bump: 2.2 + signal.score * 6,
          baseOpacity: Math.min(0.9, 0.45 + signal.score),
        });
      }

      hotspots.sort((a, b) => b.signal.score - a.signal.score);
      renderHotspots(hotspots.slice(0, 8));
      if (heatPoints.length > 0) heatLayer.setLatLngs(heatPoints);

      if (hotspots.length >= 3) {
        const path = hotspots
          .slice(0, 8)
          .sort((a, b) => a.store.lon - b.store.lon)
          .map((h) => [h.store.lat, h.store.lon]);
        L.polyline(path, {
          color: '#67e8f9',
          weight: 2,
          opacity: 0.4,
          dashArray: '10 8',
        }).addTo(signalLayer);
      }

      metricStores.textContent = String(nearbyStores.length);
      metricActive.textContent = String(activeCount);
      if (hotspots.length > 0) {
        const peak = hotspots[0];
        metricPeak.textContent = Math.round(peak.signal.score * 100) + '%';
      } else {
        metricPeak.textContent = '-';
      }
      startPulseAnimation();
    }

    function renderHotspots(entries) {
      frontsHotspots.innerHTML = '';
      if (!entries.length) {
        frontsHotspots.innerHTML = '<li>No strong front zones for this flavor/day yet.</li>';
        return;
      }

      for (const entry of entries) {
        const li = document.createElement('li');
        const pct = Math.round(entry.signal.score * 100);
        li.innerHTML = '<span>' + escapeHtml(entry.store.name || entry.store.slug) + '</span>'
          + '<span class="fronts-hotspot-score">' + pct + '%</span>';
        frontsHotspots.appendChild(li);
      }
    }

    function renderConfirmedFronts() {
      var heatPoints = [];
      var familyStores = {};

      for (var i = 0; i < nearbyStores.length; i++) {
        var store = nearbyStores[i];
        if (!store.lat || !store.lon) continue;

        // Base dot for all stores
        L.circleMarker([store.lat, store.lon], {
          radius: 3, fillColor: '#888', fillOpacity: 0.3, stroke: false
        }).addTo(baseLayer);

        if (!store.flavor) continue;

        var family = getFamilyForFlavor(store.flavor);
        var familyColor = getFamilyColor(store.flavor);
        var familyKey = family || 'other';

        // Colored marker by family
        var marker = L.circleMarker([store.lat, store.lon], {
          radius: 10,
          fillColor: familyColor,
          fillOpacity: 0.7,
          color: familyColor,
          weight: 2,
          opacity: 0.9
        }).addTo(signalLayer);

        var cLat = Number(store.lat);
        var cLon = Number(store.lon || store.lng);
        var confirmedCtas = CustardPlanner.actionCTAsHTML({
          slug: store.slug,
          storeName: store.name,
          lat: Number.isFinite(cLat) ? cLat : null,
          lon: Number.isFinite(cLon) ? cLon : null,
          workerBase: WORKER_BASE,
          actions: ['directions', 'alert', 'calendar'],
        });
        marker.bindPopup(
          '<strong>' + escapeHtml(store.name) + '</strong>'
          + ' <span class="popup-confirmed">Confirmed</span><br>'
          + escapeHtml(store.address || '') + '<br>'
          + '<em>' + escapeHtml(store.flavor) + '</em>'
          + (family ? '<br><span style="color:' + familyColor + ';">' + family + ' family</span>' : '')
          + confirmedCtas
        );
        marker.on('popupopen', function () {
          CustardPlanner.emitInteractionEvent({
            event_type: 'popup_open',
            action: 'store_popup',
            store_slug: store.slug || null,
            flavor: store.flavor || null,
            certainty_tier: 'confirmed',
          });
        });

        // Group by family
        if (!familyStores[familyKey]) familyStores[familyKey] = [];
        familyStores[familyKey].push({ lat: store.lat, lon: store.lon, store: store, color: familyColor });

        // Heat point
        heatPoints.push([store.lat, store.lon, 0.8]);

        pulseMarkers.push({
          marker: marker,
          baseRadius: 10,
          bump: 3,
          baseOpacity: 0.7
        });
      }

      heatLayer.setLatLngs(heatPoints);

      // Count stores with confirmed flavors
      var confirmedCount = 0;
      for (var j = 0; j < nearbyStores.length; j++) {
        if (nearbyStores[j].flavor) confirmedCount++;
      }

      // Update metrics
      metricStores.textContent = String(nearbyStores.length);
      metricActive.textContent = String(confirmedCount);
      metricPeak.textContent = Object.keys(familyStores).length + ' families';

      // Render hotspots grouped by family
      renderConfirmedHotspots(familyStores);

      startPulseAnimation();
    }

    function renderConfirmedHotspots(familyStores) {
      frontsHotspots.innerHTML = '';

      // Sort families by store count
      var familyEntries = Object.entries(familyStores).sort(function(a, b) { return b[1].length - a[1].length; });

      if (!familyEntries.length) {
        frontsHotspots.innerHTML = '<li>No confirmed flavors for nearby stores today.</li>';
        return;
      }

      for (var i = 0; i < Math.min(familyEntries.length, 8); i++) {
        var familyName = familyEntries[i][0];
        var stores = familyEntries[i][1];
        var color = stores[0] ? stores[0].color : '#666';
        var li = document.createElement('li');
        li.className = 'hotspot-row';
        li.innerHTML = '<span class="hotspot-dot" style="background:' + color + '"></span>' +
          '<span class="hotspot-name">' + escapeHtml(familyName) + '</span>' +
          '<span class="hotspot-score">' + stores.length + ' stores</span>';
        frontsHotspots.appendChild(li);
      }
    }

    async function fetchNearbyStores(locationText) {
      const url = WORKER_BASE + '/api/v1/nearby-flavors?location=' + encodeURIComponent(locationText) + '&limit=40';
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error('Unable to load nearby stores (' + resp.status + ')');
      }
      const data = await resp.json();
      const stores = (data.nearby || []).filter((store) => store.lat && store.lon && store.slug);
      return stores;
    }

    async function fetchForecastForSlug(slug) {
      if (forecastCache.has(slug)) return forecastCache.get(slug);

      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/forecast/' + encodeURIComponent(slug));
        if (!resp.ok) {
          forecastCache.set(slug, null);
          return null;
        }
        const payload = await resp.json();
        forecastCache.set(slug, payload);
        return payload;
      } catch {
        forecastCache.set(slug, null);
        return null;
      }
    }

    async function warmForecasts(stores) {
      await Promise.all(stores.map((store) => fetchForecastForSlug(store.slug)));
    }

    function fitMapToStores(stores) {
      const bounds = L.latLngBounds();
      for (const store of stores) {
        bounds.extend([store.lat, store.lon]);
      }
      if (bounds.isValid()) {
        map.fitBounds(bounds, { padding: [35, 35], maxZoom: 11 });
      }
    }

    async function reverseGeocode(lat, lon) {
      try {
        const resp = await fetch('https://nominatim.openstreetmap.org/reverse?lat=' + lat + '&lon=' + lon + '&format=json&zoom=10');
        const data = await resp.json();
        const address = data.address || {};
        const city = address.city || address.town || address.village || address.county || '';
        const state = address.state || '';
        if (city && state) return city + ', ' + state;
      } catch {
        // Fall through to null.
      }
      return null;
    }

    async function useDetectedLocation() {
      frontsGeoBtn.disabled = true;
      try {
        if (navigator.geolocation) {
          const pos = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 5000 });
          });
          const label = await reverseGeocode(pos.coords.latitude, pos.coords.longitude);
          if (label) {
            frontsLocationInput.value = label;
            frontsGeoBtn.disabled = false;
            await loadFronts();
            return;
          }
        }
      } catch {
        // Fall back to CF geolocation.
      }

      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/geolocate');
        const geo = await resp.json();
        if (geo.city && geo.state) {
          frontsLocationInput.value = geo.city + ', ' + geo.state;
          await loadFronts();
        } else {
          setStatus('Unable to determine location. Enter a city or ZIP.', 'error');
        }
      } catch {
        setStatus('Unable to determine location. Enter a city or ZIP.', 'error');
      }

      frontsGeoBtn.disabled = false;
    }

    async function loadFronts() {
      const locationText = frontsLocationInput.value.trim();
      if (!locationText) {
        setStatus('Enter a location first (for example: Madison, WI).', 'error');
        frontsLocationInput.focus();
        return;
      }

      setStatus('Loading nearby stores and forecast fronts...', 'loading');
      frontsRefreshBtn.disabled = true;

      try {
        const stores = await fetchNearbyStores(locationText);
        if (!stores.length) {
          nearbyStores = [];
          baseLayer.clearLayers();
          signalLayer.clearLayers();
          heatLayer.setLatLngs([]);
          stopPulseAnimation();
          stopAutoPlay();
          metricStores.textContent = '0';
          metricActive.textContent = '0';
          metricPeak.textContent = '-';
          frontsHotspots.innerHTML = '<li>No stores returned for this location.</li>';
          frontsFlavorSelect.innerHTML = '<option value="">No stores found</option>';
          frontsFlavorSelect.disabled = true;
          setStatus('No nearby stores found. Try a different city or ZIP.', 'error');
          return;
        }

        nearbyStores = stores;
        fitMapToStores(nearbyStores);
        await warmForecasts(nearbyStores);

        updateDayLabel();
        updateTimelineTicks();
        populateFlavorSelect();
        renderMapSignals();

        const dayOffset = Number(frontsDayInput.value || 0);
        const dayText = dayOffset === 0 ? 'today' : 'day ' + dayOffset;
        setStatus('Loaded ' + nearbyStores.length + ' stores. Showing fronts for ' + dayText + '.', 'success');
      } catch (err) {
        setStatus(err.message || 'Failed to load fronts.', 'error');
      } finally {
        frontsRefreshBtn.disabled = false;
      }
    }

    frontsRefreshBtn.addEventListener('click', loadFronts);
    frontsLocationInput.addEventListener('keydown', (evt) => {
      if (evt.key === 'Enter') loadFronts();
    });

    frontsGeoBtn.addEventListener('click', useDetectedLocation);
    frontsPlayBtn.addEventListener('click', toggleAutoPlay);

    document.getElementById('mode-confirmed').addEventListener('click', function() {
      viewMode = 'confirmed';
      this.classList.add('active');
      document.getElementById('mode-forecast').classList.remove('active');
      // Hide forecast-only controls in confirmed mode
      var timelineCard = document.querySelector('.fronts-timeline-card');
      var flavorBlock = frontsFlavorSelect.closest('.fronts-control-block');
      if (timelineCard) timelineCard.style.display = 'none';
      if (flavorBlock) flavorBlock.style.display = 'none';
      stopAutoPlay();
      renderMapSignals();
    });

    document.getElementById('mode-forecast').addEventListener('click', function() {
      viewMode = 'forecast';
      this.classList.add('active');
      document.getElementById('mode-confirmed').classList.remove('active');
      // Show forecast controls
      var timelineCard = document.querySelector('.fronts-timeline-card');
      var flavorBlock = frontsFlavorSelect.closest('.fronts-control-block');
      if (timelineCard) timelineCard.style.display = '';
      if (flavorBlock) flavorBlock.style.display = '';
      populateFlavorSelect();
      renderMapSignals();
    });

    frontsDayInput.addEventListener('input', function(evt) {
      if (evt.isTrusted && isAutoPlaying) stopAutoPlay();
      smoothTransition(parseInt(this.value));
    });

    frontsFlavorSelect.addEventListener('change', () => {
      selectedFlavorKey = frontsFlavorSelect.value;
      frontsActiveFlavor.textContent = frontsFlavorSelect.options[frontsFlavorSelect.selectedIndex]?.textContent || 'No front selected';
      renderMapSignals();
    });

    function applyViewModeVisibility() {
      var timelineCard = document.querySelector('.fronts-timeline-card');
      var flavorBlock = frontsFlavorSelect.closest('.fronts-control-block');
      if (viewMode === 'confirmed') {
        if (timelineCard) timelineCard.style.display = 'none';
        if (flavorBlock) flavorBlock.style.display = 'none';
      } else {
        if (timelineCard) timelineCard.style.display = '';
        if (flavorBlock) flavorBlock.style.display = '';
      }
    }

    async function init() {
      updateDayLabel();
      applyViewModeVisibility();

      try {
        const resp = await fetch(WORKER_BASE + '/api/v1/geolocate');
        if (resp.ok) {
          const geo = await resp.json();
          if (geo.city && geo.state) {
            frontsLocationInput.value = geo.city + ', ' + geo.state;
            await loadFronts();
            return;
          }
        }
      } catch {
        // No-op: user can type location manually.
      }

      setStatus('Select a location to build your local forecast map.', 'success');
    }

    init();
  </script>
</body>
</html>
