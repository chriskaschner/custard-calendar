<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custard Map ‚Äî Find a Flavor Near You</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üç¶</text></svg>">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
</head>
<body>
  <header>
    <h1>Custard Map</h1>
    <p>Find a Culver's Flavor of the Day near you.</p>
    <nav class="nav-links">
      <a href="index.html">Calendar</a>
      <a href="alerts.html">Alerts</a>
    </nav>
  </header>

  <main>
    <section id="search-controls">
      <div class="filter-row">
        <div class="filter-group">
          <label for="flavor-input">Flavor (optional)</label>
          <input type="text" id="flavor-input" list="flavor-list" placeholder="e.g. Mint Explosion">
          <datalist id="flavor-list"></datalist>
        </div>
        <div class="filter-group filter-group-location">
          <label for="location-input">Location</label>
          <div class="location-row">
            <input type="text" id="location-input" placeholder="Zip code or city...">
            <button id="geolocate-btn" title="Use my location" class="icon-btn">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="filter-group filter-group-btn">
          <label>&nbsp;</label>
          <button id="search-btn" class="btn btn-search">Search</button>
        </div>
        <div class="filter-group filter-group-btn">
          <label>&nbsp;</label>
          <button id="not-culvers-btn">Not Culver's</button>
        </div>
      </div>
    </section>

    <section id="suggestions-panel" hidden>
      <div id="suggestions-content"></div>
    </section>

    <section id="map-container">
      <div id="map"></div>
    </section>

    <section id="results-list" hidden>
      <h2 id="results-heading">Results</h2>
      <div id="results-body"></div>
    </section>
  </main>

  <footer>
    <p>Not affiliated with Culver's. Data sourced from <a href="https://www.culvers.com" target="_blank" rel="noopener">culvers.com</a>.</p>
  </footer>

  <script>
    const WORKER_BASE = 'https://custard-calendar.chris-kaschner.workers.dev';

    const BRAND_COLORS = {
      kopps: '#000000',
      gilles: '#EBCC35',
      hefners: '#93BE46',
      kraverz: '#CE742D',
      oscars: '#BC272C',
    };

    const BRAND_DISPLAY = {
      kopps: "Kopp's",
      gilles: "Gille's",
      hefners: "Hefner's",
      kraverz: "Kraverz",
      oscars: "Oscar's",
    };

    // Known flavors for autocomplete
    const KNOWN_FLAVORS = [
      'Andes Mint Avalanche', 'Blackberry Cobbler', 'Brownie Thunder',
      'Butter Pecan', 'Caramel Cashew', 'Caramel Fudge Cookie Dough',
      'Caramel Pecan', 'Caramel Turtle', 'Chocolate Caramel Twist',
      'Chocolate Heath Crunch', 'Chocolate Oreo Volcano', 'Chocolate Volcano',
      'Crazy for Cookie Dough', 'Dark Chocolate Decadence',
      'Dark Chocolate PB Crunch', 'Georgia Peach Pecan',
      'Lemon Berry Layer Cake', 'Lemon Dash Cookie', 'Mint Cookie',
      'Mint Explosion', 'OREO Cheesecake', 'OREO Cookies and Cream',
      'Peanut Butter Cup', 'Raspberry Cheesecake', 'Really Reese\'s',
      'Salted Caramel Pecan Pie', 'Snickers Swirl',
      'Strawberry Cheesecake', 'Turtle', 'Turtle Cheesecake',
      'Turtle Dove', 'Vanilla',
    ];

    // DOM elements
    const flavorInput = document.getElementById('flavor-input');
    const flavorList = document.getElementById('flavor-list');
    const locationInput = document.getElementById('location-input');
    const geolocateBtn = document.getElementById('geolocate-btn');
    const searchBtn = document.getElementById('search-btn');
    const suggestionsPanel = document.getElementById('suggestions-panel');
    const suggestionsContent = document.getElementById('suggestions-content');
    const resultsSection = document.getElementById('results-list');
    const resultsHeading = document.getElementById('results-heading');
    const resultsBody = document.getElementById('results-body');

    // Map setup
    const map = L.map('map').setView([43.0, -89.5], 7); // Default: Wisconsin
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 18,
    }).addTo(map);

    let markers = L.layerGroup().addTo(map);
    const notCulversBtn = document.getElementById('not-culvers-btn');
    let notCulversActive = false;
    let brandStores = []; // loaded from stores.json
    let skipMoveHandler = false; // flag to skip moveend during programmatic fitBounds

    // Populate flavor datalist
    for (const f of KNOWN_FLAVORS) {
      const opt = document.createElement('option');
      opt.value = f;
      flavorList.appendChild(opt);
    }

    // Read URL params on load
    function readUrlParams() {
      const params = new URLSearchParams(window.location.search);
      if (params.get('flavor')) flavorInput.value = params.get('flavor');
      if (params.get('location')) locationInput.value = params.get('location');
      if (params.get('location')) doSearch();
    }

    // Update URL without reload
    function updateUrl() {
      const params = new URLSearchParams();
      if (flavorInput.value.trim()) params.set('flavor', flavorInput.value.trim());
      if (locationInput.value.trim()) params.set('location', locationInput.value.trim());
      const qs = params.toString();
      const newUrl = qs ? `${window.location.pathname}?${qs}` : window.location.pathname;
      history.replaceState(null, '', newUrl);
    }

    // Geolocation
    geolocateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        return;
      }
      geolocateBtn.disabled = true;
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          locationInput.value = `${pos.coords.latitude.toFixed(4)},${pos.coords.longitude.toFixed(4)}`;
          geolocateBtn.disabled = false;
          doSearch();
        },
        (err) => {
          geolocateBtn.disabled = false;
          // Fall back to IP-based geolocation
          autoGeolocate();
        },
        { timeout: 5000 }
      );
    });

    async function autoGeolocate() {
      try {
        const resp = await fetch(`${WORKER_BASE}/api/geolocate`);
        const geo = await resp.json();
        if (geo.city && geo.state) {
          locationInput.value = `${geo.city}, ${geo.state}`;
          doSearch();
        }
      } catch (err) {
        console.debug('Geolocation unavailable:', err);
      }
    }

    // Search
    searchBtn.addEventListener('click', doSearch);
    locationInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') doSearch();
    });
    flavorInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') doSearch();
    });

    // Debounced map move handler for dynamic search
    let moveTimer = null;
    map.on('moveend', () => {
      if (skipMoveHandler) { skipMoveHandler = false; return; }
      if (notCulversActive) return; // don't re-search in "Not Culver's" mode
      clearTimeout(moveTimer);
      moveTimer = setTimeout(() => {
        const center = map.getCenter();
        locationInput.value = `${center.lat.toFixed(4)},${center.lng.toFixed(4)}`;
        doSearch(true); // true = triggered by map move (skip fitBounds)
      }, 300);
    });

    let searchAbort = null;

    async function doSearch(fromMapMove = false) {
      const location = locationInput.value.trim();
      if (!location) {
        locationInput.focus();
        return;
      }

      updateUrl();

      // Cancel previous search
      if (searchAbort) searchAbort.abort();
      searchAbort = new AbortController();

      searchBtn.disabled = true;
      searchBtn.textContent = 'Searching...';
      suggestionsPanel.hidden = true;
      resultsSection.hidden = true;

      const flavor = flavorInput.value.trim();
      let url = `${WORKER_BASE}/api/nearby-flavors?location=${encodeURIComponent(location)}`;
      if (flavor) url += `&flavor=${encodeURIComponent(flavor)}`;

      try {
        const resp = await fetch(url, { signal: searchAbort.signal });
        if (!resp.ok) {
          const err = await resp.json().catch(() => ({}));
          throw new Error(err.error || `HTTP ${resp.status}`);
        }
        const data = await resp.json();
        renderResults(data, fromMapMove);
      } catch (err) {
        if (err.name === 'AbortError') return;
        resultsBody.innerHTML = `<div class="error-msg">Search failed: ${escapeHtml(err.message)}</div>`;
        resultsSection.hidden = false;
      } finally {
        searchBtn.disabled = false;
        searchBtn.textContent = 'Search';
      }
    }

    function renderResults(data, skipFitBounds = false) {
      markers.clearLayers();

      const hasFlavorFilter = !!data.query.flavor;
      const allStores = [...data.matches, ...data.nearby];

      if (allStores.length === 0) {
        resultsBody.innerHTML = '<div class="no-results">No Culver\'s locations found near that location.</div>';
        resultsSection.hidden = false;
        return;
      }

      // Suggestions with rotating fun intros
      if (hasFlavorFilter && data.matches.length === 0 && data.suggestions.length > 0) {
        const intros = [
          'You could broaden your horizons and try',
          'How about something a little different?',
          'What about something out of left field?',
          'Might I interest you in',
          'Live a little ‚Äî go for',
          'Plot twist:',
          'Hear me out ‚Äî',
          'The universe is telling you to try',
          'Your taste buds called, they want',
          'Bold move incoming:',
          'Cone-sider trying',
          'Don\'t have a meltdown ‚Äî try',
          'Sundae funday alternative:',
          'This one\'s the real scoop:',
          'Spoon-worthy option:',
          'Worth the brain freeze:',
        ];
        // Shuffle and pick one intro per suggestion
        const shuffled = intros.sort(() => Math.random() - 0.5);
        const lines = data.suggestions.map((s, i) => {
          const intro = shuffled[i % shuffled.length];
          const link = `<button class="suggestion-link" data-flavor="${escapeAttr(s.flavor)}">${escapeHtml(s.flavor)}</button>`;
          const count = `(${s.count} store${s.count > 1 ? 's' : ''})`;
          return `${intro} ${link} ${count}`;
        });
        suggestionsContent.innerHTML = `<strong>No ${escapeHtml(data.query.flavor)} today.</strong><br>${lines.join('<br>')}`;
        suggestionsPanel.hidden = false;

        // Bind suggestion clicks
        suggestionsPanel.querySelectorAll('.suggestion-link').forEach(btn => {
          btn.addEventListener('click', () => {
            flavorInput.value = btn.dataset.flavor;
            doSearch();
          });
        });
      } else if (hasFlavorFilter && data.matches.length > 0) {
        suggestionsPanel.hidden = true;
      } else {
        suggestionsPanel.hidden = true;
      }

      // Map markers
      const bounds = L.latLngBounds();

      for (const store of data.matches) {
        if (!store.lat || !store.lon) continue;
        const marker = L.marker([store.lat, store.lon], {
          icon: greenIcon,
        }).bindPopup(storePopup(store, true));
        markers.addLayer(marker);
        bounds.extend([store.lat, store.lon]);
      }

      for (const store of data.nearby) {
        if (!store.lat || !store.lon) continue;
        const marker = L.marker([store.lat, store.lon], {
          icon: hasFlavorFilter ? blueIcon : defaultIcon,
        }).bindPopup(storePopup(store, false));
        markers.addLayer(marker);
        bounds.extend([store.lat, store.lon]);
      }

      if (bounds.isValid() && !skipFitBounds) {
        skipMoveHandler = true;
        map.fitBounds(bounds, { padding: [30, 30], maxZoom: 12 });
      }

      // Results list
      let html = '';

      if (hasFlavorFilter && data.matches.length > 0) {
        html += `<div class="results-group"><h3 class="results-group-title match-title">Stores with ${escapeHtml(data.query.flavor)} (${data.matches.length})</h3>`;
        for (const store of data.matches) {
          html += storeCard(store, true);
        }
        html += '</div>';
      }

      if (data.nearby.length > 0) {
        let nearbyLabel;
        if (!hasFlavorFilter) {
          nearbyLabel = `Nearby stores (${data.nearby.length})`;
        } else if (data.matches.length > 0) {
          const altIntros = [
            'Meanwhile, nearby',
            'Not your flavor? These stores beg to differ',
            'Other scoops in the neighborhood',
            'The rest of the cone-petition',
            'What the other stores are dishing out',
            'In other frozen news',
            'But wait, there\'s more custard',
            'The supporting cast',
          ];
          nearbyLabel = altIntros[Math.floor(Math.random() * altIntros.length)];
        } else {
          const nearbyIntros = [
            `No ${escapeHtml(data.query.flavor)} nearby ‚Äî here's what's scooping instead`,
            `${escapeHtml(data.query.flavor)}? Not today. But check out what is`,
            `Fresh out of ${escapeHtml(data.query.flavor)} ‚Äî but never fresh out of options`,
            `The custard must flow ‚Äî just not ${escapeHtml(data.query.flavor)} right now`,
            `${escapeHtml(data.query.flavor)} is playing hard to get. These aren't`,
            `No ${escapeHtml(data.query.flavor)}? That's the way the cookie crumbles. Here's what's left`,
            `We all scream for ${escapeHtml(data.query.flavor)} but today we settle`,
            `Life gave you no ${escapeHtml(data.query.flavor)}. Make custard-ade`,
          ];
          nearbyLabel = nearbyIntros[Math.floor(Math.random() * nearbyIntros.length)];
        }
        html += `<div class="results-group"><h3 class="results-group-title">${nearbyLabel}</h3>`;
        for (const store of data.nearby) {
          html += storeCard(store, false);
        }
        html += '</div>';
      }

      resultsBody.innerHTML = html;
      resultsSection.hidden = false;
    }

    // Custom map icons
    const greenIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41],
    });

    const blueIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41],
    });

    const defaultIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41],
    });

    function storePopup(store, isMatch) {
      const matchBadge = isMatch ? ' <span class="popup-match">MATCH</span>' : '';
      const desc = store.description ? `<br><small>${escapeHtml(store.description)}</small>` : '';
      const brandLabel = store.brand && BRAND_DISPLAY[store.brand] ? `<small style="color:${BRAND_COLORS[store.brand] || '#003366'}">${escapeHtml(BRAND_DISPLAY[store.brand])}</small><br>` : '';
      return `<div class="store-popup">
        ${brandLabel}<strong>${escapeHtml(store.name)}</strong>${matchBadge}<br>
        ${escapeHtml(store.address)}<br>
        <em>${escapeHtml(store.flavor)}</em>${desc}
      </div>`;
    }

    function brandClass(store) {
      if (store.brand && BRAND_COLORS[store.brand]) return ` brand-${store.brand}`;
      return '';
    }

    function storeCard(store, isMatch) {
      const matchClass = isMatch ? ' store-card-match' : (store.brand ? brandClass(store) : ' brand-culvers');
      const brandLabel = store.brand && BRAND_DISPLAY[store.brand] ? `<span style="color:${BRAND_COLORS[store.brand] || '#003366'}; font-size:0.75rem; font-weight:600">${escapeHtml(BRAND_DISPLAY[store.brand])}</span> ` : '';
      const culversUrl = store.slug ? (store.brand ? '#' : `https://www.culvers.com/restaurants/${encodeURIComponent(store.slug)}`) : '#';
      const linkText = store.brand ? '' : `<a class="store-card-link" href="${culversUrl}" target="_blank" rel="noopener">View on culvers.com</a>`;
      const desc = store.description ? `<div class="store-card-description">${escapeHtml(store.description)}</div>` : '';
      const rankHtml = store.rank != null ? `<span class="store-card-rank">#${store.rank}</span>` : '';
      return `<div class="store-card${matchClass}">
        <div class="store-card-header">
          <span class="store-card-name">${brandLabel}${escapeHtml(store.name)}</span>
          ${rankHtml}
        </div>
        <div class="store-card-address">${escapeHtml(store.address || '')}</div>
        <div class="store-card-flavor">${escapeHtml(store.flavor || 'Loading...')}</div>
        ${desc}
        ${linkText}
      </div>`;
    }

    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function escapeAttr(str) {
      return escapeHtml(str);
    }

    // Load brand stores from stores.json
    async function loadBrandStores() {
      if (brandStores.length > 0) return brandStores;
      try {
        const resp = await fetch('stores.json?v=' + new Date().toISOString().slice(0, 10));
        const data = await resp.json();
        brandStores = (data.stores || []).filter(s => s.brand);
      } catch (err) {
        console.error('Failed to load brand stores:', err);
      }
      return brandStores;
    }

    // "Not Culver's" toggle
    notCulversBtn.addEventListener('click', async () => {
      notCulversActive = !notCulversActive;
      notCulversBtn.classList.toggle('active', notCulversActive);

      if (!notCulversActive) {
        // Toggle off: clear and re-search normally
        notCulversBtn.textContent = "Not Culver's";
        markers.clearLayers();
        resultsSection.hidden = true;
        if (locationInput.value.trim()) doSearch();
        return;
      }

      notCulversBtn.textContent = 'Loading...';
      const stores = await loadBrandStores();
      if (stores.length === 0) {
        notCulversBtn.textContent = 'No stores';
        setTimeout(() => {
          notCulversBtn.textContent = "Not Culver's";
          notCulversActive = false;
          notCulversBtn.classList.remove('active');
        }, 2000);
        return;
      }

      // Fetch today's flavor for each brand store in parallel
      const flavorPromises = stores.map(async (store) => {
        try {
          const resp = await fetch(`${WORKER_BASE}/api/flavors?slug=${encodeURIComponent(store.slug)}`);
          if (!resp.ok) return { ...store, flavor: 'Unavailable' };
          const data = await resp.json();
          const today = new Date().toISOString().slice(0, 10);
          const todayFlavor = (data.flavors || []).find(f => f.date === today);
          return { ...store, flavor: todayFlavor ? todayFlavor.flavor : (data.flavors && data.flavors[0] ? data.flavors[0].flavor : 'Unavailable'), description: todayFlavor ? (todayFlavor.description || '') : '' };
        } catch {
          return { ...store, flavor: 'Unavailable' };
        }
      });

      const results = await Promise.all(flavorPromises);

      notCulversBtn.textContent = "Not Culver's";

      // Render brand store results
      markers.clearLayers();
      const bounds = L.latLngBounds();

      for (const store of results) {
        if (!store.lat && !store.lng) continue;
        const lat = store.lat;
        const lng = store.lng;
        const color = BRAND_COLORS[store.brand] || '#003366';
        const marker = L.circleMarker([lat, lng], {
          radius: 10,
          fillColor: color,
          color: '#fff',
          weight: 2,
          fillOpacity: 0.9,
        }).bindPopup(storePopup(store, false));
        markers.addLayer(marker);
        bounds.extend([lat, lng]);
      }

      if (bounds.isValid()) {
        skipMoveHandler = true;
        map.fitBounds(bounds, { padding: [30, 30], maxZoom: 12 });
      }

      // Render result cards
      let html = `<div class="results-group"><h3 class="results-group-title">MKE Area Custard Shops (${results.length})</h3>`;
      for (const store of results) {
        html += storeCard(store, false);
      }
      html += '</div>';
      resultsBody.innerHTML = html;
      resultsSection.hidden = false;
    });

    // Auto-detect location on load via Cloudflare geolocation, then search
    async function initLocation() {
      try {
        const resp = await fetch(`${WORKER_BASE}/api/geolocate`);
        const geo = await resp.json();
        if (geo.city && geo.state && !locationInput.value) {
          locationInput.value = `${geo.city}, ${geo.state}`;
          doSearch();
        }
      } catch (err) {
        console.debug('Auto-geolocation unavailable:', err);
      }
    }

    // Init
    const params = new URLSearchParams(window.location.search);
    if (params.get('location')) {
      readUrlParams();
    } else {
      initLocation();
    }
  </script>
</body>
</html>
