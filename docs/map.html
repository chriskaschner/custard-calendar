<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custard Map ‚Äî Find a Flavor Near You</title>
  <meta name="description" content="Find today's Flavor of the Day at frozen custard shops near you. Search by location or flavor.">
  <meta property="og:title" content="Custard Map ‚Äî Find a Flavor Near You">
  <meta property="og:description" content="Find today's Flavor of the Day at frozen custard shops near you. Search by location or flavor.">
  <meta property="og:url" content="https://custard.chriskaschner.com/map.html">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://custard.chriskaschner.com/og-map.png">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üç¶</text></svg>">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha384-sHL9NAb7lN7rfvG5lfHpm643Xkcjzp4jFvuavGOndn6pjVqS6ny56CAt3nsEVT4H" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha384-cxOPjt7s7Iz04uaHJceBmS+qpjv2JkIHNVcuOrM+YHwZOmJGBXI00mdUXEq65HTH" crossorigin=""></script>
</head>
<body>
  <header>
    <h1>Custard Map</h1>
    <p>Find today's Flavor of the Day near you.</p>
    <nav class="nav-links">
      <a href="index.html">Forecast</a>
      <a href="calendar.html">Calendar</a>
      <a href="map.html" class="nav-active">Map</a>
      <a href="radar.html">Radar</a>
      <a href="alerts.html">Alerts</a>
      <a href="siri.html">Siri</a>
      <a href="forecast-map.html">Fronts</a>
      <a href="quiz.html">Quiz</a>
      <a href="widget.html">Widget</a>
    </nav>
  </header>

  <main>
    <section id="search-controls">
      <div class="filter-row">
        <div class="filter-group">
          <label for="flavor-input">Flavor (optional)</label>
          <div class="flavor-input-wrap">
            <input type="text" id="flavor-input" placeholder="e.g. Mint Explosion" autocomplete="off">
            <div id="flavor-dropdown" class="flavor-dropdown" hidden></div>
          </div>
        </div>
        <div class="filter-group filter-group-location">
          <label for="location-input">Location</label>
          <div class="location-row">
            <input type="text" id="location-input" placeholder="Zip code or city...">
            <button id="geolocate-btn" title="Use my location" class="icon-btn">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="filter-group filter-group-btn">
          <label>&nbsp;</label>
          <button id="search-btn" class="btn btn-search">Search</button>
        </div>
      </div>
      <div class="brand-chips">
        <button class="brand-chip" data-brand="all">All</button>
        <button class="brand-chip active" data-brand="culvers" style="background:#003366;border-color:transparent">Culver's</button>
        <button class="brand-chip" data-brand="kopps">Kopp's</button>
        <button class="brand-chip" data-brand="gilles">Gille's</button>
        <button class="brand-chip" data-brand="hefners">Hefner's</button>
        <button class="brand-chip" data-brand="kraverz">Kraverz</button>
        <button class="brand-chip" data-brand="oscars">Oscar's</button>
      </div>
      <div class="flavor-family-chips" id="flavor-family-chips" hidden>
        <span class="chips-label">Flavor family:</span>
        <button class="flavor-chip active" data-family="all">All</button>
        <button class="flavor-chip" data-family="mint">Mint</button>
        <button class="flavor-chip" data-family="chocolate">Chocolate</button>
        <button class="flavor-chip" data-family="caramel">Caramel</button>
        <button class="flavor-chip" data-family="cheesecake">Cheesecake</button>
        <button class="flavor-chip" data-family="turtle">Turtle</button>
        <button class="flavor-chip" data-family="cookie">Cookie</button>
        <button class="flavor-chip" data-family="peanut-butter">Peanut Butter</button>
        <button class="flavor-chip" data-family="berry">Berry</button>
        <button class="flavor-chip" data-family="pecan">Pecan</button>
      </div>
    </section>

    <section id="suggestions-panel" hidden>
      <div id="suggestions-content"></div>
    </section>

    <section id="map-container">
      <div id="map"></div>
    </section>

    <section id="results-list" hidden>
      <h2 id="results-heading">Results</h2>
      <div id="results-body"></div>
    </section>
  </main>

  <footer>
    <p>Not affiliated with any restaurant. Flavor data sourced from restaurant websites.</p>
  </footer>

  <script src="planner-shared.js"></script>
  <script>var WORKER_BASE = CustardPlanner.WORKER_BASE;</script>
  <script src="cone-renderer.js"></script>
  <script>
    var BRAND_COLORS = CustardPlanner.BRAND_COLORS;
    var BRAND_DISPLAY = CustardPlanner.BRAND_DISPLAY;

    // flavorColorData and FALLBACK_* constants provided by cone-renderer.js
    const flavorIconCache = new Map();

    // Known flavors for autocomplete ‚Äî seeded from catalog API, static list as fallback
    const KNOWN_FLAVORS_FALLBACK = [
      'Andes Mint Avalanche', 'Blackberry Cobbler', 'Brownie Thunder',
      'Butter Pecan', 'Caramel Cashew', 'Caramel Fudge Cookie Dough',
      'Caramel Pecan', 'Caramel Turtle', 'Chocolate Caramel Twist',
      'Chocolate Heath Crunch', 'Chocolate Oreo Volcano', 'Chocolate Volcano',
      'Crazy for Cookie Dough', 'Dark Chocolate Decadence',
      'Dark Chocolate PB Crunch', 'Georgia Peach Pecan',
      'Lemon Berry Layer Cake', 'Lemon Dash Cookie', 'Mint Cookie',
      'Mint Explosion', 'OREO Cheesecake', 'OREO Cookies and Cream',
      'Peanut Butter Cup', 'Raspberry Cheesecake', 'Really Reese\'s',
      'Salted Caramel Pecan Pie', 'Snickers Swirl',
      'Strawberry Cheesecake', 'Turtle', 'Turtle Cheesecake',
      'Turtle Dove', 'Vanilla',
    ];
    let KNOWN_FLAVORS = KNOWN_FLAVORS_FALLBACK;

    fetch(WORKER_BASE + '/api/flavors/catalog')
      .then(r => r.ok ? r.json() : null)
      .then(data => {
        if (data && Array.isArray(data.flavors) && data.flavors.length > 0) {
          KNOWN_FLAVORS = data.flavors.map(f => f.title).filter(Boolean).sort();
        }
      })
      .catch(() => { /* keep fallback */ });

    // DOM elements
    const flavorInput = document.getElementById('flavor-input');
    const flavorDropdown = document.getElementById('flavor-dropdown');
    const locationInput = document.getElementById('location-input');
    const geolocateBtn = document.getElementById('geolocate-btn');
    const searchBtn = document.getElementById('search-btn');
    const suggestionsPanel = document.getElementById('suggestions-panel');
    const suggestionsContent = document.getElementById('suggestions-content');
    const resultsSection = document.getElementById('results-list');
    const resultsHeading = document.getElementById('results-heading');
    const resultsBody = document.getElementById('results-body');

    // Map setup
    const map = L.map('map').setView([43.0, -89.5], 7); // Default: Wisconsin
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 18,
    }).addTo(map);

    let markers = L.layerGroup().addTo(map);
    let brandStores = []; // loaded from stores.json
    let skipMoveHandler = false; // flag to skip moveend during programmatic fitBounds
    const flavorColorsReady = loadFlavorColors().then(function() { flavorIconCache.clear(); });
    const flavorIntelCache = new Map(); // normalized flavor -> rendered intel HTML
    const storeIntelCache = new Map(); // slug -> rendered specialty HTML

    // Brand chip state
    const BRAND_CHIP_COLORS = { culvers: '#003366', ...BRAND_COLORS };
    const activeBrands = new Set(['culvers']);

    const ALL_BRANDS = ['culvers', 'kopps', 'gilles', 'hefners', 'kraverz', 'oscars'];

    // Flavor family filter data -- sourced from CustardPlanner.
    // map.html uses 'peanut-butter' (kebab) as the chip data attribute; build
    // a local lookup that maps both 'peanutButter' and 'peanut-butter' keys.
    var FLAVOR_FAMILIES = CustardPlanner.FLAVOR_FAMILY_MEMBERS;
    FLAVOR_FAMILIES['peanut-butter'] = FLAVOR_FAMILIES['peanut-butter'] || FLAVOR_FAMILIES.peanutButter;

    // Build reverse lookup: normalized flavor -> set of families
    var flavorToFamilies = {};
    for (var _famKey in FLAVOR_FAMILIES) {
      if (!FLAVOR_FAMILIES.hasOwnProperty(_famKey)) continue;
      var _members = FLAVOR_FAMILIES[_famKey];
      if (!_members) continue;
      for (var _mi = 0; _mi < _members.length; _mi++) {
        var _member = _members[_mi];
        if (!flavorToFamilies[_member]) flavorToFamilies[_member] = [];
        flavorToFamilies[_member].push(_famKey);
      }
    }

    let activeFamily = 'all';
    const familyChipsContainer = document.getElementById('flavor-family-chips');

    var haversine = CustardPlanner.haversineMiles;

    // loadFlavorColors, normalizeFlavorKey, getFlavorProfileLocal, getFlavorBaseColor,
    // resolveToppingSlots, renderMiniConeSVG provided by cone-renderer.js

    function rgbaFromHex(hex, alpha) {
      const normalized = String(hex || '').trim();
      const m = normalized.match(/^#([0-9a-fA-F]{6})$/);
      if (!m) return 'rgba(0, 54, 102, ' + alpha + ')';
      const value = m[1];
      const r = parseInt(value.slice(0, 2), 16);
      const g = parseInt(value.slice(2, 4), 16);
      const b = parseInt(value.slice(4, 6), 16);
      return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
    }

    function iconStateClass(isMatch, hasFlavorFilter) {
      if (isMatch) return 'flavor-map-marker-match';
      if (hasFlavorFilter) return 'flavor-map-marker-filtered';
      return 'flavor-map-marker-default';
    }

    function markerBrandColor(brand) {
      if (!brand || brand === 'culvers') return '#003366';
      return BRAND_COLORS[brand] || '#003366';
    }

    function buildConeMarkerIcon(store, hasFlavorFilter) {
      const flavor = store.flavor || 'Vanilla';
      const accentColor = getFlavorBaseColor(flavor);
      const brandColor = markerBrandColor(store._brand || store.brand);
      const stateClass = iconStateClass(Boolean(store._match), hasFlavorFilter);
      const cacheKey = [
        normalizeFlavorKey(flavor),
        store._brand || store.brand || 'culvers',
        stateClass,
      ].join('|');
      if (flavorIconCache.has(cacheKey)) return flavorIconCache.get(cacheKey);

      const markerGlow = rgbaFromHex(accentColor, 0.5);
      const icon = L.divIcon({
        className: 'flavor-map-marker-wrap',
        iconSize: [48, 60],
        iconAnchor: [24, 58],
        popupAnchor: [0, -52],
        html:
          '<div class="flavor-map-marker ' + stateClass + '" style="--marker-ring:' + brandColor + ';--marker-glow:' + markerGlow + ';">' +
            renderMiniConeSVG(flavor, 4) +
          '</div>',
      });
      flavorIconCache.set(cacheKey, icon);
      return icon;
    }

    function syncChipStyles() {
      document.querySelectorAll('.brand-chip').forEach(chip => {
        const brand = chip.dataset.brand;
        if (brand === 'all') {
          const allActive = ALL_BRANDS.every(b => activeBrands.has(b));
          chip.classList.toggle('active', allActive);
          chip.style.background = allActive ? '#555' : '';
          chip.style.borderColor = allActive ? 'transparent' : '';
        } else {
          const isActive = activeBrands.has(brand);
          chip.classList.toggle('active', isActive);
          chip.style.background = isActive ? (BRAND_CHIP_COLORS[brand] || '') : '';
          chip.style.borderColor = isActive ? 'transparent' : '';
        }
      });
    }

    // Wire up brand chips
    document.querySelectorAll('.brand-chip').forEach(chip => {
      chip.addEventListener('click', () => {
        const brand = chip.dataset.brand;
        if (brand === 'all') {
          const allActive = ALL_BRANDS.every(b => activeBrands.has(b));
          if (allActive) {
            ALL_BRANDS.forEach(b => activeBrands.delete(b));
          } else {
            ALL_BRANDS.forEach(b => activeBrands.add(b));
          }
        } else if (activeBrands.has(brand)) {
          activeBrands.delete(brand);
        } else {
          activeBrands.add(brand);
        }
        syncChipStyles();
        refreshResults();
      });
    });

    // Wire up flavor family chips
    document.querySelectorAll('.flavor-chip').forEach(function(chip) {
      chip.addEventListener('click', function() {
        activeFamily = this.dataset.family;
        document.querySelectorAll('.flavor-chip').forEach(function(c) {
          c.classList.toggle('active', c.dataset.family === activeFamily);
        });
        applyFamilyFilter();
      });
    });

    function storeMatchesFamily(store) {
      if (activeFamily === 'all') return true;
      if (!store.flavor) return false;
      var normalized = CustardPlanner.normalize(store.flavor);
      var families = flavorToFamilies[normalized];
      return families && families.includes(activeFamily);
    }

    function applyFamilyFilter() {
      if (!window._allMarkers) return;

      var visibleCount = 0;
      for (var i = 0; i < window._allMarkers.length; i++) {
        var entry = window._allMarkers[i];
        var matches = storeMatchesFamily(entry.store);
        if (matches) {
          entry.marker.setOpacity(1);
          visibleCount++;
        } else {
          entry.marker.setOpacity(0.15);
        }
      }

      var countEl = document.getElementById('results-count');
      if (countEl && activeFamily !== 'all') {
        countEl.textContent = visibleCount + ' ' + activeFamily + ' stores';
      }
    }

    let cachedSecondaryResults = []; // cached so map moves don't re-fetch
    let cachedSecondaryKey = '';    // tracks which brands are cached

    async function refreshResults(skipFitBounds = false) {
      await flavorColorsReady;

      // Reset flavor family filter on each refresh
      activeFamily = 'all';
      document.querySelectorAll('.flavor-chip').forEach(function(c) {
        c.classList.toggle('active', c.dataset.family === 'all');
      });

      const hasPrimary = activeBrands.has('culvers');
      const secondaryBrands = [...activeBrands].filter(b => b !== 'culvers');

      // If nothing active, just clear
      if (!hasPrimary && secondaryBrands.length === 0) {
        markers.clearLayers();
        resultsSection.hidden = true;
        cachedSecondaryResults = [];
        cachedSecondaryKey = '';
        return;
      }

      // Only re-fetch brands when the active set changes
      const brandKey = secondaryBrands.sort().join(',');
      const needSecondaryFetch = brandKey && brandKey !== cachedSecondaryKey;

      // Kick off Culver's search; only fetch brands if selection changed
      const primaryPromise = hasPrimary && locationInput.value.trim() ? doPrimarySearch() : Promise.resolve(null);
      const brandPromise = needSecondaryFetch ? doBrandSearch(secondaryBrands) : Promise.resolve(null);

      const [primaryData, freshSecondaryResults] = await Promise.all([primaryPromise, brandPromise]);

      if (freshSecondaryResults !== null) {
        cachedSecondaryResults = freshSecondaryResults;
        cachedSecondaryKey = brandKey;
      }
      const brandResults = brandKey ? cachedSecondaryResults : [];

      // Build unified store list with normalized coords + distance
      const center = map.getCenter();
      const allStores = [];
      const matchedSlugs = new Set(); // track flavor-matched Culver's slugs

      if (primaryData) {
        for (const store of primaryData.matches) {
          if (!store.lat || !store.lon) continue;
          matchedSlugs.add(store.slug);
          allStores.push({ ...store, _lat: store.lat, _lon: store.lon, _match: true, _brand: 'culvers',
            _dist: haversine(center.lat, center.lng, store.lat, store.lon) });
        }
        for (const store of primaryData.nearby) {
          if (!store.lat || !store.lon) continue;
          allStores.push({ ...store, _lat: store.lat, _lon: store.lon, _match: false, _brand: 'culvers',
            _dist: haversine(center.lat, center.lng, store.lat, store.lon) });
        }
      }

      const flavorQuery = flavorInput.value.trim().toLowerCase();
      for (const store of brandResults) {
        const lat = store.lat;
        const lon = store.lng || store.lon;
        if (!lat || !lon) continue;
        const brandFlavorMatch = flavorQuery && store.flavor &&
          store.flavor.toLowerCase().includes(flavorQuery);
        allStores.push({ ...store, _lat: lat, _lon: lon, _match: brandFlavorMatch, _brand: store.brand,
          _dist: haversine(center.lat, center.lng, lat, lon) });
      }

      // On map-move refreshes, preserve existing markers/results if lookup
      // yields no stores (common when reverse-geocode/API is transiently limited).
      if (skipFitBounds && allStores.length === 0) {
        return;
      }

      // Markers + bounds
      markers.clearLayers();
      window._allMarkers = [];
      const allBounds = L.latLngBounds();
      const hasFlavorFilter = primaryData ? !!primaryData.query.flavor : !!flavorQuery;

      for (const store of allStores) {
        allBounds.extend([store._lat, store._lon]);
        const icon = buildConeMarkerIcon(store, hasFlavorFilter);
        const marker = L.marker([store._lat, store._lon], { icon }).bindPopup(storePopup(store, store._match));
        marker.on('popupopen', () => {
          CustardPlanner.emitInteractionEvent({
            event_type: 'popup_open',
            action: 'store_popup',
            store_slug: store.slug || null,
            flavor: store.flavor || null,
            certainty_tier: store.flavor ? 'confirmed' : 'none',
          });
          if (store.flavor) enrichPopupIntel(marker, store.flavor, store.slug || null);
          if (store.slug) enrichPopupStoreSpecialty(marker, store.slug);
        });
        markers.addLayer(marker);
        window._allMarkers.push({ store: store, marker: marker });
      }

      // Suggestions
      if (primaryData && hasFlavorFilter && primaryData.matches.length === 0 && primaryData.suggestions.length > 0) {
        renderSuggestions(primaryData);
      } else {
        suggestionsPanel.hidden = true;
      }

      // Easter egg quip: no Culver's active, brands only, MKE area stores present
      let quipHtml = '';
      if (!hasPrimary && brandResults.length > 0) {
        const hasMKEStores = brandResults.some(s =>
          s.lat > 42.8 && s.lat < 43.3 && (s.lng || s.lon) > -88.2 && (s.lng || s.lon) < -87.7
        );
        if (hasMKEStores) {
          const quips = [
            "Oh sure, skip the ButterBurgers, that'll end well.",
            "Oh, too good for Culver's now, are we?",
            "Ope, found the custard hipster.",
            "You can take the kid outta Culver's, but you can't take the Culver's outta the kid.",
            "Your aunt from Waukesha is very disappointed you skipped Culver's.",
            "You're just going to scootch past Culver's?!?!",
            "You probably left a sticker on the Minnow, didn't you.",
            "Summerfest is 11 days a year. Custard snobbery is forever.",
            "Bucks in 6. Custard shops in... well, fewer than 6.",
            "It's not an ocean, and Culver's isn't just ice cream. We've been over this.",
            "Da Crusher didn't body-slam his way through South Milwaukee for you to skip Culver's.",
            "The ghost of Frederick Pabst didn't brew all that beer for you to get picky about custard.",
            "You'll swim in 52-degree lake water but draw the line at ButterBurgers?",
            "You can handle Real Chili at 1 a.m. but not Culver's?",
            "You think the Minnow stranded itself for nothing?",
          ];
          quipHtml = `<p style="font-style:italic;color:#888;text-align:center;margin:0.5rem 0">${quips[Math.floor(Math.random() * quips.length)]}</p>`;
        }
      }

      // Build result cards ‚Äî unified list sorted by distance
      const flavorName = primaryData ? primaryData.query.flavor : flavorInput.value.trim();
      let html = '';
      if (hasFlavorFilter) {
        const matches = allStores.filter(s => s._match).sort((a, b) => a._dist - b._dist);
        const rest = allStores.filter(s => !s._match).sort((a, b) => a._dist - b._dist);

        if (matches.length > 0) {
          html += `<div class="results-group"><h3 class="results-group-title match-title">Stores with ${escapeHtml(flavorName)} (${matches.length})</h3>`;
          for (const store of matches) html += storeCard(store, true);
          html += '</div>';
        }
        if (rest.length > 0) {
          let nearbyLabel;
          if (matches.length > 0) {
            const altIntros = [
              'Meanwhile, nearby',
              'Not your flavor? These stores beg to differ',
              'Other scoops in the neighborhood',
              'The rest of the cone-petition',
              'What the other stores are dishing out',
              'In other frozen news',
              'But wait, there\'s more custard',
              'The supporting cast',
            ];
            nearbyLabel = altIntros[Math.floor(Math.random() * altIntros.length)];
          } else {
            const nearbyIntros = [
              `No ${escapeHtml(flavorName)} nearby ‚Äî here's what's scooping instead`,
              `${escapeHtml(flavorName)}? Not today. But check out what is`,
              `Fresh out of ${escapeHtml(flavorName)} ‚Äî but never fresh out of options`,
              `The custard must flow ‚Äî just not ${escapeHtml(flavorName)} right now`,
              `${escapeHtml(flavorName)} is playing hard to get. These aren't`,
              `No ${escapeHtml(flavorName)}? That's the way the cookie crumbles. Here's what's left`,
              `We all scream for ${escapeHtml(flavorName)} but today we settle`,
              `Life gave you no ${escapeHtml(flavorName)}. Make custard-ade`,
            ];
            nearbyLabel = nearbyIntros[Math.floor(Math.random() * nearbyIntros.length)];
          }
          html += `<div class="results-group">${quipHtml}<h3 class="results-group-title">${nearbyLabel}</h3>`;
          for (const store of rest) html += storeCard(store, false);
          html += '</div>';
        }
      } else {
        // No flavor filter ‚Äî single flat list sorted by distance
        allStores.sort((a, b) => a._dist - b._dist);
        const total = allStores.length;
        html += `<div class="results-group">${quipHtml}<h3 class="results-group-title">Results (${total})</h3>`;
        for (const store of allStores) html += storeCard(store, false);
        html += '</div>';
      }

      // fitBounds: only on explicit searches (not map moves)
      if (!skipFitBounds && allBounds.isValid()) {
        skipMoveHandler = true;
        map.fitBounds(allBounds, { padding: [30, 30], maxZoom: 12 });
      }

      resultsBody.innerHTML = html || '<div class="no-results">No results.</div>';
      resultsSection.hidden = false;

      // Show flavor family chips once we have results
      if (allStores.length > 0) {
        familyChipsContainer.hidden = false;
      }
    }

    // Fetch primary brand data via locator API (returns API response or null)
    async function doPrimarySearch() {
      const location = locationInput.value.trim();
      if (!location) return null;
      const flavor = flavorInput.value.trim();
      let url = `${WORKER_BASE}/api/v1/nearby-flavors?location=${encodeURIComponent(location)}`;
      if (flavor) url += `&flavor=${encodeURIComponent(flavor)}`;
      try {
        const resp = await fetch(url);
        if (!resp.ok) return null;
        return await resp.json();
      } catch { return null; }
    }

    // Fetch brand stores + their flavors
    async function doBrandSearch(brands) {
      const stores = await loadBrandStores();
      const filtered = stores.filter(s => brands.includes(s.brand));
      if (filtered.length === 0) return [];

      const results = await Promise.all(filtered.map(async (store) => {
        try {
          const resp = await fetch(`${WORKER_BASE}/api/v1/flavors?slug=${encodeURIComponent(store.slug)}`);
          if (!resp.ok) return { ...store, flavor: 'Unavailable' };
          const data = await resp.json();
          const today = new Date().toISOString().slice(0, 10);
          const todayFlavor = (data.flavors || []).find(f => f.date === today);
          const fl = todayFlavor || (data.flavors && data.flavors[0]);
          return { ...store, flavor: fl ? (fl.title || fl.flavor || 'Unavailable') : 'Unavailable', description: fl ? (fl.description || '') : '' };
        } catch {
          return { ...store, flavor: 'Unavailable' };
        }
      }));
      return results;
    }

    // Flavor keywords for matching ingredients not in the name
    const FLAVOR_KEYWORDS = {
      'Mint Explosion': 'oreo cookie chocolate fudge',
      'Brownie Thunder': 'brownie chocolate caramel',
      'Crazy for Cookie Dough': 'chocolate chip vanilla',
      'Dark Chocolate Decadence': 'cocoa fudge',
      'Dark Chocolate PB Crunch': 'peanut butter reeses',
      'Really Reese\'s': 'peanut butter chocolate reeses',
      'Snickers Swirl': 'peanut caramel nougat chocolate',
      'Turtle': 'caramel pecan chocolate fudge',
      'Turtle Cheesecake': 'caramel pecan chocolate cheesecake',
      'Turtle Dove': 'caramel pecan chocolate dove',
    };

    // Custom flavor dropdown autocomplete
    function showFlavorDropdown() {
      const query = flavorInput.value.trim().toLowerCase();
      if (!query) { flavorDropdown.hidden = true; return; }
      const matches = KNOWN_FLAVORS.filter(f =>
        f.toLowerCase().includes(query) ||
        (FLAVOR_KEYWORDS[f] && FLAVOR_KEYWORDS[f].includes(query))
      );
      if (matches.length === 0) { flavorDropdown.hidden = true; return; }
      flavorDropdown.innerHTML = matches.map(f =>
        `<div class="flavor-option">${escapeHtml(f)}</div>`
      ).join('');
      flavorDropdown.hidden = false;
    }

    flavorInput.addEventListener('input', showFlavorDropdown);

    flavorInput.addEventListener('focus', () => {
      if (flavorInput.value.trim()) showFlavorDropdown();
    });

    flavorDropdown.addEventListener('click', (e) => {
      const opt = e.target.closest('.flavor-option');
      if (!opt) return;
      flavorInput.value = opt.textContent;
      flavorDropdown.hidden = true;
    });

    document.addEventListener('click', (e) => {
      if (!flavorInput.contains(e.target) && !flavorDropdown.contains(e.target)) {
        flavorDropdown.hidden = true;
      }
    });

    // Read URL params on load
    function readUrlParams() {
      const params = new URLSearchParams(window.location.search);
      if (params.get('flavor')) flavorInput.value = params.get('flavor');
      if (params.get('location')) locationInput.value = params.get('location');
      if (params.get('location')) doSearch();
    }

    // Update URL without reload
    function updateUrl() {
      const params = new URLSearchParams();
      if (flavorInput.value.trim()) params.set('flavor', flavorInput.value.trim());
      if (locationInput.value.trim()) params.set('location', locationInput.value.trim());
      const qs = params.toString();
      const newUrl = qs ? `${window.location.pathname}?${qs}` : window.location.pathname;
      history.replaceState(null, '', newUrl);
    }

    // Geolocation
    geolocateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        return;
      }
      geolocateBtn.disabled = true;
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          locationInput.value = `${pos.coords.latitude.toFixed(4)},${pos.coords.longitude.toFixed(4)}`;
          geolocateBtn.disabled = false;
          doSearch();
        },
        (err) => {
          geolocateBtn.disabled = false;
          // Fall back to IP-based geolocation
          autoGeolocate();
        },
        { timeout: 5000 }
      );
    });

    async function autoGeolocate() {
      try {
        const resp = await fetch(`${WORKER_BASE}/api/v1/geolocate`);
        const geo = await resp.json();
        if (geo.city && geo.state) {
          locationInput.value = `${geo.city}, ${geo.state}`;
          doSearch();
        }
      } catch (err) {
        console.debug('Geolocation unavailable:', err);
      }
    }

    // Search ‚Äî always include Culver's when user explicitly searches
    searchBtn.addEventListener('click', () => {
      if (!activeBrands.has('culvers')) {
        activeBrands.add('culvers');
        syncChipStyles();
      }
      doSearch();
    });
    locationInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (!activeBrands.has('culvers')) { activeBrands.add('culvers'); syncChipStyles(); }
        doSearch();
      }
    });
    flavorInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (!activeBrands.has('culvers')) { activeBrands.add('culvers'); syncChipStyles(); }
        doSearch();
      }
    });

    // Reverse geocode coords to city/state (Culver's API doesn't accept raw lat,lon)
    async function reverseGeocode(lat, lng) {
      try {
        const resp = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&zoom=10`);
        const data = await resp.json();
        const addr = data.address || {};
        const city = addr.city || addr.town || addr.village || addr.county || '';
        const state = addr.state || '';
        return city && state ? `${city}, ${state}` : city || `${lat.toFixed(4)},${lng.toFixed(4)}`;
      } catch {
        return `${lat.toFixed(4)},${lng.toFixed(4)}`;
      }
    }

    function isCoordinateLocation(value) {
      return /^-?\d+(\.\d+)?\s*,\s*-?\d+(\.\d+)?$/.test(String(value || '').trim());
    }

    // Debounced map move handler for dynamic search
    let moveTimer = null;
    map.on('moveend', () => {
      if (skipMoveHandler) { skipMoveHandler = false; return; }
      if (!activeBrands.has('culvers')) return;
      clearTimeout(moveTimer);
      moveTimer = setTimeout(async () => {
        const center = map.getCenter();
        const placeName = await reverseGeocode(center.lat, center.lng);
        if (!placeName || isCoordinateLocation(placeName)) return;
        locationInput.value = placeName;
        doSearch(true);
      }, 300);
    });

    async function doSearch(fromMapMove = false) {
      const location = locationInput.value.trim();
      if (!location && activeBrands.has('culvers')) {
        locationInput.focus();
        return;
      }
      updateUrl();
      searchBtn.disabled = true;
      searchBtn.textContent = 'Searching...';
      await refreshResults(fromMapMove);
      searchBtn.disabled = false;
      searchBtn.textContent = 'Search';
    }

    function renderSuggestions(data) {
      const intros = [
        'You could broaden your horizons and try',
        'How about something a little different?',
        'What about something out of left field?',
        'Might I interest you in',
        'Live a little ‚Äî go for',
        'Plot twist:',
        'Hear me out ‚Äî',
        'The universe is telling you to try',
        'Your taste buds called, they want',
        'Bold move incoming:',
        'Cone-sider trying',
        'Don\'t have a meltdown ‚Äî try',
        'Sundae funday alternative:',
        'This one\'s the real scoop:',
        'Spoon-worthy option:',
        'Worth the brain freeze:',
      ];
      const shuffled = intros.sort(() => Math.random() - 0.5);
      const lines = data.suggestions.map((s, i) => {
        const intro = shuffled[i % shuffled.length];
        const link = `<button class="suggestion-link" data-flavor="${escapeAttr(s.flavor)}">${escapeHtml(s.flavor)}</button>`;
        const count = `(${s.count} store${s.count > 1 ? 's' : ''})`;
        return `${intro} ${link} ${count}`;
      });
      suggestionsContent.innerHTML = `<strong>No ${escapeHtml(data.query.flavor)} today.</strong><br>${lines.join('<br>')}`;
      suggestionsPanel.hidden = false;
      suggestionsPanel.querySelectorAll('.suggestion-link').forEach(btn => {
        btn.addEventListener('click', () => {
          flavorInput.value = btn.dataset.flavor;
          doSearch();
        });
      });
    }

    function rarityChipClass(tier) {
      if (!tier) return '';
      const map = {
        'Ultra Rare': 'rarity-ultra-rare',
        'Rare': 'rarity-rare',
        'Uncommon': 'rarity-uncommon',
        'Common': 'rarity-common',
        'Staple': 'rarity-staple',
      };
      return map[tier] || '';
    }

    function buildPopupIntelHTML(data) {
      if (!data || !data.found || !data.flavor) return '';
      const tier = CustardPlanner.rarityLabelFromRank(data.rank, data.total_ranked_flavors);
      const peak = data.flavor.peak_month_name || null;
      const parts = [];
      if (tier) {
        const cls = rarityChipClass(tier);
        parts.push(`<span class="popup-rarity-chip ${escapeHtml(cls)}">${escapeHtml(tier)}</span>`);
      }
      if (peak) parts.push(`Peak: ${escapeHtml(peak)}`);
      return parts.join('');
    }

    function injectPopupIntel(marker, html, slug, flavorName) {
      const popup = marker.getPopup && marker.getPopup();
      if (!popup) return;
      const el = popup.getElement && popup.getElement();
      if (!el) return;
      const placeholder = el.querySelector('.popup-intel');
      if (placeholder) {
        placeholder.innerHTML = html;
        if (html && slug) {
          CustardPlanner.emitInteractionEvent({
            event_type: 'popup_open',
            action: 'rarity_shown',
            store_slug: slug,
            flavor: flavorName || null,
          });
        }
      }
    }

    async function enrichPopupIntel(marker, flavorName, slug) {
      const key = normalizeFlavorKey(flavorName);
      if (flavorIntelCache.has(key)) {
        injectPopupIntel(marker, flavorIntelCache.get(key), slug, flavorName);
        return;
      }
      try {
        const resp = await fetch(`${WORKER_BASE}/api/v1/metrics/context/flavor/${encodeURIComponent(flavorName)}`);
        if (!resp.ok) return;
        const data = await resp.json();
        const html = buildPopupIntelHTML(data);
        flavorIntelCache.set(key, html);
        injectPopupIntel(marker, html, slug, flavorName);
      } catch (_) {}
    }

    function buildStoreSpecialtyHTML(specialty) {
      if (!specialty || specialty.ratio < 1.2) return '';
      return '<span class="popup-specialty">Store specialty: ' + escapeHtml(specialty.title) + '</span>';
    }

    function injectPopupSpecialty(marker, html, slug) {
      const popup = marker.getPopup && marker.getPopup();
      if (!popup) return;
      const el = popup.getElement && popup.getElement();
      if (!el) return;
      const slot = el.querySelector('.popup-specialty-slot');
      if (slot) {
        slot.innerHTML = html;
        if (html && slug) {
          CustardPlanner.emitInteractionEvent({
            event_type: 'popup_open',
            action: 'specialty_shown',
            store_slug: slug,
          });
        }
      }
    }

    async function enrichPopupStoreSpecialty(marker, slug) {
      if (storeIntelCache.has(slug)) {
        injectPopupSpecialty(marker, storeIntelCache.get(slug), slug);
        return;
      }
      try {
        var resp = await fetch(WORKER_BASE + '/api/v1/metrics/context/store/' + encodeURIComponent(slug));
        if (!resp.ok) return;
        var data = await resp.json();
        var html = data.specialty_flavor ? buildStoreSpecialtyHTML(data.specialty_flavor) : '';
        storeIntelCache.set(slug, html);
        injectPopupSpecialty(marker, html, slug);
      } catch (_) {}
    }

    function storePopup(store, isMatch) {
      const matchBadge = isMatch ? ' <span class="popup-match">MATCH</span>' : '';
      const certBadge = store.flavor ? ' <span class="popup-confirmed">Confirmed</span>' : '';
      const desc = store.description ? `<br><small>${escapeHtml(store.description)}</small>` : '';
      const nameColor = store.brand && BRAND_COLORS[store.brand] ? ` style="color:${BRAND_COLORS[store.brand]}"` : '';
      const lat = Number(store.lat);
      const lon = Number(store.lon || store.lng);
      const ctas = store.flavor ? CustardPlanner.actionCTAsHTML({
        slug: store.slug,
        storeName: store.name,
        lat: Number.isFinite(lat) ? lat : null,
        lon: Number.isFinite(lon) ? lon : null,
        workerBase: WORKER_BASE,
        actions: ['directions', 'alert', 'calendar'],
      }) : '';
      const intelPlaceholder = store.flavor ? '<div class="popup-intel"></div><div class="popup-specialty-slot"></div>' : '';
      return `<div class="store-popup">
        <strong${nameColor}>${escapeHtml(store.name)}</strong>${matchBadge}${certBadge}<br>
        ${escapeHtml(store.address)}<br>
        <em>${escapeHtml(store.flavor || 'No flavor data')}</em>${desc}
        ${intelPlaceholder}
        ${ctas}
      </div>`;
    }

    function brandClass(store) {
      if (store.brand && BRAND_COLORS[store.brand]) return ` brand-${store.brand}`;
      return '';
    }

    function storeCard(store, isMatch) {
      const matchClass = isMatch ? ' store-card-match' : (store.brand ? brandClass(store) : ' brand-culvers');
      const nameColor = store.brand && BRAND_COLORS[store.brand] ? ` style="color:${BRAND_COLORS[store.brand]}"` : '';
      const desc = store.description ? `<div class="store-card-description">${escapeHtml(store.description)}</div>` : '';
      const distHtml = store._dist != null ? `<span class="store-card-rank">${store._dist.toFixed(1)} mi</span>` : '';
      const lat = Number(store.lat);
      const lon = Number(store.lon || store.lng);
      const ctas = store.flavor ? CustardPlanner.actionCTAsHTML({
        slug: store.slug,
        storeName: store.name,
        lat: Number.isFinite(lat) ? lat : null,
        lon: Number.isFinite(lon) ? lon : null,
        workerBase: WORKER_BASE,
        actions: ['directions', 'alert', 'calendar'],
      }) : '';
      return `<div class="store-card${matchClass}">
        <div class="store-card-header">
          <span class="store-card-name"${nameColor}>${escapeHtml(store.name)}</span>
          ${distHtml}
        </div>
        <div class="store-card-address">${escapeHtml(store.address || '')}</div>
        <div class="store-card-flavor">${escapeHtml(store.flavor || 'Loading...')}</div>
        ${desc}
        ${ctas}
      </div>`;
    }

    var escapeHtml = CustardPlanner.escapeHtml;

    function escapeAttr(str) {
      return escapeHtml(str);
    }

    // Load brand stores from stores.json
    async function loadBrandStores() {
      if (brandStores.length > 0) return brandStores;
      try {
        const resp = await fetch('stores.json?v=' + new Date().toISOString().slice(0, 10));
        const data = await resp.json();
        brandStores = (data.stores || []).filter(s => s.brand);
      } catch (err) {
        console.error('Failed to load brand stores:', err);
      }
      return brandStores;
    }

    // Auto-detect location on load via Cloudflare geolocation, then search
    async function initLocation() {
      try {
        const resp = await fetch(`${WORKER_BASE}/api/v1/geolocate`);
        const geo = await resp.json();
        if (geo.city && geo.state && !locationInput.value) {
          locationInput.value = `${geo.city}, ${geo.state}`;
          doSearch();
        }
      } catch (err) {
        console.debug('Auto-geolocation unavailable:', err);
      }
    }

    // Init
    const params = new URLSearchParams(window.location.search);
    if (params.get('location')) {
      readUrlParams();
    } else {
      initLocation();
    }
  </script>
</body>
</html>
