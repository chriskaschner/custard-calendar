<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custard Map ‚Äî Find a Flavor Near You</title>
  <meta name="description" content="Find today's Flavor of the Day at frozen custard shops near you. Search by location or flavor.">
  <meta property="og:title" content="Custard Map ‚Äî Find a Flavor Near You">
  <meta property="og:description" content="Find today's Flavor of the Day at frozen custard shops near you. Search by location or flavor.">
  <meta property="og:url" content="https://custard.chriskaschner.com/map.html">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://custard.chriskaschner.com/og-map.png">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üç¶</text></svg>">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
</head>
<body>
  <header>
    <h1>Custard Map</h1>
    <p>Find a Culver's Flavor of the Day near you.</p>
    <nav class="nav-links">
      <a href="index.html">Calendar</a>
      <a href="alerts.html">Alerts</a>
    </nav>
  </header>

  <main>
    <section id="search-controls">
      <div class="filter-row">
        <div class="filter-group">
          <label for="flavor-input">Flavor (optional)</label>
          <div class="flavor-input-wrap">
            <input type="text" id="flavor-input" placeholder="e.g. Mint Explosion" autocomplete="off">
            <div id="flavor-dropdown" class="flavor-dropdown" hidden></div>
          </div>
        </div>
        <div class="filter-group filter-group-location">
          <label for="location-input">Location</label>
          <div class="location-row">
            <input type="text" id="location-input" placeholder="Zip code or city...">
            <button id="geolocate-btn" title="Use my location" class="icon-btn">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="filter-group filter-group-btn">
          <label>&nbsp;</label>
          <button id="search-btn" class="btn btn-search">Search</button>
        </div>
      </div>
      <div class="brand-chips">
        <button class="brand-chip" data-brand="all">All</button>
        <button class="brand-chip active" data-brand="culvers" style="background:#003366;border-color:transparent">Culver's</button>
        <button class="brand-chip" data-brand="kopps">Kopp's</button>
        <button class="brand-chip" data-brand="gilles">Gille's</button>
        <button class="brand-chip" data-brand="hefners">Hefner's</button>
        <button class="brand-chip" data-brand="kraverz">Kraverz</button>
        <button class="brand-chip" data-brand="oscars">Oscar's</button>
      </div>
    </section>

    <section id="suggestions-panel" hidden>
      <div id="suggestions-content"></div>
    </section>

    <section id="map-container">
      <div id="map"></div>
    </section>

    <section id="results-list" hidden>
      <h2 id="results-heading">Results</h2>
      <div id="results-body"></div>
    </section>
  </main>

  <footer>
    <p>Not affiliated with Culver's. Data sourced from <a href="https://www.culvers.com" target="_blank" rel="noopener">culvers.com</a>.</p>
  </footer>

  <script>
    const WORKER_BASE = 'https://custard-calendar.chris-kaschner.workers.dev';

    const BRAND_COLORS = {
      kopps: '#000000',
      gilles: '#EBCC35',
      hefners: '#93BE46',
      kraverz: '#CE742D',
      oscars: '#BC272C',
    };

    const BRAND_DISPLAY = {
      kopps: "Kopp's",
      gilles: "Gille's",
      hefners: "Hefner's",
      kraverz: "Kraverz",
      oscars: "Oscar's",
    };

    // Known flavors for autocomplete
    const KNOWN_FLAVORS = [
      'Andes Mint Avalanche', 'Blackberry Cobbler', 'Brownie Thunder',
      'Butter Pecan', 'Caramel Cashew', 'Caramel Fudge Cookie Dough',
      'Caramel Pecan', 'Caramel Turtle', 'Chocolate Caramel Twist',
      'Chocolate Heath Crunch', 'Chocolate Oreo Volcano', 'Chocolate Volcano',
      'Crazy for Cookie Dough', 'Dark Chocolate Decadence',
      'Dark Chocolate PB Crunch', 'Georgia Peach Pecan',
      'Lemon Berry Layer Cake', 'Lemon Dash Cookie', 'Mint Cookie',
      'Mint Explosion', 'OREO Cheesecake', 'OREO Cookies and Cream',
      'Peanut Butter Cup', 'Raspberry Cheesecake', 'Really Reese\'s',
      'Salted Caramel Pecan Pie', 'Snickers Swirl',
      'Strawberry Cheesecake', 'Turtle', 'Turtle Cheesecake',
      'Turtle Dove', 'Vanilla',
    ];

    // DOM elements
    const flavorInput = document.getElementById('flavor-input');
    const flavorDropdown = document.getElementById('flavor-dropdown');
    const locationInput = document.getElementById('location-input');
    const geolocateBtn = document.getElementById('geolocate-btn');
    const searchBtn = document.getElementById('search-btn');
    const suggestionsPanel = document.getElementById('suggestions-panel');
    const suggestionsContent = document.getElementById('suggestions-content');
    const resultsSection = document.getElementById('results-list');
    const resultsHeading = document.getElementById('results-heading');
    const resultsBody = document.getElementById('results-body');

    // Map setup
    const map = L.map('map').setView([43.0, -89.5], 7); // Default: Wisconsin
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 18,
    }).addTo(map);

    let markers = L.layerGroup().addTo(map);
    let brandStores = []; // loaded from stores.json
    let skipMoveHandler = false; // flag to skip moveend during programmatic fitBounds

    // Brand chip state
    const BRAND_CHIP_COLORS = { culvers: '#003366', ...BRAND_COLORS };
    const activeBrands = new Set(['culvers']);

    const ALL_BRANDS = ['culvers', 'kopps', 'gilles', 'hefners', 'kraverz', 'oscars'];

    // Haversine distance in miles between two coordinate pairs
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 3958.8; // Earth radius in miles
      const toRad = d => d * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function syncChipStyles() {
      document.querySelectorAll('.brand-chip').forEach(chip => {
        const brand = chip.dataset.brand;
        if (brand === 'all') {
          const allActive = ALL_BRANDS.every(b => activeBrands.has(b));
          chip.classList.toggle('active', allActive);
          chip.style.background = allActive ? '#555' : '';
          chip.style.borderColor = allActive ? 'transparent' : '';
        } else {
          const isActive = activeBrands.has(brand);
          chip.classList.toggle('active', isActive);
          chip.style.background = isActive ? (BRAND_CHIP_COLORS[brand] || '') : '';
          chip.style.borderColor = isActive ? 'transparent' : '';
        }
      });
    }

    // Wire up brand chips
    document.querySelectorAll('.brand-chip').forEach(chip => {
      chip.addEventListener('click', () => {
        const brand = chip.dataset.brand;
        if (brand === 'all') {
          const allActive = ALL_BRANDS.every(b => activeBrands.has(b));
          if (allActive) {
            ALL_BRANDS.forEach(b => activeBrands.delete(b));
          } else {
            ALL_BRANDS.forEach(b => activeBrands.add(b));
          }
        } else if (activeBrands.has(brand)) {
          activeBrands.delete(brand);
        } else {
          activeBrands.add(brand);
        }
        syncChipStyles();
        refreshResults();
      });
    });

    let cachedSecondaryResults = []; // cached so map moves don't re-fetch
    let cachedSecondaryKey = '';    // tracks which brands are cached

    async function refreshResults(skipFitBounds = false) {
      const hasPrimary = activeBrands.has('culvers');
      const secondaryBrands = [...activeBrands].filter(b => b !== 'culvers');

      // If nothing active, just clear
      if (!hasPrimary && secondaryBrands.length === 0) {
        markers.clearLayers();
        resultsSection.hidden = true;
        cachedSecondaryResults = [];
        cachedSecondaryKey = '';
        return;
      }

      // Only re-fetch brands when the active set changes
      const brandKey = secondaryBrands.sort().join(',');
      const needSecondaryFetch = brandKey && brandKey !== cachedSecondaryKey;

      // Kick off Culver's search; only fetch brands if selection changed
      const primaryPromise = hasPrimary && locationInput.value.trim() ? doPrimarySearch() : Promise.resolve(null);
      const brandPromise = needSecondaryFetch ? doBrandSearch(secondaryBrands) : Promise.resolve(null);

      const [primaryData, freshSecondaryResults] = await Promise.all([primaryPromise, brandPromise]);

      if (freshSecondaryResults !== null) {
        cachedSecondaryResults = freshSecondaryResults;
        cachedSecondaryKey = brandKey;
      }
      const brandResults = brandKey ? cachedSecondaryResults : [];

      // Build unified store list with normalized coords + distance
      const center = map.getCenter();
      const allStores = [];
      const matchedSlugs = new Set(); // track flavor-matched Culver's slugs

      if (primaryData) {
        for (const store of primaryData.matches) {
          if (!store.lat || !store.lon) continue;
          matchedSlugs.add(store.slug);
          allStores.push({ ...store, _lat: store.lat, _lon: store.lon, _match: true, _brand: 'culvers',
            _dist: haversine(center.lat, center.lng, store.lat, store.lon) });
        }
        for (const store of primaryData.nearby) {
          if (!store.lat || !store.lon) continue;
          allStores.push({ ...store, _lat: store.lat, _lon: store.lon, _match: false, _brand: 'culvers',
            _dist: haversine(center.lat, center.lng, store.lat, store.lon) });
        }
      }

      const flavorQuery = flavorInput.value.trim().toLowerCase();
      for (const store of brandResults) {
        const lat = store.lat;
        const lon = store.lng || store.lon;
        if (!lat || !lon) continue;
        const brandFlavorMatch = flavorQuery && store.flavor &&
          store.flavor.toLowerCase().includes(flavorQuery);
        allStores.push({ ...store, _lat: lat, _lon: lon, _match: brandFlavorMatch, _brand: store.brand,
          _dist: haversine(center.lat, center.lng, lat, lon) });
      }

      // Markers + bounds
      markers.clearLayers();
      const allBounds = L.latLngBounds();
      const hasFlavorFilter = primaryData ? !!primaryData.query.flavor : !!flavorQuery;

      for (const store of allStores) {
        allBounds.extend([store._lat, store._lon]);
        if (store._brand === 'culvers') {
          const icon = store._match ? greenIcon : (hasFlavorFilter ? blueIcon : defaultIcon);
          const marker = L.marker([store._lat, store._lon], { icon }).bindPopup(storePopup(store, store._match));
          markers.addLayer(marker);
        } else {
          const color = BRAND_COLORS[store._brand] || '#003366';
          const marker = L.circleMarker([store._lat, store._lon], {
            radius: 10, fillColor: color, color: '#fff', weight: 2, fillOpacity: 0.9,
          }).bindPopup(storePopup(store, store._match));
          markers.addLayer(marker);
        }
      }

      // Suggestions
      if (primaryData && hasFlavorFilter && primaryData.matches.length === 0 && primaryData.suggestions.length > 0) {
        renderSuggestions(primaryData);
      } else {
        suggestionsPanel.hidden = true;
      }

      // Easter egg quip: no Culver's active, brands only, MKE area stores present
      let quipHtml = '';
      if (!hasPrimary && brandResults.length > 0) {
        const hasMKEStores = brandResults.some(s =>
          s.lat > 42.8 && s.lat < 43.3 && (s.lng || s.lon) > -88.2 && (s.lng || s.lon) < -87.7
        );
        if (hasMKEStores) {
          const quips = [
            "Oh sure, skip the ButterBurgers, that'll end well.",
            "Oh, too good for Culver's now, are we?",
            "Ope, found the custard hipster.",
            "You can take the kid outta Culver's, but you can't take the Culver's outta the kid.",
            "Your aunt from Waukesha is very disappointed you skipped Culver's.",
            "You're just going to scootch past Culver's?!?!",
            "You probably left a sticker on the Minnow, didn't you.",
            "Summerfest is 11 days a year. Custard snobbery is forever.",
            "Bucks in 6. Custard shops in... well, fewer than 6.",
            "It's not an ocean, and Culver's isn't just ice cream. We've been over this.",
            "Da Crusher didn't body-slam his way through South Milwaukee for you to skip Culver's.",
            "The ghost of Frederick Pabst didn't brew all that beer for you to get picky about custard.",
            "You'll swim in 52-degree lake water but draw the line at ButterBurgers?",
            "You can handle Real Chili at 1 a.m. but not Culver's?",
            "You think the Minnow stranded itself for nothing?",
          ];
          quipHtml = `<p style="font-style:italic;color:#888;text-align:center;margin:0.5rem 0">${quips[Math.floor(Math.random() * quips.length)]}</p>`;
        }
      }

      // Build result cards ‚Äî unified list sorted by distance
      const flavorName = primaryData ? primaryData.query.flavor : flavorInput.value.trim();
      let html = '';
      if (hasFlavorFilter) {
        const matches = allStores.filter(s => s._match).sort((a, b) => a._dist - b._dist);
        const rest = allStores.filter(s => !s._match).sort((a, b) => a._dist - b._dist);

        if (matches.length > 0) {
          html += `<div class="results-group"><h3 class="results-group-title match-title">Stores with ${escapeHtml(flavorName)} (${matches.length})</h3>`;
          for (const store of matches) html += storeCard(store, true);
          html += '</div>';
        }
        if (rest.length > 0) {
          let nearbyLabel;
          if (matches.length > 0) {
            const altIntros = [
              'Meanwhile, nearby',
              'Not your flavor? These stores beg to differ',
              'Other scoops in the neighborhood',
              'The rest of the cone-petition',
              'What the other stores are dishing out',
              'In other frozen news',
              'But wait, there\'s more custard',
              'The supporting cast',
            ];
            nearbyLabel = altIntros[Math.floor(Math.random() * altIntros.length)];
          } else {
            const nearbyIntros = [
              `No ${escapeHtml(flavorName)} nearby ‚Äî here's what's scooping instead`,
              `${escapeHtml(flavorName)}? Not today. But check out what is`,
              `Fresh out of ${escapeHtml(flavorName)} ‚Äî but never fresh out of options`,
              `The custard must flow ‚Äî just not ${escapeHtml(flavorName)} right now`,
              `${escapeHtml(flavorName)} is playing hard to get. These aren't`,
              `No ${escapeHtml(flavorName)}? That's the way the cookie crumbles. Here's what's left`,
              `We all scream for ${escapeHtml(flavorName)} but today we settle`,
              `Life gave you no ${escapeHtml(flavorName)}. Make custard-ade`,
            ];
            nearbyLabel = nearbyIntros[Math.floor(Math.random() * nearbyIntros.length)];
          }
          html += `<div class="results-group">${quipHtml}<h3 class="results-group-title">${nearbyLabel}</h3>`;
          for (const store of rest) html += storeCard(store, false);
          html += '</div>';
        }
      } else {
        // No flavor filter ‚Äî single flat list sorted by distance
        allStores.sort((a, b) => a._dist - b._dist);
        const total = allStores.length;
        html += `<div class="results-group">${quipHtml}<h3 class="results-group-title">Results (${total})</h3>`;
        for (const store of allStores) html += storeCard(store, false);
        html += '</div>';
      }

      // fitBounds: only on explicit searches (not map moves)
      if (!skipFitBounds && allBounds.isValid()) {
        skipMoveHandler = true;
        map.fitBounds(allBounds, { padding: [30, 30], maxZoom: 12 });
      }

      resultsBody.innerHTML = html || '<div class="no-results">No results.</div>';
      resultsSection.hidden = false;
    }

    // Fetch primary brand data via locator API (returns API response or null)
    async function doPrimarySearch() {
      const location = locationInput.value.trim();
      if (!location) return null;
      const flavor = flavorInput.value.trim();
      let url = `${WORKER_BASE}/api/v1/nearby-flavors?location=${encodeURIComponent(location)}`;
      if (flavor) url += `&flavor=${encodeURIComponent(flavor)}`;
      try {
        const resp = await fetch(url);
        if (!resp.ok) return null;
        return await resp.json();
      } catch { return null; }
    }

    // Fetch brand stores + their flavors
    async function doBrandSearch(brands) {
      const stores = await loadBrandStores();
      const filtered = stores.filter(s => brands.includes(s.brand));
      if (filtered.length === 0) return [];

      const results = await Promise.all(filtered.map(async (store) => {
        try {
          const resp = await fetch(`${WORKER_BASE}/api/v1/flavors?slug=${encodeURIComponent(store.slug)}`);
          if (!resp.ok) return { ...store, flavor: 'Unavailable' };
          const data = await resp.json();
          const today = new Date().toISOString().slice(0, 10);
          const todayFlavor = (data.flavors || []).find(f => f.date === today);
          const fl = todayFlavor || (data.flavors && data.flavors[0]);
          return { ...store, flavor: fl ? (fl.title || fl.flavor || 'Unavailable') : 'Unavailable', description: fl ? (fl.description || '') : '' };
        } catch {
          return { ...store, flavor: 'Unavailable' };
        }
      }));
      return results;
    }

    // Flavor keywords for matching ingredients not in the name
    const FLAVOR_KEYWORDS = {
      'Mint Explosion': 'oreo cookie chocolate fudge',
      'Brownie Thunder': 'brownie chocolate caramel',
      'Crazy for Cookie Dough': 'chocolate chip vanilla',
      'Dark Chocolate Decadence': 'cocoa fudge',
      'Dark Chocolate PB Crunch': 'peanut butter reeses',
      'Really Reese\'s': 'peanut butter chocolate reeses',
      'Snickers Swirl': 'peanut caramel nougat chocolate',
      'Turtle': 'caramel pecan chocolate fudge',
      'Turtle Cheesecake': 'caramel pecan chocolate cheesecake',
      'Turtle Dove': 'caramel pecan chocolate dove',
    };

    // Custom flavor dropdown autocomplete
    function showFlavorDropdown() {
      const query = flavorInput.value.trim().toLowerCase();
      if (!query) { flavorDropdown.hidden = true; return; }
      const matches = KNOWN_FLAVORS.filter(f =>
        f.toLowerCase().includes(query) ||
        (FLAVOR_KEYWORDS[f] && FLAVOR_KEYWORDS[f].includes(query))
      );
      if (matches.length === 0) { flavorDropdown.hidden = true; return; }
      flavorDropdown.innerHTML = matches.map(f =>
        `<div class="flavor-option">${escapeHtml(f)}</div>`
      ).join('');
      flavorDropdown.hidden = false;
    }

    flavorInput.addEventListener('input', showFlavorDropdown);

    flavorInput.addEventListener('focus', () => {
      if (flavorInput.value.trim()) showFlavorDropdown();
    });

    flavorDropdown.addEventListener('click', (e) => {
      const opt = e.target.closest('.flavor-option');
      if (!opt) return;
      flavorInput.value = opt.textContent;
      flavorDropdown.hidden = true;
    });

    document.addEventListener('click', (e) => {
      if (!flavorInput.contains(e.target) && !flavorDropdown.contains(e.target)) {
        flavorDropdown.hidden = true;
      }
    });

    // Read URL params on load
    function readUrlParams() {
      const params = new URLSearchParams(window.location.search);
      if (params.get('flavor')) flavorInput.value = params.get('flavor');
      if (params.get('location')) locationInput.value = params.get('location');
      if (params.get('location')) doSearch();
    }

    // Update URL without reload
    function updateUrl() {
      const params = new URLSearchParams();
      if (flavorInput.value.trim()) params.set('flavor', flavorInput.value.trim());
      if (locationInput.value.trim()) params.set('location', locationInput.value.trim());
      const qs = params.toString();
      const newUrl = qs ? `${window.location.pathname}?${qs}` : window.location.pathname;
      history.replaceState(null, '', newUrl);
    }

    // Geolocation
    geolocateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        return;
      }
      geolocateBtn.disabled = true;
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          locationInput.value = `${pos.coords.latitude.toFixed(4)},${pos.coords.longitude.toFixed(4)}`;
          geolocateBtn.disabled = false;
          doSearch();
        },
        (err) => {
          geolocateBtn.disabled = false;
          // Fall back to IP-based geolocation
          autoGeolocate();
        },
        { timeout: 5000 }
      );
    });

    async function autoGeolocate() {
      try {
        const resp = await fetch(`${WORKER_BASE}/api/v1/geolocate`);
        const geo = await resp.json();
        if (geo.city && geo.state) {
          locationInput.value = `${geo.city}, ${geo.state}`;
          doSearch();
        }
      } catch (err) {
        console.debug('Geolocation unavailable:', err);
      }
    }

    // Search ‚Äî always include Culver's when user explicitly searches
    searchBtn.addEventListener('click', () => {
      if (!activeBrands.has('culvers')) {
        activeBrands.add('culvers');
        syncChipStyles();
      }
      doSearch();
    });
    locationInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (!activeBrands.has('culvers')) { activeBrands.add('culvers'); syncChipStyles(); }
        doSearch();
      }
    });
    flavorInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (!activeBrands.has('culvers')) { activeBrands.add('culvers'); syncChipStyles(); }
        doSearch();
      }
    });

    // Reverse geocode coords to city/state (Culver's API doesn't accept raw lat,lon)
    async function reverseGeocode(lat, lng) {
      try {
        const resp = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&zoom=10`);
        const data = await resp.json();
        const addr = data.address || {};
        const city = addr.city || addr.town || addr.village || addr.county || '';
        const state = addr.state || '';
        return city && state ? `${city}, ${state}` : city || `${lat.toFixed(4)},${lng.toFixed(4)}`;
      } catch {
        return `${lat.toFixed(4)},${lng.toFixed(4)}`;
      }
    }

    // Debounced map move handler for dynamic search
    let moveTimer = null;
    map.on('moveend', () => {
      if (skipMoveHandler) { skipMoveHandler = false; return; }
      if (!activeBrands.has('culvers')) return;
      clearTimeout(moveTimer);
      moveTimer = setTimeout(async () => {
        const center = map.getCenter();
        const placeName = await reverseGeocode(center.lat, center.lng);
        locationInput.value = placeName;
        doSearch(true);
      }, 300);
    });

    async function doSearch(fromMapMove = false) {
      const location = locationInput.value.trim();
      if (!location && activeBrands.has('culvers')) {
        locationInput.focus();
        return;
      }
      updateUrl();
      searchBtn.disabled = true;
      searchBtn.textContent = 'Searching...';
      await refreshResults(fromMapMove);
      searchBtn.disabled = false;
      searchBtn.textContent = 'Search';
    }

    function renderSuggestions(data) {
      const intros = [
        'You could broaden your horizons and try',
        'How about something a little different?',
        'What about something out of left field?',
        'Might I interest you in',
        'Live a little ‚Äî go for',
        'Plot twist:',
        'Hear me out ‚Äî',
        'The universe is telling you to try',
        'Your taste buds called, they want',
        'Bold move incoming:',
        'Cone-sider trying',
        'Don\'t have a meltdown ‚Äî try',
        'Sundae funday alternative:',
        'This one\'s the real scoop:',
        'Spoon-worthy option:',
        'Worth the brain freeze:',
      ];
      const shuffled = intros.sort(() => Math.random() - 0.5);
      const lines = data.suggestions.map((s, i) => {
        const intro = shuffled[i % shuffled.length];
        const link = `<button class="suggestion-link" data-flavor="${escapeAttr(s.flavor)}">${escapeHtml(s.flavor)}</button>`;
        const count = `(${s.count} store${s.count > 1 ? 's' : ''})`;
        return `${intro} ${link} ${count}`;
      });
      suggestionsContent.innerHTML = `<strong>No ${escapeHtml(data.query.flavor)} today.</strong><br>${lines.join('<br>')}`;
      suggestionsPanel.hidden = false;
      suggestionsPanel.querySelectorAll('.suggestion-link').forEach(btn => {
        btn.addEventListener('click', () => {
          flavorInput.value = btn.dataset.flavor;
          doSearch();
        });
      });
    }

    // Custom map icons
    const greenIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41],
    });

    const blueIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41],
    });

    const defaultIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41],
    });

    function storePopup(store, isMatch) {
      const matchBadge = isMatch ? ' <span class="popup-match">MATCH</span>' : '';
      const desc = store.description ? `<br><small>${escapeHtml(store.description)}</small>` : '';
      const nameColor = store.brand && BRAND_COLORS[store.brand] ? ` style="color:${BRAND_COLORS[store.brand]}"` : '';
      return `<div class="store-popup">
        <strong${nameColor}>${escapeHtml(store.name)}</strong>${matchBadge}<br>
        ${escapeHtml(store.address)}<br>
        <em>${escapeHtml(store.flavor)}</em>${desc}
      </div>`;
    }

    function brandClass(store) {
      if (store.brand && BRAND_COLORS[store.brand]) return ` brand-${store.brand}`;
      return '';
    }

    function storeCard(store, isMatch) {
      const matchClass = isMatch ? ' store-card-match' : (store.brand ? brandClass(store) : ' brand-culvers');
      const nameColor = store.brand && BRAND_COLORS[store.brand] ? ` style="color:${BRAND_COLORS[store.brand]}"` : '';
      const culversUrl = store.slug ? (store.brand ? '#' : `https://www.culvers.com/restaurants/${encodeURIComponent(store.slug)}`) : '#';
      const linkText = store.brand ? '' : `<a class="store-card-link" href="${culversUrl}" target="_blank" rel="noopener">View on culvers.com</a>`;
      const desc = store.description ? `<div class="store-card-description">${escapeHtml(store.description)}</div>` : '';
      const distHtml = store._dist != null ? `<span class="store-card-rank">${store._dist.toFixed(1)} mi</span>` : '';
      return `<div class="store-card${matchClass}">
        <div class="store-card-header">
          <span class="store-card-name"${nameColor}>${escapeHtml(store.name)}</span>
          ${distHtml}
        </div>
        <div class="store-card-address">${escapeHtml(store.address || '')}</div>
        <div class="store-card-flavor">${escapeHtml(store.flavor || 'Loading...')}</div>
        ${desc}
        ${linkText}
      </div>`;
    }

    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function escapeAttr(str) {
      return escapeHtml(str);
    }

    // Load brand stores from stores.json
    async function loadBrandStores() {
      if (brandStores.length > 0) return brandStores;
      try {
        const resp = await fetch('stores.json?v=' + new Date().toISOString().slice(0, 10));
        const data = await resp.json();
        brandStores = (data.stores || []).filter(s => s.brand);
      } catch (err) {
        console.error('Failed to load brand stores:', err);
      }
      return brandStores;
    }

    // Auto-detect location on load via Cloudflare geolocation, then search
    async function initLocation() {
      try {
        const resp = await fetch(`${WORKER_BASE}/api/v1/geolocate`);
        const geo = await resp.json();
        if (geo.city && geo.state && !locationInput.value) {
          locationInput.value = `${geo.city}, ${geo.state}`;
          doSearch();
        }
      } catch (err) {
        console.debug('Auto-geolocation unavailable:', err);
      }
    }

    // Init
    const params = new URLSearchParams(window.location.search);
    if (params.get('location')) {
      readUrlParams();
    } else {
      initLocation();
    }
  </script>
</body>
</html>
