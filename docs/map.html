<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custard Map ‚Äî Find a Flavor Near You</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üç¶</text></svg>">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
</head>
<body>
  <header>
    <h1>Custard Map</h1>
    <p>Find a Culver's Flavor of the Day near you.</p>
    <nav class="nav-links">
      <a href="index.html">Calendar</a>
      <a href="alerts.html">Alerts</a>
    </nav>
  </header>

  <main>
    <section id="search-controls">
      <div class="filter-row">
        <div class="filter-group">
          <label for="flavor-input">Flavor (optional)</label>
          <div class="flavor-input-wrap">
            <input type="text" id="flavor-input" placeholder="e.g. Mint Explosion" autocomplete="off">
            <div id="flavor-dropdown" class="flavor-dropdown" hidden></div>
          </div>
        </div>
        <div class="filter-group filter-group-location">
          <label for="location-input">Location</label>
          <div class="location-row">
            <input type="text" id="location-input" placeholder="Zip code or city...">
            <button id="geolocate-btn" title="Use my location" class="icon-btn">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="filter-group filter-group-btn">
          <label>&nbsp;</label>
          <button id="search-btn" class="btn btn-search">Search</button>
        </div>
      </div>
      <div class="brand-chips">
        <button class="brand-chip" data-brand="all">All</button>
        <button class="brand-chip active" data-brand="culvers" style="background:#003366;border-color:transparent">Culver's</button>
        <button class="brand-chip" data-brand="kopps">Kopp's</button>
        <button class="brand-chip" data-brand="gilles">Gille's</button>
        <button class="brand-chip" data-brand="hefners">Hefner's</button>
        <button class="brand-chip" data-brand="kraverz">Kraverz</button>
        <button class="brand-chip" data-brand="oscars">Oscar's</button>
      </div>
    </section>

    <section id="suggestions-panel" hidden>
      <div id="suggestions-content"></div>
    </section>

    <section id="map-container">
      <div id="map"></div>
    </section>

    <section id="results-list" hidden>
      <h2 id="results-heading">Results</h2>
      <div id="results-body"></div>
    </section>
  </main>

  <footer>
    <p>Not affiliated with Culver's. Data sourced from <a href="https://www.culvers.com" target="_blank" rel="noopener">culvers.com</a>.</p>
  </footer>

  <script>
    const WORKER_BASE = 'https://custard-calendar.chris-kaschner.workers.dev';

    const BRAND_COLORS = {
      kopps: '#000000',
      gilles: '#EBCC35',
      hefners: '#93BE46',
      kraverz: '#CE742D',
      oscars: '#BC272C',
    };

    const BRAND_DISPLAY = {
      kopps: "Kopp's",
      gilles: "Gille's",
      hefners: "Hefner's",
      kraverz: "Kraverz",
      oscars: "Oscar's",
    };

    // Known flavors for autocomplete
    const KNOWN_FLAVORS = [
      'Andes Mint Avalanche', 'Blackberry Cobbler', 'Brownie Thunder',
      'Butter Pecan', 'Caramel Cashew', 'Caramel Fudge Cookie Dough',
      'Caramel Pecan', 'Caramel Turtle', 'Chocolate Caramel Twist',
      'Chocolate Heath Crunch', 'Chocolate Oreo Volcano', 'Chocolate Volcano',
      'Crazy for Cookie Dough', 'Dark Chocolate Decadence',
      'Dark Chocolate PB Crunch', 'Georgia Peach Pecan',
      'Lemon Berry Layer Cake', 'Lemon Dash Cookie', 'Mint Cookie',
      'Mint Explosion', 'OREO Cheesecake', 'OREO Cookies and Cream',
      'Peanut Butter Cup', 'Raspberry Cheesecake', 'Really Reese\'s',
      'Salted Caramel Pecan Pie', 'Snickers Swirl',
      'Strawberry Cheesecake', 'Turtle', 'Turtle Cheesecake',
      'Turtle Dove', 'Vanilla',
    ];

    // DOM elements
    const flavorInput = document.getElementById('flavor-input');
    const flavorDropdown = document.getElementById('flavor-dropdown');
    const locationInput = document.getElementById('location-input');
    const geolocateBtn = document.getElementById('geolocate-btn');
    const searchBtn = document.getElementById('search-btn');
    const suggestionsPanel = document.getElementById('suggestions-panel');
    const suggestionsContent = document.getElementById('suggestions-content');
    const resultsSection = document.getElementById('results-list');
    const resultsHeading = document.getElementById('results-heading');
    const resultsBody = document.getElementById('results-body');

    // Map setup
    const map = L.map('map').setView([43.0, -89.5], 7); // Default: Wisconsin
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: 18,
    }).addTo(map);

    let markers = L.layerGroup().addTo(map);
    let brandStores = []; // loaded from stores.json
    let skipMoveHandler = false; // flag to skip moveend during programmatic fitBounds

    // Brand chip state
    const BRAND_CHIP_COLORS = { culvers: '#003366', ...BRAND_COLORS };
    const activeBrands = new Set(['culvers']);

    const ALL_BRANDS = ['culvers', 'kopps', 'gilles', 'hefners', 'kraverz', 'oscars'];

    function syncChipStyles() {
      document.querySelectorAll('.brand-chip').forEach(chip => {
        const brand = chip.dataset.brand;
        if (brand === 'all') {
          const allActive = ALL_BRANDS.every(b => activeBrands.has(b));
          chip.classList.toggle('active', allActive);
          chip.style.background = allActive ? '#555' : '';
          chip.style.borderColor = allActive ? 'transparent' : '';
        } else {
          const isActive = activeBrands.has(brand);
          chip.classList.toggle('active', isActive);
          chip.style.background = isActive ? (BRAND_CHIP_COLORS[brand] || '') : '';
          chip.style.borderColor = isActive ? 'transparent' : '';
        }
      });
    }

    // Wire up brand chips
    document.querySelectorAll('.brand-chip').forEach(chip => {
      chip.addEventListener('click', () => {
        const brand = chip.dataset.brand;
        if (brand === 'all') {
          const allActive = ALL_BRANDS.every(b => activeBrands.has(b));
          if (allActive) {
            ALL_BRANDS.forEach(b => activeBrands.delete(b));
          } else {
            ALL_BRANDS.forEach(b => activeBrands.add(b));
          }
        } else if (activeBrands.has(brand)) {
          activeBrands.delete(brand);
        } else {
          activeBrands.add(brand);
        }
        syncChipStyles();
        refreshResults();
      });
    });

    let cachedBrandResults = []; // cached so map moves don't re-fetch
    let cachedBrandKey = '';    // tracks which brands are cached

    async function refreshResults(skipFitBounds = false) {
      const hasCulvers = activeBrands.has('culvers');
      const nonCulversBrands = [...activeBrands].filter(b => b !== 'culvers');

      // If nothing active, just clear
      if (!hasCulvers && nonCulversBrands.length === 0) {
        markers.clearLayers();
        resultsSection.hidden = true;
        cachedBrandResults = [];
        cachedBrandKey = '';
        return;
      }

      // Only re-fetch brands when the active set changes
      const brandKey = nonCulversBrands.sort().join(',');
      const needBrandFetch = brandKey && brandKey !== cachedBrandKey;

      // Kick off Culver's search; only fetch brands if selection changed
      const culversPromise = hasCulvers && locationInput.value.trim() ? doCulversSearch() : Promise.resolve(null);
      const brandPromise = needBrandFetch ? doBrandSearch(nonCulversBrands) : Promise.resolve(null);

      const [culversData, freshBrandResults] = await Promise.all([culversPromise, brandPromise]);

      if (freshBrandResults !== null) {
        cachedBrandResults = freshBrandResults;
        cachedBrandKey = brandKey;
      }
      const brandResults = brandKey ? cachedBrandResults : [];

      // Merge and render ‚Äî use separate bounds so brand stores don't pull the map away
      markers.clearLayers();
      const culversBounds = L.latLngBounds(); // only Culver's results affect fitBounds
      let html = '';

      if (culversData) {
        const hasFlavorFilter = !!culversData.query.flavor;
        // Render Culver's markers
        for (const store of culversData.matches) {
          if (!store.lat || !store.lon) continue;
          const marker = L.marker([store.lat, store.lon], { icon: greenIcon }).bindPopup(storePopup(store, true));
          markers.addLayer(marker);
          culversBounds.extend([store.lat, store.lon]);
        }
        for (const store of culversData.nearby) {
          if (!store.lat || !store.lon) continue;
          const marker = L.marker([store.lat, store.lon], {
            icon: hasFlavorFilter ? blueIcon : defaultIcon,
          }).bindPopup(storePopup(store, false));
          markers.addLayer(marker);
          culversBounds.extend([store.lat, store.lon]);
        }

        // Suggestions
        if (hasFlavorFilter && culversData.matches.length === 0 && culversData.suggestions.length > 0) {
          renderSuggestions(culversData);
        } else {
          suggestionsPanel.hidden = true;
        }

        // Culver's result cards
        if (hasFlavorFilter && culversData.matches.length > 0) {
          html += `<div class="results-group"><h3 class="results-group-title match-title">Stores with ${escapeHtml(culversData.query.flavor)} (${culversData.matches.length})</h3>`;
          for (const store of culversData.matches) html += storeCard(store, true);
          html += '</div>';
        }
        if (culversData.nearby.length > 0) {
          let nearbyLabel;
          if (!hasFlavorFilter) {
            nearbyLabel = `Nearby stores (${culversData.nearby.length})`;
          } else if (culversData.matches.length > 0) {
            const altIntros = [
              'Meanwhile, nearby',
              'Not your flavor? These stores beg to differ',
              'Other scoops in the neighborhood',
              'The rest of the cone-petition',
              'What the other stores are dishing out',
              'In other frozen news',
              'But wait, there\'s more custard',
              'The supporting cast',
            ];
            nearbyLabel = altIntros[Math.floor(Math.random() * altIntros.length)];
          } else {
            const nearbyIntros = [
              `No ${escapeHtml(culversData.query.flavor)} nearby ‚Äî here's what's scooping instead`,
              `${escapeHtml(culversData.query.flavor)}? Not today. But check out what is`,
              `Fresh out of ${escapeHtml(culversData.query.flavor)} ‚Äî but never fresh out of options`,
              `The custard must flow ‚Äî just not ${escapeHtml(culversData.query.flavor)} right now`,
              `${escapeHtml(culversData.query.flavor)} is playing hard to get. These aren't`,
              `No ${escapeHtml(culversData.query.flavor)}? That's the way the cookie crumbles. Here's what's left`,
              `We all scream for ${escapeHtml(culversData.query.flavor)} but today we settle`,
              `Life gave you no ${escapeHtml(culversData.query.flavor)}. Make custard-ade`,
            ];
            nearbyLabel = nearbyIntros[Math.floor(Math.random() * nearbyIntros.length)];
          }
          html += `<div class="results-group"><h3 class="results-group-title">${nearbyLabel}</h3>`;
          for (const store of culversData.nearby) html += storeCard(store, false);
          html += '</div>';
        }
      } else {
        suggestionsPanel.hidden = true;
      }

      // Easter egg: no Culver's, brands only, zoomed into MKE
      if (!hasCulvers && brandResults.length > 0) {
        const center = map.getCenter();
        const zoom = map.getZoom();
        const nearMKE = center.lat > 42.8 && center.lat < 43.3 && center.lng > -88.2 && center.lng < -87.7;
        if (nearMKE && zoom >= 9) {
          const quips = [
            "Oh sure, skip the ButterBurgers, that'll end well.",
            "Oh, too good for Culver's now, are we?",
            "Someone's been spending too much time on Brady Street.",
            "Look at you, Mr. Third Ward.",
            "Ope, found the custard hipster.",
            "Real Milwaukeeans eat both, bud.",
            "You can take the kid outta Culver's, but you can't take the Culver's outta the kid.",
            "Your aunt from Waukesha is very disappointed in you right now.",
            "Bold move, Cotton. Let's see if it pays off.",
            "Tell me you're from the East Side without telling me you're from the East Side.",
            "You're just going to scootch past Culver's?!?!",
            "Were you there when they finally towed away Deep Thought?",
            "Summerfest is 11 days a year. Custard snobbery is forever.",
          ];
          html += `<div class="results-group"><p style="font-style:italic;color:#888;text-align:center;margin:0.5rem 0">${quips[Math.floor(Math.random() * quips.length)]}</p></div>`;
        }
      }

      // Render brand results
      if (brandResults.length > 0) {
        // Group by brand
        const byBrand = {};
        for (const store of brandResults) {
          const b = store.brand;
          if (!byBrand[b]) byBrand[b] = [];
          byBrand[b].push(store);
        }
        for (const [brand, stores] of Object.entries(byBrand)) {
          const color = BRAND_COLORS[brand] || '#003366';
          for (const store of stores) {
            if (!store.lat && !store.lng) continue;
            const marker = L.circleMarker([store.lat, store.lng], {
              radius: 10, fillColor: color, color: '#fff', weight: 2, fillOpacity: 0.9,
            }).bindPopup(storePopup(store, false));
            markers.addLayer(marker);
          }
          html += `<div class="results-group"><h3 class="results-group-title">${escapeHtml(BRAND_DISPLAY[brand] || brand)} (${stores.length})</h3>`;
          for (const store of stores) html += storeCard(store, false);
          html += '</div>';
        }
      }

      // fitBounds: only on explicit searches (not map moves), and only to Culver's results
      // When only brand chips are active (no Culver's), fit to brand stores on first load
      if (!skipFitBounds) {
        if (culversBounds.isValid()) {
          skipMoveHandler = true;
          map.fitBounds(culversBounds, { padding: [30, 30], maxZoom: 12 });
        } else if (brandResults.length > 0 && !hasCulvers) {
          const brandBounds = L.latLngBounds();
          for (const store of brandResults) {
            if (store.lat && store.lng) brandBounds.extend([store.lat, store.lng]);
          }
          if (brandBounds.isValid()) {
            skipMoveHandler = true;
            map.fitBounds(brandBounds, { padding: [30, 30], maxZoom: 12 });
          }
        }
      }

      resultsBody.innerHTML = html || '<div class="no-results">No results.</div>';
      resultsSection.hidden = false;
    }

    // Fetch Culver's data (returns API response or null)
    async function doCulversSearch() {
      const location = locationInput.value.trim();
      if (!location) return null;
      const flavor = flavorInput.value.trim();
      let url = `${WORKER_BASE}/api/nearby-flavors?location=${encodeURIComponent(location)}`;
      if (flavor) url += `&flavor=${encodeURIComponent(flavor)}`;
      try {
        const resp = await fetch(url);
        if (!resp.ok) return null;
        return await resp.json();
      } catch { return null; }
    }

    // Fetch brand stores + their flavors
    async function doBrandSearch(brands) {
      const stores = await loadBrandStores();
      const filtered = stores.filter(s => brands.includes(s.brand));
      if (filtered.length === 0) return [];

      const results = await Promise.all(filtered.map(async (store) => {
        try {
          const resp = await fetch(`${WORKER_BASE}/api/flavors?slug=${encodeURIComponent(store.slug)}`);
          if (!resp.ok) return { ...store, flavor: 'Unavailable' };
          const data = await resp.json();
          const today = new Date().toISOString().slice(0, 10);
          const todayFlavor = (data.flavors || []).find(f => f.date === today);
          const fl = todayFlavor || (data.flavors && data.flavors[0]);
          return { ...store, flavor: fl ? (fl.title || fl.flavor || 'Unavailable') : 'Unavailable', description: fl ? (fl.description || '') : '' };
        } catch {
          return { ...store, flavor: 'Unavailable' };
        }
      }));
      return results;
    }

    // Flavor keywords for matching ingredients not in the name
    const FLAVOR_KEYWORDS = {
      'Mint Explosion': 'oreo cookie chocolate fudge',
      'Brownie Thunder': 'brownie chocolate caramel',
      'Crazy for Cookie Dough': 'chocolate chip vanilla',
      'Dark Chocolate Decadence': 'cocoa fudge',
      'Dark Chocolate PB Crunch': 'peanut butter reeses',
      'Really Reese\'s': 'peanut butter chocolate reeses',
      'Snickers Swirl': 'peanut caramel nougat chocolate',
      'Turtle': 'caramel pecan chocolate fudge',
      'Turtle Cheesecake': 'caramel pecan chocolate cheesecake',
      'Turtle Dove': 'caramel pecan chocolate dove',
    };

    // Custom flavor dropdown autocomplete
    function showFlavorDropdown() {
      const query = flavorInput.value.trim().toLowerCase();
      if (!query) { flavorDropdown.hidden = true; return; }
      const matches = KNOWN_FLAVORS.filter(f =>
        f.toLowerCase().includes(query) ||
        (FLAVOR_KEYWORDS[f] && FLAVOR_KEYWORDS[f].includes(query))
      );
      if (matches.length === 0) { flavorDropdown.hidden = true; return; }
      flavorDropdown.innerHTML = matches.map(f =>
        `<div class="flavor-option">${escapeHtml(f)}</div>`
      ).join('');
      flavorDropdown.hidden = false;
    }

    flavorInput.addEventListener('input', showFlavorDropdown);

    flavorInput.addEventListener('focus', () => {
      if (flavorInput.value.trim()) showFlavorDropdown();
    });

    flavorDropdown.addEventListener('click', (e) => {
      const opt = e.target.closest('.flavor-option');
      if (!opt) return;
      flavorInput.value = opt.textContent;
      flavorDropdown.hidden = true;
    });

    document.addEventListener('click', (e) => {
      if (!flavorInput.contains(e.target) && !flavorDropdown.contains(e.target)) {
        flavorDropdown.hidden = true;
      }
    });

    // Read URL params on load
    function readUrlParams() {
      const params = new URLSearchParams(window.location.search);
      if (params.get('flavor')) flavorInput.value = params.get('flavor');
      if (params.get('location')) locationInput.value = params.get('location');
      if (params.get('location')) doSearch();
    }

    // Update URL without reload
    function updateUrl() {
      const params = new URLSearchParams();
      if (flavorInput.value.trim()) params.set('flavor', flavorInput.value.trim());
      if (locationInput.value.trim()) params.set('location', locationInput.value.trim());
      const qs = params.toString();
      const newUrl = qs ? `${window.location.pathname}?${qs}` : window.location.pathname;
      history.replaceState(null, '', newUrl);
    }

    // Geolocation
    geolocateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        return;
      }
      geolocateBtn.disabled = true;
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          locationInput.value = `${pos.coords.latitude.toFixed(4)},${pos.coords.longitude.toFixed(4)}`;
          geolocateBtn.disabled = false;
          doSearch();
        },
        (err) => {
          geolocateBtn.disabled = false;
          // Fall back to IP-based geolocation
          autoGeolocate();
        },
        { timeout: 5000 }
      );
    });

    async function autoGeolocate() {
      try {
        const resp = await fetch(`${WORKER_BASE}/api/geolocate`);
        const geo = await resp.json();
        if (geo.city && geo.state) {
          locationInput.value = `${geo.city}, ${geo.state}`;
          doSearch();
        }
      } catch (err) {
        console.debug('Geolocation unavailable:', err);
      }
    }

    // Search
    searchBtn.addEventListener('click', doSearch);
    locationInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') doSearch();
    });
    flavorInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') doSearch();
    });

    // Debounced map move handler for dynamic search
    let moveTimer = null;
    map.on('moveend', () => {
      if (skipMoveHandler) { skipMoveHandler = false; return; }
      if (!activeBrands.has('culvers')) return; // only dynamic-search for Culver's
      clearTimeout(moveTimer);
      moveTimer = setTimeout(() => {
        const center = map.getCenter();
        locationInput.value = `${center.lat.toFixed(4)},${center.lng.toFixed(4)}`;
        doSearch(true);
      }, 300);
    });

    async function doSearch(fromMapMove = false) {
      const location = locationInput.value.trim();
      if (!location && activeBrands.has('culvers')) {
        locationInput.focus();
        return;
      }
      updateUrl();
      searchBtn.disabled = true;
      searchBtn.textContent = 'Searching...';
      await refreshResults(fromMapMove);
      searchBtn.disabled = false;
      searchBtn.textContent = 'Search';
    }

    function renderSuggestions(data) {
      const intros = [
        'You could broaden your horizons and try',
        'How about something a little different?',
        'What about something out of left field?',
        'Might I interest you in',
        'Live a little ‚Äî go for',
        'Plot twist:',
        'Hear me out ‚Äî',
        'The universe is telling you to try',
        'Your taste buds called, they want',
        'Bold move incoming:',
        'Cone-sider trying',
        'Don\'t have a meltdown ‚Äî try',
        'Sundae funday alternative:',
        'This one\'s the real scoop:',
        'Spoon-worthy option:',
        'Worth the brain freeze:',
      ];
      const shuffled = intros.sort(() => Math.random() - 0.5);
      const lines = data.suggestions.map((s, i) => {
        const intro = shuffled[i % shuffled.length];
        const link = `<button class="suggestion-link" data-flavor="${escapeAttr(s.flavor)}">${escapeHtml(s.flavor)}</button>`;
        const count = `(${s.count} store${s.count > 1 ? 's' : ''})`;
        return `${intro} ${link} ${count}`;
      });
      suggestionsContent.innerHTML = `<strong>No ${escapeHtml(data.query.flavor)} today.</strong><br>${lines.join('<br>')}`;
      suggestionsPanel.hidden = false;
      suggestionsPanel.querySelectorAll('.suggestion-link').forEach(btn => {
        btn.addEventListener('click', () => {
          flavorInput.value = btn.dataset.flavor;
          doSearch();
        });
      });
    }

    // Custom map icons
    const greenIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41],
    });

    const blueIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41],
    });

    const defaultIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41],
    });

    function storePopup(store, isMatch) {
      const matchBadge = isMatch ? ' <span class="popup-match">MATCH</span>' : '';
      const desc = store.description ? `<br><small>${escapeHtml(store.description)}</small>` : '';
      const nameColor = store.brand && BRAND_COLORS[store.brand] ? ` style="color:${BRAND_COLORS[store.brand]}"` : '';
      return `<div class="store-popup">
        <strong${nameColor}>${escapeHtml(store.name)}</strong>${matchBadge}<br>
        ${escapeHtml(store.address)}<br>
        <em>${escapeHtml(store.flavor)}</em>${desc}
      </div>`;
    }

    function brandClass(store) {
      if (store.brand && BRAND_COLORS[store.brand]) return ` brand-${store.brand}`;
      return '';
    }

    function storeCard(store, isMatch) {
      const matchClass = isMatch ? ' store-card-match' : (store.brand ? brandClass(store) : ' brand-culvers');
      const nameColor = store.brand && BRAND_COLORS[store.brand] ? ` style="color:${BRAND_COLORS[store.brand]}"` : '';
      const culversUrl = store.slug ? (store.brand ? '#' : `https://www.culvers.com/restaurants/${encodeURIComponent(store.slug)}`) : '#';
      const linkText = store.brand ? '' : `<a class="store-card-link" href="${culversUrl}" target="_blank" rel="noopener">View on culvers.com</a>`;
      const desc = store.description ? `<div class="store-card-description">${escapeHtml(store.description)}</div>` : '';
      const rankHtml = store.rank != null ? `<span class="store-card-rank">#${store.rank}</span>` : '';
      return `<div class="store-card${matchClass}">
        <div class="store-card-header">
          <span class="store-card-name"${nameColor}>${escapeHtml(store.name)}</span>
          ${rankHtml}
        </div>
        <div class="store-card-address">${escapeHtml(store.address || '')}</div>
        <div class="store-card-flavor">${escapeHtml(store.flavor || 'Loading...')}</div>
        ${desc}
        ${linkText}
      </div>`;
    }

    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function escapeAttr(str) {
      return escapeHtml(str);
    }

    // Load brand stores from stores.json
    async function loadBrandStores() {
      if (brandStores.length > 0) return brandStores;
      try {
        const resp = await fetch('stores.json?v=' + new Date().toISOString().slice(0, 10));
        const data = await resp.json();
        brandStores = (data.stores || []).filter(s => s.brand);
      } catch (err) {
        console.error('Failed to load brand stores:', err);
      }
      return brandStores;
    }

    // Auto-detect location on load via Cloudflare geolocation, then search
    async function initLocation() {
      try {
        const resp = await fetch(`${WORKER_BASE}/api/geolocate`);
        const geo = await resp.json();
        if (geo.city && geo.state && !locationInput.value) {
          locationInput.value = `${geo.city}, ${geo.state}`;
          doSearch();
        }
      } catch (err) {
        console.debug('Auto-geolocation unavailable:', err);
      }
    }

    // Init
    const params = new URLSearchParams(window.location.search);
    if (params.get('location')) {
      readUrlParams();
    } else {
      initLocation();
    }
  </script>
</body>
</html>
